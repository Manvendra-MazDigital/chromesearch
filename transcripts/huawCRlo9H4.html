<p class="speaker"><span class="line" data-starttime="2"><span class="speakerName">Lars Bak</span>: Good morning, and welcome to the </span><span class="line" data-startTime="2">second day of Google I/O. I hope you all enjoyed </span><span class="line" data-startTime="6">the party yesterday with Billy Idol. </span><span class="line" data-startTime="6">[ Laughter ] </span></p>

<p class="speaker"><span class="line" data-starttime="10"><span class="speakerName">Lars Bak</span>: Yeah. From my youth. </span><span class="line" data-startTime="10">[ Laughter ] </span></p>

<p class="speaker"><span class="line" data-starttime="14"><span class="speakerName">Lars Bak</span>: So we want to talk about web programming </span><span class="line" data-startTime="14">languages and virtual machines and we're trying </span><span class="line" data-startTime="22">to argue why it's important to always make </span><span class="line" data-startTime="22">it faster so that you guys can make better </span><span class="line" data-startTime="29">applications. </span><span class="line" data-startTime="29">I'm Lars Bak. I'm the blue guy. And this is </span><span class="line" data-startTime="33">Kasper Lund &mdash; </span></p>

<p class="speaker"><span class="line" data-starttime="33"><span class="speakerName">Kasper Lund</span>: I'm the red guy. </span><span class="line" data-startTime="35">Lars Bak: &mdash; the red guy. </span><span class="line" data-startTime="35">[ Laughter ] </span></p>

<p class="speaker"><span class="line" data-starttime="36"><span class="speakerName">Lars Bak</span>: And we are from Google, from the </span><span class="line" data-startTime="36">Danish engineering office, so if we look tired, </span><span class="line" data-startTime="44">it's jet lag. </span> <span class="line" data-startTime="44">All right. So just to know &mdash; so you know </span><span class="line" data-startTime="51">who we are, we've been working on virtual </span><span class="line" data-startTime="51">machines for too long. I started in '86, and </span><span class="line" data-startTime="58">in '86 working on virtual machines for their </span><span class="line" data-startTime="58">programming languages was sort of a little </span><span class="line" data-startTime="62">bit niche, and it was only research communities </span><span class="line" data-startTime="62">that had an interest in it. </span> <span class="line" data-startTime="67">But given today we have several hundred people </span><span class="line" data-startTime="67">here, I'm pleased that there's more interest </span><span class="line" data-startTime="72">for it. </span> <span class="line" data-startTime="72">So I started working with Kasper 13 years </span><span class="line" data-startTime="76">ago and we've been doing Java virtual machines, </span><span class="line" data-startTime="76">Smalltalk virtual machines, JavaScript virtual </span><span class="line" data-startTime="84">machines, and now Dart, so we sort of have </span><span class="line" data-startTime="84">a little bit of experience in doing compilers </span><span class="line" data-startTime="89">and garbage collectors, so hopefully we can </span><span class="line" data-startTime="89">tell you about some of our findings over the </span><span class="line" data-startTime="95">last many years. </span> <span class="line" data-startTime="95">So why are we here? We're here because we </span><span class="line" data-startTime="102">truly believe that speed in web browsers fuel </span><span class="line" data-startTime="102">innovations for application developers, right? </span><span class="line" data-startTime="108">The more speed we can give you, the more interesting </span><span class="line" data-startTime="108">applications you can do. And we strongly believe </span><span class="line" data-startTime="113">in the fly-by web, right? Developers do one </span><span class="line" data-startTime="113">application &mdash; it runs on mobile phones and </span><span class="line" data-startTime="118">desktop systems &mdash; and this is just fantastic. </span></p>

<p><span class="line" data-startTime="118">And the source that makes it work is the virtual </span><span class="line" data-startTime="125">machine inside the browser. </span> <span class="line" data-startTime="125">And if we can make it faster, you can take </span><span class="line" data-startTime="129">advantage of it. </span> <span class="line" data-startTime="129">The question is, we have seen a lot of speedup </span><span class="line" data-startTime="134">in browsers over the last, I guess, five years. </span> <span class="line" data-startTime="134">Is it fast enough or do we want more speed? </span><span class="line" data-startTime="140">So we are of the opinion that we need to do </span><span class="line" data-startTime="140">even better, and that is one of the reasons </span><span class="line" data-startTime="146">why we have started on this new venture to </span><span class="line" data-startTime="146">do a Dart platform. </span></p>

<p class="speaker"><span class="line" data-starttime="151"><span class="speakerName">Kasper Lund</span>: So before we dive into the </span><span class="line" data-startTime="151">technical details of virtual machines and </span><span class="line" data-startTime="158">programming for the web, I just wanted to </span><span class="line" data-startTime="158">take you back to 2006 when we started developing </span><span class="line" data-startTime="164">V8. At that point, Web pages had evolved from </span><span class="line" data-startTime="164">being fairly static to being a little bit </span><span class="line" data-startTime="171">more rich, and we were seeing sort of the </span><span class="line" data-startTime="171">first Web applications appear. At the point </span><span class="line" data-startTime="176">in time, you were probably running Firefox </span><span class="line" data-startTime="176">2.0, Internet Explorer 7.0, or some other </span><span class="line" data-startTime="182">browsers there, but it was very clear that </span><span class="line" data-startTime="182">these browsers were not really designed for </span><span class="line" data-startTime="188">long-running, heavy Web applications. They </span><span class="line" data-startTime="188">were designed for the web of two thousand- </span><span class="line" data-startTime="192">&mdash; well, probably 2000, yeah. </span></p>

<p><span class="line" data-startTime="192">And so it was an interesting at that point </span><span class="line" data-startTime="196">in time, 2006, it was just before we were </span><span class="line" data-startTime="196">seeing these applications really come to life </span><span class="line" data-startTime="201">on the web. And even if you &mdash; if you look </span><span class="line" data-startTime="201">at the Web sites I've depicted up here, you </span><span class="line" data-startTime="206">can tell the difference, if you can actually </span><span class="line" data-startTime="206">see it from the back of the room, that in </span><span class="line" data-startTime="210">2008, already then we were seeing pages like </span><span class="line" data-startTime="210">BBC becoming a little bit more interactive </span><span class="line" data-startTime="214">and more rich. </span> <span class="line" data-startTime="214">So in 2006 when we set out to implement a </span><span class="line" data-startTime="220">new virtual machine for JavaScript for the </span><span class="line" data-startTime="220">web, people believed that browsers were essentially </span><span class="line" data-startTime="224">fast enough. Web applications like Gmail and </span><span class="line" data-startTime="224">Google Maps ran fine and people were very </span><span class="line" data-startTime="228">impressed with them. People also believed </span><span class="line" data-startTime="228">that JavaScript was just inherently too slow </span><span class="line" data-startTime="234">for writing heavy client-side computations. </span> <span class="line" data-startTime="234">And even so, people didn't really expect the </span><span class="line" data-startTime="240">JavaScript to improve that much so they didn't </span><span class="line" data-startTime="240">think that the execution of JavaScript was </span><span class="line" data-startTime="244">holding things back. They were okay with having </span><span class="line" data-startTime="244">more code running on the server side and having </span><span class="line" data-startTime="249">fairly limited amounts of logic on the client </span><span class="line" data-startTime="249">side. </span> <span class="line" data-startTime="255">Another key thing for us when we started was </span><span class="line" data-startTime="255">that performance at that point was evaluated </span><span class="line" data-startTime="259">using very simple micro-benchmarks, where </span><span class="line" data-startTime="259">all the emphasis was put on simple loops with </span><span class="line" data-startTime="264">very simple arithmetic and nobody paid any </span><span class="line" data-startTime="264">attention to the overhead for calling methods </span><span class="line" data-startTime="270">or how large applications would perform when </span><span class="line" data-startTime="270">it comes to memory management. </span></p>

<p><span class="line" data-startTime="275">So people were really spending all their time </span><span class="line" data-startTime="275">looking at small, simple loops and trying </span><span class="line" data-startTime="280">to make them run a little bit faster. </span> <span class="line" data-startTime="280">So here's an example of a benchmark that I </span><span class="line" data-startTime="284">think represents that line of thought pretty </span><span class="line" data-startTime="284">well. </span> <span class="line" data-startTime="287">This is a benchmark, a JavaScript benchmark, </span><span class="line" data-startTime="287">from the SunSpider benchmark collection. It's </span><span class="line" data-startTime="291">known as "bit-wise and" and that's all it </span><span class="line" data-startTime="291">does. It computes the bit-wise and for a series </span><span class="line" data-startTime="297">of values here, starting out with a fairly </span><span class="line" data-startTime="297">large number and then it runs through a loop </span><span class="line" data-startTime="301">and you'll probably notice that even on the </span><span class="line" data-startTime="301">iteration, I is zero so when you "and" that </span><span class="line" data-startTime="308">with anything, you'll get zero out. So this </span><span class="line" data-startTime="308">is just a fancy way of computing zero. </span> <span class="line" data-startTime="314">Not exactly something you want to spend a </span><span class="line" data-startTime="314">lot of time on optimizing for, I guess, and </span><span class="line" data-startTime="317">certainly not something that would, if you </span><span class="line" data-startTime="317">actually did optimize this, it would turn </span><span class="line" data-startTime="321">your application any faster. </span></p>

<p><span class="line" data-startTime="321">So SunSpider is a benchmark that sort of represents </span><span class="line" data-startTime="326">some of the things and some of the problems </span><span class="line" data-startTime="326">from sort of the earlier web, and they &mdash; it </span><span class="line" data-startTime="332">is being updated every now and then but not </span><span class="line" data-startTime="332">with any significant differences. This is </span><span class="line" data-startTime="336">from SunSpider 1.0 released a couple of weeks </span><span class="line" data-startTime="336">ago. It's very nice to see that they've added </span><span class="line" data-startTime="341">testing that actually does compute zero but </span><span class="line" data-startTime="341">it's still a really bad benchmark. Making </span><span class="line" data-startTime="346">this faster and tuning V8 for these kind of </span><span class="line" data-startTime="346">things would not make your applications run </span><span class="line" data-startTime="350">any faster, so... </span> <span class="line" data-startTime="350">So when we started designing V8, we had to </span><span class="line" data-startTime="355">make a choice. Like what do we want to optimize </span><span class="line" data-startTime="355">for? </span><span class="line" data-startTime="358">And there are basically two approaches. </span> <span class="line" data-startTime="358">You can optimize for the current apps and </span><span class="line" data-startTime="362">the current benchmarks, and that's a nice </span><span class="line" data-startTime="362">and simple incremental approach, and there's </span><span class="line" data-startTime="367">a good chance you can make things 10%, maybe </span><span class="line" data-startTime="367">20% faster that way. And we chose to optimize </span><span class="line" data-startTime="373">for the apps of the future at that point so </span><span class="line" data-startTime="373">we decided that we wanted to support much </span><span class="line" data-startTime="378">heavier side client-side computations and </span><span class="line" data-startTime="378">we wanted to turn the browser into a scalable </span><span class="line" data-startTime="381">application platform, sort of thus enabling </span><span class="line" data-startTime="381">a new class of Webapps that could be written. </span></p>

<p><span class="line" data-startTime="387">So optimizing a brand-new virtual machine </span><span class="line" data-startTime="387">for some applications that you cannot write </span><span class="line" data-startTime="393">&mdash; or you couldn't write in 2006 &mdash; required </span><span class="line" data-startTime="393">us to come up with some benchmarks and some </span><span class="line" data-startTime="399">metrics that would allow us to make progress </span><span class="line" data-startTime="399">on that problem. </span> <span class="line" data-startTime="402">Which is where the V8 benchmark suite entered </span><span class="line" data-startTime="402">the game. </span> <span class="line" data-startTime="407">So the V8 benchmark suite is a collection </span><span class="line" data-startTime="407">of benchmarks that are structured and mostly </span><span class="line" data-startTime="411">object-oriented, and they're designed to push </span><span class="line" data-startTime="411">the limits of browsers in 2006 but also today, </span><span class="line" data-startTime="418">and it's benchmarks that are mostly proven </span><span class="line" data-startTime="418">valuable in the context of lots of other languages. </span> <span class="line" data-startTime="423">So it's benchmarks that we know that if we </span><span class="line" data-startTime="423">optimize for those, it will actually make </span><span class="line" data-startTime="427">it possible for you guys to write much larger </span><span class="line" data-startTime="427">and much more interesting applications. </span> <span class="line" data-startTime="431">It measures the performance of dynamic message </span><span class="line" data-startTime="431">calls and property access and it also measures </span><span class="line" data-startTime="437">the performance of the memory management system, </span><span class="line" data-startTime="437">and closure creation and location, to a much </span><span class="line" data-startTime="441">higher degree than any of the existing benchmarks </span><span class="line" data-startTime="441">in 2006. </span></p>

<p></p>

<p class="speaker"><span class="line" data-starttime="443"><span class="speakerName">Lars Bak</span>: But Kasper, can I get the mic? </span><span class="line" data-startTime="443">Thank you. Let's try to run it so we can see </span><span class="line" data-startTime="449">how it looks. </span><span class="line" data-startTime="449">So here, let's search for the V8 benchmark </span><span class="line" data-startTime="453">suite and we can run Version 7 of it, and </span><span class="line" data-startTime="453">it will start running and you'll see the results </span><span class="line" data-startTime="459">trickling in on the right-hand side and you </span><span class="line" data-startTime="459">can see the collection of benchmarks we are </span><span class="line" data-startTime="463">running. It's eight different benchmarks. </span><span class="line" data-startTime="463">They're not big, but they are certainly not </span><span class="line" data-startTime="467">micro-benchmarks. </span><span class="line" data-startTime="467">And we should soon have the results. </span><span class="line" data-startTime="473">The interesting part is that the score you </span><span class="line" data-startTime="473">see is computed as the geometric mean between </span><span class="line" data-startTime="481">individual scores but it's calibrated for </span><span class="line" data-startTime="481">Firefox 2 on a high-end desktop machine in </span><span class="line" data-startTime="489">2008. </span><span class="line" data-startTime="489">So we are pretty much running 160 times faster </span><span class="line" data-startTime="497">than one of the browsers in 2008, so this </span><span class="line" data-startTime="497">is pretty amazing. </span></p>

<p class="speaker"><span class="line" data-starttime="500"><span class="speakerName">Kasper Lund</span>: Yeah. The score was 100 on </span><span class="line" data-startTime="500">Firefox 2 on my beefy desktop machine in 2008. </span><span class="line" data-startTime="505">It's a little bit better now. Which is nice. </span><span class="line" data-startTime="505">[ Laughter ] </span></p>

<p class="speaker"><span class="line" data-starttime="511"><span class="speakerName">Kasper Lund</span>: So I think it's fair to conclude </span><span class="line" data-startTime="511">that the performance improvements for JavaScript </span><span class="line" data-startTime="519">over the last eight years have been pretty </span><span class="line" data-startTime="519">impressive. JavaScript itself executes a hundred </span><span class="line" data-startTime="523">times faster than it did before, at least, </span><span class="line" data-startTime="523">and we see people being able to write applications </span><span class="line" data-startTime="528">that use way bigger object heaps, and the </span><span class="line" data-startTime="528">GC pauses are even lower than they were at </span><span class="line" data-startTime="534">that point. </span> <span class="line" data-startTime="534">Another key thing for us as compilers and </span><span class="line" data-startTime="538">VM engineers is that people pay attention </span><span class="line" data-startTime="538">now to performance of their Webapps and it's </span><span class="line" data-startTime="542">very, very common to see benchmark numbers </span><span class="line" data-startTime="542">reported in the press, so it's a &mdash; there's </span><span class="line" data-startTime="547">a nice friendly competition going on to improve </span><span class="line" data-startTime="547">the web platform performance. </span> <span class="line" data-startTime="552">Another thing that's very nice to see is that </span><span class="line" data-startTime="552">it's possible to write really large Webapps </span><span class="line" data-startTime="556">these days. We see common pages like Amazon, </span><span class="line" data-startTime="556">CNN, and ESPN have &mdash; they're serving fairly </span><span class="line" data-startTime="562">large amounts of JavaScript codes to their </span><span class="line" data-startTime="562">customers all day, so it's not uncommon to </span><span class="line" data-startTime="568">see like a megabyte of JavaScript code, minified </span><span class="line" data-startTime="568">JavaScript code, being sent to clients. And </span><span class="line" data-startTime="574">the browsers are generally capable of working </span><span class="line" data-startTime="574">with that. So things have certainly changed </span><span class="line" data-startTime="578">since 2006. </span></p>

<p><span class="line" data-startTime="578">One thing that is important for us is to pay </span><span class="line" data-startTime="584">attention to where the time is actually spent </span><span class="line" data-startTime="584">in your browser, and what you have here is </span><span class="line" data-startTime="589">a couple of diagrams that show that we're </span><span class="line" data-startTime="589">spending around 60% of the time in JavaScript </span><span class="line" data-startTime="597">execution when you're running things like </span><span class="line" data-startTime="597">Gmail, Google Docs, Google Search, and things </span><span class="line" data-startTime="601">like that, and the rest is spent in the general </span><span class="line" data-startTime="601">browser infrastructure. </span> <span class="line" data-startTime="606">On other sites like Twitter and Facebook, </span><span class="line" data-startTime="606">the percentage in JavaScript is a little bit </span><span class="line" data-startTime="609">lower than that. And these measurements are </span><span class="line" data-startTime="609">all done by the Chrome team using Chrome, </span><span class="line" data-startTime="615">so we don't have the exact same numbers for </span><span class="line" data-startTime="615">the other browsers. But it shows that no matter </span><span class="line" data-startTime="620">how fast we make the engines, the application </span><span class="line" data-startTime="620">developers will adapt to that and add new </span><span class="line" data-startTime="625">functionality and essentially make their applications </span><span class="line" data-startTime="625">better by using this thing. </span></p>

<p><span class="line" data-startTime="630">So imagine how it would feel like running </span><span class="line" data-startTime="630">modern Gmail on a browser from 2006. I don't </span><span class="line" data-startTime="636">think you would like that at all. </span> <span class="line" data-startTime="636">So today, web developers are really pushing </span><span class="line" data-startTime="642">the limits of the platform and they really </span><span class="line" data-startTime="642">want and demand predictable high performance. </span> <span class="line" data-startTime="646">Higher and higher, actually. </span> <span class="line" data-startTime="646">They want consistent frame rates for their </span><span class="line" data-startTime="649">games. And they really want to support large-scale </span><span class="line" data-startTime="649">application development. </span> <span class="line" data-startTime="654">So people's expectations for this platform </span><span class="line" data-startTime="654">have really changed. They really demand these </span><span class="line" data-startTime="658">things now, and all it took is 100X performance </span><span class="line" data-startTime="658">improvement. It makes a really, really big </span><span class="line" data-startTime="662">change to the technology stack when you do </span><span class="line" data-startTime="662">these things. </span> <span class="line" data-startTime="666">So the question is, of course, are the web </span><span class="line" data-startTime="666">developers getting predictable and high performance, </span><span class="line" data-startTime="672">and can they actually support really large-scale </span><span class="line" data-startTime="672">application development on the current web </span><span class="line" data-startTime="676">stack? </span><span class="line" data-startTime="676">So before we answer that question, I think </span><span class="line" data-startTime="678">we should dive into the &mdash; the current web </span><span class="line" data-startTime="678">stack and take a look at how we can improve </span><span class="line" data-startTime="682">the parts. </span></p>

<p class="speaker"><span class="line" data-starttime="682"><span class="speakerName">Lars Bak</span>: All right. Now we'll dive into </span><span class="line" data-startTime="689">what actually happens inside the virtual machine </span><span class="line" data-startTime="689">and the browser. </span> <span class="line" data-startTime="692">So I'll be talking about a few different techniques </span><span class="line" data-startTime="692">we've been using to make V8 fast and I'll </span><span class="line" data-startTime="697">talk about the history behind these technologies. </span> <span class="line" data-startTime="697">Firstly, let's look at a browser. So a browser </span><span class="line" data-startTime="705">has several parts. But if we look at the performance-critical </span><span class="line" data-startTime="705">part for a Webapp, it actually consists of </span><span class="line" data-startTime="712">two segments. </span> <span class="line" data-startTime="712">At the lower part, we have the JavaScript </span><span class="line" data-startTime="716">engine where you have all the code and the </span><span class="line" data-startTime="716">objects and the WebObjects that point to the </span><span class="line" data-startTime="722">DOM. The DOM consists of the &mdash; the nodes </span><span class="line" data-startTime="722">that you can see on the screen. And when you </span><span class="line" data-startTime="728">execute your Web application, you manipulate </span><span class="line" data-startTime="728">the DOM by executing JavaScript. </span> <span class="line" data-startTime="735">We all hope that when you develop a Web application, </span><span class="line" data-startTime="735">you have low latency so it comes up fast and </span><span class="line" data-startTime="741">there's no pauses, it has high performance, </span><span class="line" data-startTime="741">and it also has low memory usage so you don't </span><span class="line" data-startTime="747">end up swapping when you run your application. </span></p>

<p><span class="line" data-startTime="747">And then, of course, more pauses if you do </span><span class="line" data-startTime="752">animation. But there are still big fears when </span><span class="line" data-startTime="752">you run a Web application, right? </span><span class="line" data-startTime="757">If the object heap is too big, you can get </span><span class="line" data-startTime="757">very large GC pauses, and you can have memory </span><span class="line" data-startTime="763">leaks. So having a Web application that runs </span><span class="line" data-startTime="763">for weeks and suddenly it runs out of memory </span><span class="line" data-startTime="769">is not very pleasant for the user. </span> <span class="line" data-startTime="769">And sometimes you'll get erratic performance </span><span class="line" data-startTime="773">behavior for no good reasons. </span> <span class="line" data-startTime="773">And this is sort of some of the issues people </span><span class="line" data-startTime="779">are concerned about when writing for the web. </span> <span class="line" data-startTime="779">Here is my picture of how a virtual machine </span><span class="line" data-startTime="788">or a JavaScript engine looked like in the </span><span class="line" data-startTime="788">year 2006. </span></p>

<p><span class="line" data-startTime="791">It had a simple parser that would take the </span><span class="line" data-startTime="791">source code and convert into an abstract syntax </span><span class="line" data-startTime="797">tree or into byte codes and then it would </span><span class="line" data-startTime="797">have a simplistic interpreter that would run </span><span class="line" data-startTime="802">over the AST, abstract syntax tree, or the </span><span class="line" data-startTime="802">byte codes and execute the program. </span> <span class="line" data-startTime="809">And then it would have a simple memory management </span><span class="line" data-startTime="809">system to clean out unused memory. </span> <span class="line" data-startTime="813">Now, in 2006 you would not create many objects </span><span class="line" data-startTime="813">because you knew that if you created a lot </span><span class="line" data-startTime="819">of objects, your program would be slow, so </span><span class="line" data-startTime="819">you actually didn't use many of the object-oriented </span><span class="line" data-startTime="824">qualities of the system. </span> <span class="line" data-startTime="824">So the conclusion is, it was very simple and </span><span class="line" data-startTime="829">that's nice that you can write this kind of </span><span class="line" data-startTime="829">VM in a few thousand lines, but the downside </span><span class="line" data-startTime="833">was it was really slow. </span> <span class="line" data-startTime="833">Today, we have a sports car and I can guarantee </span><span class="line" data-startTime="839">you we have put in all kinds of fancy turbo </span><span class="line" data-startTime="839">engines in it to make it fast, right? We still </span><span class="line" data-startTime="846">have a parser, but instead of an interpreter, </span><span class="line" data-startTime="846">we have a multi-tier adaptive compilation </span><span class="line" data-startTime="852">system. It's basically a &mdash; it's a series </span><span class="line" data-startTime="852">of compilers that learns from the behavior </span><span class="line" data-startTime="858">of the program and tries to optimize the execution </span><span class="line" data-startTime="858">based on behavior. </span></p>

<p><span class="line" data-startTime="864">We have a de-optimization system that allows </span><span class="line" data-startTime="864">the system to back out of optimization if </span><span class="line" data-startTime="870">the behavior of the program changes over time. </span> <span class="line" data-startTime="870">And then we have a system that handles large </span><span class="line" data-startTime="876">object heaps. And in the V8 case, we have </span><span class="line" data-startTime="876">a generation-based garbage collector that </span><span class="line" data-startTime="882">allows us to have heaps up to a gigabyte, </span><span class="line" data-startTime="882">at least, where you can still have reasonable </span><span class="line" data-startTime="887">pauses when running your program. </span> <span class="line" data-startTime="887">Native code is generated on the fly and is </span><span class="line" data-startTime="894">generated by the buckets, I guarantee you, </span><span class="line" data-startTime="894">and what will happen when it's not used anymore, </span><span class="line" data-startTime="900">it will be removed by the garbage collector. </span> <span class="line" data-startTime="900">So even return addresses on the execution </span><span class="line" data-startTime="905">stack will function like pointers into the </span><span class="line" data-startTime="905">code, and if they are not used anymore, the </span><span class="line" data-startTime="911">code will be eliminated. </span> <span class="line" data-startTime="911">And then of course there's all this tool sport </span><span class="line" data-startTime="916">with debugging and profiling. </span></p>

<p><span class="line" data-startTime="916">Because when you do optimizations &mdash; right? </span><span class="line" data-startTime="919">&mdash; you sort of lose the understanding of what </span><span class="line" data-startTime="919">the source code is doing, so you cannot single-step </span><span class="line" data-startTime="925">an optimized code. It will give no meaning </span><span class="line" data-startTime="925">to you. </span> <span class="line" data-startTime="928">So what we try to do is we try to de-optimize </span><span class="line" data-startTime="928">the code. If we try to single-step, it will </span><span class="line" data-startTime="933">look like you do single-stepping in the normal </span><span class="line" data-startTime="933">source code. And that's great for a programmer, </span><span class="line" data-startTime="939">because then you can debug on an odd-based </span><span class="line" data-startTime="939">system or an intra-based system and get exactly </span><span class="line" data-startTime="943">the same behavior. </span> <span class="line" data-startTime="943">It's really complex, but the good thing is, </span><span class="line" data-startTime="950">it's fast. </span> <span class="line" data-startTime="950">Let's go beyond the hood and see what's going </span><span class="line" data-startTime="955">on inside the V8 engine when it comes to a </span><span class="line" data-startTime="955">few things. </span> <span class="line" data-startTime="958">I'll briefly mention how we make the code </span><span class="line" data-startTime="958">really fast, and this is this multi-tier adaptive </span><span class="line" data-startTime="964">compilation system. </span></p>

<p><span class="line" data-startTime="964">I'll talk about how we handle large object </span><span class="line" data-startTime="969">heaps by doing this generation-based garbage </span><span class="line" data-startTime="969">collection with a twist. </span> <span class="line" data-startTime="974">And then I'll talk about how we bind JavaScript </span><span class="line" data-startTime="974">objects to the DOM nodes. </span> <span class="line" data-startTime="982">And this is &mdash; this is tricky, so I'm calling </span><span class="line" data-startTime="982">it the tangoing between the tracing GC and </span><span class="line" data-startTime="988">reference counting. </span> <span class="line" data-startTime="988">So listen up. This might be a little bit tricky </span><span class="line" data-startTime="996">here. </span> <span class="line" data-startTime="996">When you parse the code, the code is blue. </span> <span class="line" data-startTime="1001">You have a sea of JavaScript methods. Nothing </span><span class="line" data-startTime="1001">has been executed yet. When you start executing, </span><span class="line" data-startTime="1007">the first simplistic compiler will take the </span><span class="line" data-startTime="1007">source code and convert into native code, </span><span class="line" data-startTime="1012">right? </span><span class="line" data-startTime="1012">It doesn't know much about the behavior of </span><span class="line" data-startTime="1015">the program, so what it's doing is putting </span><span class="line" data-startTime="1015">in inline cache stops that tracks the behavior </span><span class="line" data-startTime="1021">of the program. So in essence, what it's doing </span><span class="line" data-startTime="1021">at one call site in the program, it tries </span><span class="line" data-startTime="1026">to figure out exactly what kind of type of </span><span class="line" data-startTime="1026">objects comes by. </span></p>

<p><span class="line" data-startTime="1031">At the same time, we have this monitoring </span><span class="line" data-startTime="1031">system in the system that detects when a method </span><span class="line" data-startTime="1036">is used frequently. If it's used frequently, </span><span class="line" data-startTime="1036">we said, "Well, let's try to optimize it even </span><span class="line" data-startTime="1041">further." And the optimizing native compiler, </span><span class="line" data-startTime="1041">what it will do, it will take the collected </span><span class="line" data-startTime="1047">type information from the inline caches and </span><span class="line" data-startTime="1047">use that to do aggressive inlining. </span> <span class="line" data-startTime="1054">So it basically assumes that the behavior </span><span class="line" data-startTime="1054">of the program you had before you optimized </span><span class="line" data-startTime="1058">will be the same in all future. It's not always </span><span class="line" data-startTime="1058">the case, but we're optimistic here. </span> <span class="line" data-startTime="1065">So we do these aggressive inlining decisions, </span><span class="line" data-startTime="1065">but we put in the optimization hook so that </span><span class="line" data-startTime="1070">if our assumptions are wrong in the optimized </span><span class="line" data-startTime="1070">code, we can go back again to the naive, simple </span><span class="line" data-startTime="1076">code. </span> <span class="line" data-startTime="1076">In most cases, we don't have to do that and </span><span class="line" data-startTime="1079">you'll get the predictable performance, which </span><span class="line" data-startTime="1079">is great. </span> <span class="line" data-startTime="1085">It gets even harder &mdash; right? &mdash; because as </span><span class="line" data-startTime="1085">you all know, there's no types in JavaScript, </span><span class="line" data-startTime="1092">and that means we have to do funky stuff. </span></p>

<p><span class="line" data-startTime="1092">One funky thing we are doing is that if you </span><span class="line" data-startTime="1097">use an array and you put doubles in it, at </span><span class="line" data-startTime="1097">some point at runtime we decide to optimize </span><span class="line" data-startTime="1104">it by converting the representation of an </span><span class="line" data-startTime="1104">object from an array that can have any kind </span><span class="line" data-startTime="1110">of objects to a representation that can only </span><span class="line" data-startTime="1110">have double values. Right? </span><span class="line" data-startTime="1116">So we assume that moving forward, we will </span><span class="line" data-startTime="1116">only operate on double values in this array. </span> <span class="line" data-startTime="1120">That will certainly speed up programs that </span><span class="line" data-startTime="1120">continue to have that behavior, but you still </span><span class="line" data-startTime="1124">need the hooks if something from the side </span><span class="line" data-startTime="1124">would put in an integer. Or not an integer. </span> <span class="line" data-startTime="1129">Let's say a &mdash; a string in that array. </span> <span class="line" data-startTime="1129">Then we have to back out of that optimization </span><span class="line" data-startTime="1135">and go back to the standard representation </span><span class="line" data-startTime="1135">of an object array. Very complicated. </span> <span class="line" data-startTime="1140">But anyways, you have a system that's always </span><span class="line" data-startTime="1140">changing when you run it. </span> <span class="line" data-startTime="1149">Did we invent this multi-tier adaptive compilation? </span><span class="line" data-startTime="1149">No, we are not that smart. There is actually </span><span class="line" data-startTime="1154">a long history of implementing dynamic languages, </span><span class="line" data-startTime="1154">started with interpretation in the '50s with </span><span class="line" data-startTime="1164">Lisp. In the '70s, we have dynamic compilation </span><span class="line" data-startTime="1164">being added to Smalltalk. And they even had </span><span class="line" data-startTime="1169">inline caching. It was not at the call side, </span><span class="line" data-startTime="1169">but they put it at the callee. So instead </span><span class="line" data-startTime="1174">of having it &mdash; the method calling it, it </span><span class="line" data-startTime="1174">was actually at the prologue of the method </span><span class="line" data-startTime="1178">you called. </span></p>

<p><span class="line" data-startTime="1178">And then the adaptive compilation was invented </span><span class="line" data-startTime="1183">in the '90s in the sales project where you </span><span class="line" data-startTime="1183">have mixed mode execution, runtime-type feedback </span><span class="line" data-startTime="1188">and all this kind of stuff. </span> <span class="line" data-startTime="1188">And then they also came up with deoptimization. </span> <span class="line" data-startTime="1193">So let me try to explain what deoptimization </span><span class="line" data-startTime="1193">is. It is actually very simple. </span> <span class="line" data-startTime="1198">When you have the optimized code and you have </span><span class="line" data-startTime="1198">activations on the stack that's executing </span><span class="line" data-startTime="1203">and you figure out that something is wrong, </span><span class="line" data-startTime="1203">you need to revert. What you do is you take </span><span class="line" data-startTime="1208">that optimized activation and convert it into </span><span class="line" data-startTime="1208">a series of unoptimized activity on the stack, </span><span class="line" data-startTime="1217">flush the optimized code, and start using </span><span class="line" data-startTime="1217">the simple code again. </span> <span class="line" data-startTime="1224">This first appeared commercially in the HotSpot </span><span class="line" data-startTime="1224">JVM. I assume you all know about what that </span><span class="line" data-startTime="1229">is. </span></p>

<p><span class="line" data-startTime="1229">The other thing we did in V8 to basically </span><span class="line" data-startTime="1234">use all this technology was introducing behind-the-scenes </span><span class="line" data-startTime="1234">classes. You know that JavaScript is prototype-based, </span><span class="line" data-startTime="1241">but we faked them behind the scenes in event </span><span class="line" data-startTime="1241">classes. Then you can apply all this technology </span><span class="line" data-startTime="1246">on the slide, and that made it fast. </span> <span class="line" data-startTime="1246">The garbage collector in V8 is here. It might </span><span class="line" data-startTime="1257">look complicated. We basically have two generations. </span> <span class="line" data-startTime="1257">And the way it works is, as you are allocating </span><span class="line" data-startTime="1263">optics in your program, we will fill up the </span><span class="line" data-startTime="1263">allocation space. It is called "from" here. </span> <span class="line" data-startTime="1270">When it is full, we will start a garbage collection </span><span class="line" data-startTime="1270">process. And we have a tracing garbage collector. </span> <span class="line" data-startTime="1276">That means that we have well-defined routes, </span><span class="line" data-startTime="1276">and we start following these routes through </span><span class="line" data-startTime="1280">the optics, through its references until we </span><span class="line" data-startTime="1280">have computed the complete live optigraph. </span> <span class="line" data-startTime="1288">And memory that's not occupied by the live </span><span class="line" data-startTime="1288">optigraph is garbage, and it can be reclaimed </span><span class="line" data-startTime="1293">and used for further objects. </span> <span class="line" data-startTime="1293">Let's see what happens when you do a use-space </span><span class="line" data-startTime="1298">collection in V8. We migrate the optics to </span><span class="line" data-startTime="1298">the "to" space. And you can see it is smaller, </span><span class="line" data-startTime="1307">and that is because most optics die young. </span></p>

<p><span class="line" data-startTime="1307">And this is great. </span> <span class="line" data-startTime="1311">Then we can start allocating and filling up </span><span class="line" data-startTime="1311">the "to" space and repeat the same story. </span> <span class="line" data-startTime="1319">The garbage collector in V8 is a precise garbage </span><span class="line" data-startTime="1319">collector. It stops the world and processes </span><span class="line" data-startTime="1326">the garbage and then continues on. </span> <span class="line" data-startTime="1326">You can see you have red pointers in the graph. </span> <span class="line" data-startTime="1333">It denotes that the system has a stop buffer </span><span class="line" data-startTime="1333">that tracks pointers from old generation to </span><span class="line" data-startTime="1338">the new generation. And you need that if you </span><span class="line" data-startTime="1338">want to do fast use-space garbage collection. </span> <span class="line" data-startTime="1344">You don't have to scan the whole heap in order </span><span class="line" data-startTime="1344">to do a small garbage collection. </span> <span class="line" data-startTime="1349">The old space in V8 has been segmented into </span><span class="line" data-startTime="1349">normal optics. That's the optics that's promoted </span><span class="line" data-startTime="1358">from use-space when they have survived for </span><span class="line" data-startTime="1358">a while, and then native code where you have </span><span class="line" data-startTime="1364">native instructions, and then a segment where </span><span class="line" data-startTime="1364">you have atomic data. Atomic data is data </span><span class="line" data-startTime="1370">that does not have pointers out again. So </span><span class="line" data-startTime="1370">it could be typed arrays or double optics, </span><span class="line" data-startTime="1376">something like that. That is easier to handle </span><span class="line" data-startTime="1376">in a separate space because they don't have </span><span class="line" data-startTime="1380">pointers out. </span> <span class="line" data-startTime="1380">Anyways, we didn't invent that either. Sorry. </span> <span class="line" data-startTime="1386">There's a long history of automatic memory </span><span class="line" data-startTime="1386">management done in Lisp in the '50s. Incremental </span><span class="line" data-startTime="1394">garbage collection done in the '70s in Lisp </span><span class="line" data-startTime="1394">as well. And then you have generational-based </span><span class="line" data-startTime="1399">garbage collection that got invented by the </span><span class="line" data-startTime="1399">one guy in the '80s and generationally scavenged </span><span class="line" data-startTime="1406">any use of Smalltalk. </span></p>

<p><span class="line" data-startTime="1406">So all these techniques for doing garbage </span><span class="line" data-startTime="1411">collection is fairly simple in my mind because </span><span class="line" data-startTime="1411">you have all the pointers to the optics and </span><span class="line" data-startTime="1415">you can just process them. </span> <span class="line" data-startTime="1415">The hard part is actually dancing with the </span><span class="line" data-startTime="1420">DOM. And I will try to tell you how that works. </span> <span class="line" data-startTime="1420">So nodes in DOM is going by what we call reference </span><span class="line" data-startTime="1429">counting. Reference counting is a simplistic </span><span class="line" data-startTime="1429">garbage collection technology that keeps a </span><span class="line" data-startTime="1435">pointer in each optic that tells how many </span><span class="line" data-startTime="1435">pointers point to it. When that pointer goes </span><span class="line" data-startTime="1442">to zero, you can de-allocate the optic. </span> <span class="line" data-startTime="1442">The problem is you don't know who points to </span><span class="line" data-startTime="1448">it. You just know how many. That means that </span><span class="line" data-startTime="1448">if you want to move the optic memory, you </span><span class="line" data-startTime="1454">cannot do that because you cannot find how </span><span class="line" data-startTime="1454">to point to it. </span></p>

<p><span class="line" data-startTime="1457">And another deficiency of that mechanism is </span><span class="line" data-startTime="1457">also if you have a cycle, which can happen, </span><span class="line" data-startTime="1464">then it's a memory leak because you will never </span><span class="line" data-startTime="1464">get down to zero in the reference count. </span> <span class="line" data-startTime="1472">And the problem is JavaScript V8 has optics </span><span class="line" data-startTime="1472">that are traced and we have to get all this </span><span class="line" data-startTime="1477">to work. </span> <span class="line" data-startTime="1477">So, here we go. Bear with me. This is complicated. </span> <span class="line" data-startTime="1484">On the top you see the DOM. You have two nodes. </span> <span class="line" data-startTime="1484">The first node has a reference count of 1. </span> <span class="line" data-startTime="1490">The second one has a count of 2. And you have </span><span class="line" data-startTime="1490">wrapper optics that point to these DOM nodes </span><span class="line" data-startTime="1497">from beneath, and that is the V8 heap. </span> <span class="line" data-startTime="1497">Now, in order to make sure you can collect </span><span class="line" data-startTime="1506">these optics, you have to make tricks. And </span><span class="line" data-startTime="1506">you can see you have this pairing between </span><span class="line" data-startTime="1510">JavaScript optics and DOM nodes by using repointers. </span> <span class="line" data-startTime="1510">So, in essence, you have a JavaScript wrapper </span><span class="line" data-startTime="1517">that points to a DOM node that in turn points </span><span class="line" data-startTime="1517">to a persistent handle &mdash; that's the black </span><span class="line" data-startTime="1522">ones &mdash; that, in turn, will use a repointer </span><span class="line" data-startTime="1522">pointing back. So it is sort of a semicycle, </span><span class="line" data-startTime="1528">and you break the cycle by using repointers. </span></p>

<p><span class="line" data-startTime="1528">So that is simple. </span> <span class="line" data-startTime="1535">But it gets even more complicated. When V8 </span><span class="line" data-startTime="1535">is running out of memory and has to perform </span><span class="line" data-startTime="1541">a garbage collection, it has to call the DOM </span><span class="line" data-startTime="1541">and ask the DOM to group all objects that </span><span class="line" data-startTime="1547">belong together because that's needed in order </span><span class="line" data-startTime="1547">to only collect &mdash; you basically have to collect </span><span class="line" data-startTime="1553">all grouped optics at the same time. That's </span><span class="line" data-startTime="1553">needed to avoid resurrection of wrapper optics. </span> <span class="line" data-startTime="1562">That might seem complicated, but it is needed </span><span class="line" data-startTime="1562">because if you add a property to one of the </span><span class="line" data-startTime="1567">JavaScript nodes at the bottom and it suddenly </span><span class="line" data-startTime="1567">disappears and reappears again, the property </span><span class="line" data-startTime="1573">is gone and the application will get a little </span><span class="line" data-startTime="1573">bit confused. So we need to do all this in </span><span class="line" data-startTime="1579">order to make sure garbage collection works. </span> <span class="line" data-startTime="1579">Did we invent this? Actually, that's the only </span><span class="line" data-startTime="1587">thing we did. It works. Chrome is great. But </span><span class="line" data-startTime="1587">that part we are not proud of. It needs a </span><span class="line" data-startTime="1598">lot more work in order to make sure that we </span><span class="line" data-startTime="1598">can guarantee that all memory is collected </span><span class="line" data-startTime="1604">the right way. But we will get back to this </span><span class="line" data-startTime="1604">later in this talk, what we are doing about </span><span class="line" data-startTime="1608">it. </span></p>

<p><span class="line" data-startTime="1608">Does this mean that V8 is as good as it gets? </span><span class="line" data-startTime="1617">Right? We have taken all these techniques </span><span class="line" data-startTime="1617">from the past, advanced codebase techniques </span><span class="line" data-startTime="1622">with hidden classes and sophisticated memory </span><span class="line" data-startTime="1622">management. </span> <span class="line" data-startTime="1627">Is this what we have, or do we want more performance? </span><span class="line" data-startTime="1627">Well, from the feedback we're getting, there's </span><span class="line" data-startTime="1634">still a lot of bottlenecks in the browser. </span> <span class="line" data-startTime="1634">Performance is not still at par with real </span><span class="line" data-startTime="1643">languages. You can define what "real" is your </span><span class="line" data-startTime="1643">own way. But I would sort of at least say </span><span class="line" data-startTime="1647">Java and C# as contenders. </span> <span class="line" data-startTime="1647">Performance is still unpredictable. And you </span><span class="line" data-startTime="1657">can see if you do animation in the browser, </span><span class="line" data-startTime="1657">sometimes you skip frames. And part of it </span><span class="line" data-startTime="1661">is because you do too much compilation. Part </span><span class="line" data-startTime="1661">of it is because you do garbage collections. </span> <span class="line" data-startTime="1667">Part of it is because you are deoptimized </span><span class="line" data-startTime="1667">because suddenly the assumption changed in </span><span class="line" data-startTime="1671">the program. </span> <span class="line" data-startTime="1671">And in JavaScript, that's very easy to do </span><span class="line" data-startTime="1675">because just jamming a lot of property on </span><span class="line" data-startTime="1675">a hot object, bam, performance changes. </span> <span class="line" data-startTime="1681">Startup is still slow. And the reason for </span><span class="line" data-startTime="1681">that is that you still have to read in the </span><span class="line" data-startTime="1687">source code whenever you have to start up </span><span class="line" data-startTime="1687">the program. </span> <span class="line" data-startTime="1690">And, of course, JavaScript is still JavaScript. </span> <span class="line" data-startTime="1690">There's a lot of implicit conversions of values </span><span class="line" data-startTime="1698">when you run JavaScript. It is just complicated. </span></p>

<p><span class="line" data-startTime="1698">So having said that, the V8 project is still </span><span class="line" data-startTime="1707">doing excellent. They are still improving </span><span class="line" data-startTime="1707">performance quarter after quarter. But we </span><span class="line" data-startTime="1714">think that if we really want to push the performance </span><span class="line" data-startTime="1714">to the next level, something else is needed. </span> <span class="line" data-startTime="1722">Let's look at performance over time when it </span><span class="line" data-startTime="1722">comes to V8. This is a graph that shows the </span><span class="line" data-startTime="1727">V8 benchmark score from the different versions </span><span class="line" data-startTime="1727">of Chrome, all the way up to today. </span> <span class="line" data-startTime="1734">And it's gone from 3,800 all the way up to </span><span class="line" data-startTime="1734">14,000. So it certainly has improved a lot. </span> <span class="line" data-startTime="1744">So this is great. But there's a downside. </span> <span class="line" data-startTime="1744">Here's the complexity over time of V8. And </span><span class="line" data-startTime="1754">we measure complexity by number of lines of </span><span class="line" data-startTime="1754">code in the VM. </span> <span class="line" data-startTime="1759">When we came out of V8, it was roughly 100,000 </span><span class="line" data-startTime="1759">lines of code. Now it's half a million lines </span><span class="line" data-startTime="1765">of code. And I don't know &mdash; as a programmer, </span><span class="line" data-startTime="1765">you know that there's trouble when it gets </span><span class="line" data-startTime="1771">so big. It takes way more effort in order </span><span class="line" data-startTime="1771">to improve performance. So we question whether </span><span class="line" data-startTime="1779">that's possible to get a factor of 2 in V8 </span><span class="line" data-startTime="1779">in the near time. You can follow the graph. </span> <span class="line" data-startTime="1785">Factor of 2 will take a long time, unless </span><span class="line" data-startTime="1785">it is rewritten, of course. This also would </span><span class="line" data-startTime="1791">be a fun project. </span></p>

<p></p>

<p class="speaker"><span class="line" data-starttime="1791"><span class="speakerName">Kasper Lund</span>: So we've gone through a lot </span><span class="line" data-startTime="1796">of Web technology stuff here and looked into </span><span class="line" data-startTime="1796">how V8 works and why it is as fast as it is. </span> <span class="line" data-startTime="1803">Let's dive into the Dart side and look at </span><span class="line" data-startTime="1803">how Dart improves this. So Dart is a simple </span><span class="line" data-startTime="1812">class-based unsurprising programming language. </span> <span class="line" data-startTime="1812">It is designed to be very familiar so that </span><span class="line" data-startTime="1818">Web developers and application developers </span><span class="line" data-startTime="1818">can pick it up and learn to use it in no time. </span> <span class="line" data-startTime="1823">We've got excellent feedback from users of </span><span class="line" data-startTime="1823">the system that this really works. You can </span><span class="line" data-startTime="1827">sit down and code in Dart. And within a few </span><span class="line" data-startTime="1827">hours, you feel like you are very productive </span><span class="line" data-startTime="1832">and it actually works out really well. </span> <span class="line" data-startTime="1832">To hit that target of being very familiar, </span><span class="line" data-startTime="1839">we've designed it based on principles and </span><span class="line" data-startTime="1839">concepts found in other languages. So the </span><span class="line" data-startTime="1844">syntax is very much inspired by JavaScript, </span><span class="line" data-startTime="1844">Java, C#, those kind of languages. And we </span><span class="line" data-startTime="1849">get a lot of other value from essentially </span><span class="line" data-startTime="1849">standing on the shoulders of other good programming </span><span class="line" data-startTime="1854">languages out there and picking the things </span><span class="line" data-startTime="1854">that we feel are good fits for a language </span><span class="line" data-startTime="1858">that needs to be really efficient and at the </span><span class="line" data-startTime="1858">same time very productive. </span></p>

<p><span class="line" data-startTime="1862">One thing that we've added to Dart, which </span><span class="line" data-startTime="1862">is a little bit uncommon is support for optional </span><span class="line" data-startTime="1867">static types. That means that you can write </span><span class="line" data-startTime="1867">static-type notations where you want them, </span><span class="line" data-startTime="1871">where you feel like they convey the intent </span><span class="line" data-startTime="1871">that you want to convey. But you don't have </span><span class="line" data-startTime="1875">to put them in. The system is very flexible </span><span class="line" data-startTime="1875">that way. It doesn't require you, and it is </span><span class="line" data-startTime="1879">a fully dynamically typed system. It is hard </span><span class="line" data-startTime="1879">to describe this in one slide without showing </span><span class="line" data-startTime="1884">some code. So I will use two. </span> <span class="line" data-startTime="1884">Here is a little bit of a taste of Dart. I </span><span class="line" data-startTime="1890">don't know how many of you are familiar with </span><span class="line" data-startTime="1890">Dart, tried it out. But for those of you who </span><span class="line" data-startTime="1893">are seeing it for the first time, I hope you </span><span class="line" data-startTime="1893">will find that this is reasonably readable. </span> <span class="line" data-startTime="1897">It is a very simple example. It shows that </span><span class="line" data-startTime="1897">all Dart applications start with a main function. </span></p>

<p><span class="line" data-startTime="1903">And in this case, I just added a little bit </span><span class="line" data-startTime="1903">of an HTML interaction here. I am creating </span><span class="line" data-startTime="1908">a new button element, adding that to the document </span><span class="line" data-startTime="1908">body, and giving it a bit of text. </span> <span class="line" data-startTime="1914">Hopefully, you can read this code if you are </span><span class="line" data-startTime="1914">familiar with JavaScript, C#, Java, those </span><span class="line" data-startTime="1919">kind of languages and it doesn't feel too </span><span class="line" data-startTime="1919">foreign for you. That's exactly what we wanted </span><span class="line" data-startTime="1922">to try to get at. </span> <span class="line" data-startTime="1922">One thing that might look a little bit different </span><span class="line" data-startTime="1925">here is the import, and it just shows that </span><span class="line" data-startTime="1925">Dart has support for modularity. So you can </span><span class="line" data-startTime="1932">import libraries of functionality and code </span><span class="line" data-startTime="1932">and use that. So we do have a namespacing </span><span class="line" data-startTime="1937">mechanism and a way of carving up your application </span><span class="line" data-startTime="1937">in multiple independent bits. So I hope this </span><span class="line" data-startTime="1943">seems reasonably easy to read for you guys. </span> <span class="line" data-startTime="1943">I think a good question to ask at this point </span><span class="line" data-startTime="1950">is: What are we trying to achieve with Dart? </span><span class="line" data-startTime="1950">And we feel that there is a need for a much </span><span class="line" data-startTime="1955">more scalable development platform for Web </span><span class="line" data-startTime="1955">apps. We feel like it is too costly and too </span><span class="line" data-startTime="1960">difficult to write great Web apps. You can </span><span class="line" data-startTime="1960">achieve amazing things on the Web today, but </span><span class="line" data-startTime="1964">you really have to invest a lot of time in </span><span class="line" data-startTime="1964">it. Things are getting better, but we feel </span><span class="line" data-startTime="1967">like we need something like Dart to push the </span><span class="line" data-startTime="1967">limits of this and make it much, much easier </span><span class="line" data-startTime="1971">to write large, well-functioning applications. </span></p>

<p><span class="line" data-startTime="1971">We think there is a real need for higher performance </span><span class="line" data-startTime="1977">and much faster startup. And we certainly </span><span class="line" data-startTime="1977">feel like having predictable performance where </span><span class="line" data-startTime="1982">it's harder to write applications that really </span><span class="line" data-startTime="1982">perform poorly because of somewhat weird semantics </span><span class="line" data-startTime="1988">in the core of the system that you're building </span><span class="line" data-startTime="1988">on is a must. </span> <span class="line" data-startTime="1994">Another thing that we consistently hear from </span><span class="line" data-startTime="1994">users of Dart and other systems is that having </span><span class="line" data-startTime="1999">great toolability, being able to write tools </span><span class="line" data-startTime="1999">and use tools on your codebases for refactoring, </span><span class="line" data-startTime="2003">editing, and just maneuvering around, navigating </span><span class="line" data-startTime="2003">your code is a great big help. And the static </span><span class="line" data-startTime="2010">types that we have, even though they are optional, </span><span class="line" data-startTime="2010">they are a big help here, to just document </span><span class="line" data-startTime="2014">your intent of your code and make use of it. </span></p>

<p><span class="line" data-startTime="2014">And, finally, I think it is very important </span><span class="line" data-startTime="2019">for us that we make it easy and nice to use </span><span class="line" data-startTime="2019">a set of consistent libraries and make it </span><span class="line" data-startTime="2026">easy for the community to create new libraries </span><span class="line" data-startTime="2026">and share them in the same way. Certainly </span><span class="line" data-startTime="2031">an area where the Web suffered a little bit. </span> <span class="line" data-startTime="2031">We see great things out there written for </span><span class="line" data-startTime="2036">JavaScript, but it is not necessarily trivial </span><span class="line" data-startTime="2036">to make things fit together if you have multiple </span><span class="line" data-startTime="2039">independent pieces of JavaScript functionality </span><span class="line" data-startTime="2039">you want to bring together. We are trying </span><span class="line" data-startTime="2043">to make that better with Dart, so that's what </span><span class="line" data-startTime="2043">we are trying to achieve. </span> <span class="line" data-startTime="2046">Clearly, we want Dart to be useful in all </span><span class="line" data-startTime="2046">browsers, all modern browsers. So we've written </span><span class="line" data-startTime="2052">a translator that translates Dart code to </span><span class="line" data-startTime="2052">JavaScript that runs in all modern browsers. </span> <span class="line" data-startTime="2058">That translator itself is actually written </span><span class="line" data-startTime="2058">in Dart, so we are trying to dogfood our own </span><span class="line" data-startTime="2061">product here. And that has been great experience </span><span class="line" data-startTime="2061">for us, to write a fairly significant amount </span><span class="line" data-startTime="2066">of code in Dart, translate &mdash; in a translator </span><span class="line" data-startTime="2066">that translates Dart to JavaScript can actually </span><span class="line" data-startTime="2071">translate itself so you can take that big </span><span class="line" data-startTime="2071">piece of code and translate it to JavaScript </span><span class="line" data-startTime="2076">and then you have a Dart-to-JavaScript translator </span><span class="line" data-startTime="2076">in JavaScript. That's kind of neat. It runs </span><span class="line" data-startTime="2082">across all modern browsers. That's a big one </span><span class="line" data-startTime="2082">here. </span></p>

<p><span class="line" data-startTime="2087">So the users that actually try using Dart </span><span class="line" data-startTime="2087">are fairly happy with some of the decisions </span><span class="line" data-startTime="2093">we've made. And Thomas from an Austrian startup, </span><span class="line" data-startTime="2093">Blossom, describes this fairly accurately </span><span class="line" data-startTime="2100">in one of his quotes here. He says that Dart </span><span class="line" data-startTime="2100">is exactly what he needs to be productive </span><span class="line" data-startTime="2105">on the Web. So the feedback that we're getting </span><span class="line" data-startTime="2105">on the productivity gains of using something </span><span class="line" data-startTime="2111">like Dart for your Web applications is very, </span><span class="line" data-startTime="2111">very positive. </span> <span class="line" data-startTime="2113">I will let this slide stay up for two more </span><span class="line" data-startTime="2113">seconds so you can read it. </span></p>

<p class="speaker"><span class="line" data-starttime="2119"><span class="speakerName">Lars Bak</span>: All right. Well, for me it is </span><span class="line" data-startTime="2119">good just to have a choice of another system, </span><span class="line" data-startTime="2132">if it fits your needs better. </span> <span class="line" data-startTime="2132">But let's go a little bit deeper when it comes </span><span class="line" data-startTime="2137">to performance. I'd like to talk about why </span><span class="line" data-startTime="2137">we can make Dart faster than JavaScript. In </span><span class="line" data-startTime="2144">some cases, it already is. </span> <span class="line" data-startTime="2144">Right. We are VM engineers. We have done that </span><span class="line" data-startTime="2150">for most of our professional lives. And we </span><span class="line" data-startTime="2150">designed Dart to make sure we could optimize </span><span class="line" data-startTime="2157">it. Maybe it is a little bit selfish, but </span><span class="line" data-startTime="2157">it is basically so we can get better performance. </span> <span class="line" data-startTime="2163">So the language model, the language semantics, </span><span class="line" data-startTime="2163">is very simple in Dart. It has a much simpler </span><span class="line" data-startTime="2169">optic model. </span> <span class="line" data-startTime="2169">It means that when you first have allocated </span><span class="line" data-startTime="2173">an optic with fields, you cannot change it </span><span class="line" data-startTime="2173">after the allocation point. That's it. And </span><span class="line" data-startTime="2178">it allows us to have much faster access to </span><span class="line" data-startTime="2178">fields, right? Just like in C# or in Java, </span><span class="line" data-startTime="2182">you can actually access the nth element because </span><span class="line" data-startTime="2182">you know that that is exactly where the foo </span><span class="line" data-startTime="2188">property is. </span> <span class="line" data-startTime="2188">Programmers are declared so you don't have </span><span class="line" data-startTime="2192">to run Dart in order to set up the program </span><span class="line" data-startTime="2192">in contrast to JavaScript. That allows us </span><span class="line" data-startTime="2199">to use snapshots for having fast startup of </span><span class="line" data-startTime="2199">applications. We like that feature. </span></p>

<p><span class="line" data-startTime="2206">And then we just have fewer special corner </span><span class="line" data-startTime="2206">cases to worry about. As an example of a corner </span><span class="line" data-startTime="2212">case in JavaScript is that, well, you might </span><span class="line" data-startTime="2212">actually like it as a programmer that you </span><span class="line" data-startTime="2216">can call a method with too many parameters </span><span class="line" data-startTime="2216">or too few. Well, this is sort of nice but </span><span class="line" data-startTime="2222">in the implementation, somebody has to figure </span><span class="line" data-startTime="2222">out what you called it with and that costs, </span><span class="line" data-startTime="2227">right? And if you don't provide enough argument, </span><span class="line" data-startTime="2227">somebody has to provide them for you, the </span><span class="line" data-startTime="2231">underlying system. And stuff like that makes </span><span class="line" data-startTime="2231">the code more complicated to generate and </span><span class="line" data-startTime="2237">the resultant code is also more loaded. </span> <span class="line" data-startTime="2237">Let's give an example. Here I tried to make </span><span class="line" data-startTime="2244">a side-by-side comparison between Dart and </span><span class="line" data-startTime="2244">JavaScript and what code it generates and </span><span class="line" data-startTime="2249">how it works. On the right side, you can see </span><span class="line" data-startTime="2249">that we have two classes. We have a class </span><span class="line" data-startTime="2256">A. It has a method called foo. It prints out </span><span class="line" data-startTime="2256">foo. And then we have a subclass B that inherits </span><span class="line" data-startTime="2263">from &mdash; or extends A. It has nothing. And </span><span class="line" data-startTime="2263">you create a new B &mdash; it is called b, lowercase </span><span class="line" data-startTime="2271">b. And the main function on the right, you </span><span class="line" data-startTime="2271">call foo. Very, very simple. We try to mimic </span><span class="line" data-startTime="2277">the same in JavaScript. You have to go to </span><span class="line" data-startTime="2277">the left of the screen. The way we model inheritance </span><span class="line" data-startTime="2282">in JavaScript is by using prototypes, so we </span><span class="line" data-startTime="2282">make a function A. And in the prototype of </span><span class="line" data-startTime="2289">A, we put in the foo function, just like on </span><span class="line" data-startTime="2289">the right. </span></p>

<p><span class="line" data-startTime="2293">And then we make a function B that calls constructor </span><span class="line" data-startTime="2293">A. And in the B prototype, we don't do anything. </span> <span class="line" data-startTime="2302">We just set it to a new A and then we create </span><span class="line" data-startTime="2302">a new B and we call B. So it is sort of the </span><span class="line" data-startTime="2308">same. No difference. </span> <span class="line" data-startTime="2308">The problem in JavaScript when it comes to </span><span class="line" data-startTime="2314">speed is you can actually on the fly change </span><span class="line" data-startTime="2314">the code. So in the inserter box you can see </span><span class="line" data-startTime="2322">that right there we actually are extending </span><span class="line" data-startTime="2322">the B pro type with a new foo that prints </span><span class="line" data-startTime="2328">in foo. You can call B foo again. And the </span><span class="line" data-startTime="2328">semantics is you have to print out new foo </span><span class="line" data-startTime="2334">now. We don't have that in Dart. We think </span><span class="line" data-startTime="2334">this is a plus. It is certainly a plus for </span><span class="line" data-startTime="2341">the implementation. So let's look at it. B </span><span class="line" data-startTime="2341">is the object created. That's the object we </span><span class="line" data-startTime="2348">wanted to execute foo on. It points to the </span><span class="line" data-startTime="2348">B prototype in JavaScript that, again, points </span><span class="line" data-startTime="2355">to the A prototype. When you start running </span><span class="line" data-startTime="2355">the program, you don't have the middle foo </span><span class="line" data-startTime="2361">so you have to execute the one up in A the </span><span class="line" data-startTime="2361">problem is, you don't know if somebody is </span><span class="line" data-startTime="2368">going to insert a foo going forward. The system </span><span class="line" data-startTime="2368">has to cope with it. So in V8 you have a choice. </span> <span class="line" data-startTime="2375">Either you have to always validate. There </span><span class="line" data-startTime="2375">is no foo in the B prototype before you can </span><span class="line" data-startTime="2381">execute the one up in A. Then it will invalidate </span><span class="line" data-startTime="2381">the code, how it generated, with these assumptions. </span></p>

<p><span class="line" data-startTime="2394">The problem is, the B prototype is an ordinary </span><span class="line" data-startTime="2394">object. You do not want to put in a general </span><span class="line" data-startTime="2400">dependency system for normal objects. So in </span><span class="line" data-startTime="2400">Dart &mdash; no, sorry, in JavaScript V8, we actually </span><span class="line" data-startTime="2409">validate that there's no foo in the middle </span><span class="line" data-startTime="2409">here before we execute foo in the A prototype. </span> <span class="line" data-startTime="2417">That is expensive on the implementation side. </span> <span class="line" data-startTime="2417">Let me try to show you what it cost in generator </span><span class="line" data-startTime="2427">code. So given the example we had on the previous </span><span class="line" data-startTime="2427">slide, we now have a small benchmark. It's </span><span class="line" data-startTime="2433">the micro benchmark. We don't like them, yes, </span><span class="line" data-startTime="2433">but I'm trying to make a point here. It's </span><span class="line" data-startTime="2440">a loop that just called B.foo repeatedly. </span></p>

<p><span class="line" data-startTime="2440">And I warm up that program and I look at what </span><span class="line" data-startTime="2449">the various system generates. On the left </span><span class="line" data-startTime="2449">side, you can see the result of what V8 generates. </span> <span class="line" data-startTime="2454">It generates nearly 300 bytes of common code </span><span class="line" data-startTime="2454">and 239 bytes of stop code. The stop code </span><span class="line" data-startTime="2463">is the source. You need in order to optimization, </span><span class="line" data-startTime="2463">if something goes wrong, for instance, you </span><span class="line" data-startTime="2470">add the extra code in the middle. On the Dart </span><span class="line" data-startTime="2470">side, it's somewhat simpler. You can see the </span><span class="line" data-startTime="2477">optimized code here. It's much smaller. In </span><span class="line" data-startTime="2477">fact, it's only a third of the V8 code being </span><span class="line" data-startTime="2485">generated. So the simple semantics in the </span><span class="line" data-startTime="2485">programming language just makes sense, right? </span><span class="line" data-startTime="2491">It's much easier to make fast. Optimizing </span><span class="line" data-startTime="2491">a little bit of code is much easier than optimizing </span><span class="line" data-startTime="2499">a big piece of code. Generally, less code </span><span class="line" data-startTime="2499">is great. Better memory performance. You also </span><span class="line" data-startTime="2505">get predictable performance because you cannot </span><span class="line" data-startTime="2505">change the code after you start it up. So </span><span class="line" data-startTime="2512">keep it simple. It's good for us, V8. </span></p>

<p></p>

<p class="speaker"><span class="line" data-starttime="2512"><span class="speakerName">Kasper Lund</span>: Hopefully it's very good for </span><span class="line" data-startTime="2518">application developers that get more predictable </span><span class="line" data-startTime="2518">performance and just generally better performance. </span> <span class="line" data-startTime="2524">So let's benchmark this thing with a non-micro </span><span class="line" data-startTime="2524">brashing benchmark suite. To benchmark the </span><span class="line" data-startTime="2532">Dart VM. We have used multiple. A couple that </span><span class="line" data-startTime="2532">are interesting are Richards and DeltaBlue. </span> <span class="line" data-startTime="2545">That means that if we make Richards and DeltaBlue </span><span class="line" data-startTime="2545">faster, it will have an impact on a real web </span><span class="line" data-startTime="2551">application. So using benchmark that you &mdash; that </span><span class="line" data-startTime="2551">have proven valuable in the context of other </span><span class="line" data-startTime="2558">languages makes a lot of sense, especially </span><span class="line" data-startTime="2558">if you want to try to bring a new programming </span><span class="line" data-startTime="2564">language implementation to the web and make </span><span class="line" data-startTime="2564">sure it has nice performance properties that </span><span class="line" data-startTime="2568">match existing real languages. So we've used </span><span class="line" data-startTime="2568">in the past for self, Strongtalk, V8, and </span><span class="line" data-startTime="2575">now we're using these two benchmarks for tuning </span><span class="line" data-startTime="2575">Dart. It's important to stress that these </span><span class="line" data-startTime="2582">benchmarks really measure the performance </span><span class="line" data-startTime="2582">of calling methods, memory allocation, and </span><span class="line" data-startTime="2587">all the things applications tend to spend </span><span class="line" data-startTime="2587">a lot of time in. So Richards is an interesting </span><span class="line" data-startTime="2592">benchmark. It's a kernel simulating benchmark </span><span class="line" data-startTime="2592">that spends a lot of time in calling small </span><span class="line" data-startTime="2596">methods and dispatching between different </span><span class="line" data-startTime="2596">objects in here. What you see on the graph </span><span class="line" data-startTime="2602">here is the Dart VM is on the graph. V8 is </span><span class="line" data-startTime="2602">there and DART to JS, which is the generated </span><span class="line" data-startTime="2609">code we get from compiling the Richards version </span><span class="line" data-startTime="2609">in Dart to JavaScript with our own Compiler </span><span class="line" data-startTime="2616">and running that on V8. So you have three </span><span class="line" data-startTime="2616">different runtime systems here in play that </span><span class="line" data-startTime="2621">execute the same benchmark. So the Dart VM </span><span class="line" data-startTime="2621">is the fastest, which is a nice thing. You </span><span class="line" data-startTime="2626">can see the V8 performance is getting better </span><span class="line" data-startTime="2626">but not at the same pace as the Dart VM. Bigger </span><span class="line" data-startTime="2632">is better here. V8 has tuned for this benchmark </span><span class="line" data-startTime="2632">since its inception. We started out with a </span><span class="line" data-startTime="2637">Richards benchmark and we have achieved a </span><span class="line" data-startTime="2637">lot of really cool speedups on these benchmarks </span><span class="line" data-startTime="2641">over the years. It means that V8 is fairly </span><span class="line" data-startTime="2641">good at optimizing for this kind of application </span><span class="line" data-startTime="2649">code and benchmark. The Dart VM is already </span><span class="line" data-startTime="2649">1.7 times faster than V8 generates way less </span><span class="line" data-startTime="2657">code when running the benchmark and much better </span><span class="line" data-startTime="2657">at executing that kind of code. The Dart to </span><span class="line" data-startTime="2662">JS code is a little bit behind. The handwritten </span><span class="line" data-startTime="2662">version of JavaScript that we use to tune </span><span class="line" data-startTime="2668">V8 and there's some extra checks going on </span><span class="line" data-startTime="2668">in there. Something we're improving over time </span><span class="line" data-startTime="2673">as you can see by the graph. But it's really </span><span class="line" data-startTime="2673">nice to see that over the last year, we have </span><span class="line" data-startTime="2678">been able to take the Dart VM from being a </span><span class="line" data-startTime="2678">fairly simple implementation of a fairly simple </span><span class="line" data-startTime="2683">language to being a really efficient implementation </span><span class="line" data-startTime="2683">of a fairly simple language. This also shows </span><span class="line" data-startTime="2690">on the DeltaBlue benchmark numbers. Here the </span><span class="line" data-startTime="2690">difference is even bigger. It's a factor of </span><span class="line" data-startTime="2694">2. DeltaBlue is a one-way constraint solver. </span></p>

<p><span class="line" data-startTime="2694">It spends time in allocating objects, constraints </span><span class="line" data-startTime="2700">and dispatcher on them. Again, it's a benchmark </span><span class="line" data-startTime="2700">that has been used for many different languages </span><span class="line" data-startTime="2706">and proven valuable in those context as well. </span> <span class="line" data-startTime="2706">It's great to see that here the same story </span><span class="line" data-startTime="2712">repeats itself. The Dart VM is just a lot </span><span class="line" data-startTime="2712">faster than V8. Of course, it's also faster </span><span class="line" data-startTime="2717">than a version we compiled to JavaScript. </span> <span class="line" data-startTime="2717">It's interesting to see that the Dart to JS </span><span class="line" data-startTime="2722">numbers here are actually faster than the </span><span class="line" data-startTime="2722">handwritten JavaScript. So the comparison </span><span class="line" data-startTime="2726">here is between handwritten JavaScript that </span><span class="line" data-startTime="2726">V8 executes, where we have tried to implement </span><span class="line" data-startTime="2733">DeltaBlue in a reasonable way in JavaScript. </span> <span class="line" data-startTime="2733">And then the generated code, this is also </span><span class="line" data-startTime="2739">JavaScript, that we compiled from Dart code </span><span class="line" data-startTime="2739">and the reason why it's a little bit faster </span><span class="line" data-startTime="2744">here is because we can do some analysis while </span><span class="line" data-startTime="2744">compiling. We can do some inlining to help </span><span class="line" data-startTime="2749">V8 execute this a little bit more quickly. </span> <span class="line" data-startTime="2749">We do expect this to be able to improve the </span><span class="line" data-startTime="2755">quality of the Dart to JS Compiler over time. </span> <span class="line" data-startTime="2755">We're aiming for trying to be as fast as the </span><span class="line" data-startTime="2761">code you would have written by hand in JavaScript. </span> <span class="line" data-startTime="2761">So but clearly, the Dart VM is faster in this </span><span class="line" data-startTime="2766">kind of thing. </span> <span class="line" data-startTime="2766">It's important to stress that performance </span><span class="line" data-startTime="2771">is super important to us. It really, really </span><span class="line" data-startTime="2771">matters that you get a really scalable application </span><span class="line" data-startTime="2776">platform out of using Dart. Having said that, </span><span class="line" data-startTime="2776">I think it's important to point to the fact </span><span class="line" data-startTime="2783">that users of Dart are really finding that </span><span class="line" data-startTime="2783">in addition to getting good performance, they </span><span class="line" data-startTime="2787">also feel that their productivity increased. </span></p>

<p><span class="line" data-startTime="2787">Ali has written a really large font atlas </span><span class="line" data-startTime="2795">generation tool, Glyph3D. We get this feedback </span><span class="line" data-startTime="2795">fairly consistently, that people that use </span><span class="line" data-startTime="2802">Dart for building bigger things are very, </span><span class="line" data-startTime="2802">very happy with it. </span></p>

<p class="speaker"><span class="line" data-starttime="2806"><span class="speakerName">Lars Bak</span>: Thank you. Just to follow up on </span><span class="line" data-startTime="2806">what Kasper said, performance is fantastic </span><span class="line" data-startTime="2817">in Dart right now and it's getting better </span><span class="line" data-startTime="2817">over time. We have seen on the web the last </span><span class="line" data-startTime="2823">few weeks some examples where Dart is out </span><span class="line" data-startTime="2823">performing Java. We are super excited about </span><span class="line" data-startTime="2829">that. We hope to get up to that level for </span><span class="line" data-startTime="2829">almost all applications basically. </span> <span class="line" data-startTime="2836">So the ultimate goal is to get the Dart VM </span><span class="line" data-startTime="2836">into Chrome. I hope you all agree. Exactly. </span> <span class="line" data-startTime="2848">At least one. </span> <span class="line" data-startTime="2848">[ Laughter ] </span><span class="line" data-startTime="2849">But we have a little bit of a problem here. </span> <span class="line" data-startTime="2849">I sort of mentioned that the garbage collection </span><span class="line" data-startTime="2856">is story where the DOM was a little bit complicated </span><span class="line" data-startTime="2856">with these reference counts and stuff like </span><span class="line" data-startTime="2861">that. And putting Dart VM into the pit doesn't </span><span class="line" data-startTime="2861">make it easier. And we cannot convince ourselves </span><span class="line" data-startTime="2869">with reference counting that we can reclaim </span><span class="line" data-startTime="2869">all unused cycles or memory data structures </span><span class="line" data-startTime="2877">in the browser. That means memory leaks. We </span><span class="line" data-startTime="2877">really do not want that. So that's a problem. </span></p>

<p><span class="line" data-startTime="2885">But we like to do something about it. The </span><span class="line" data-startTime="2885">ohm way we can make sure that we do something </span><span class="line" data-startTime="2890">about it is to actually change the reference </span><span class="line" data-startTime="2890">counted nature of the DOM. And we create a </span><span class="line" data-startTime="2897">new project, started last month. It's called </span><span class="line" data-startTime="2897">Oilpan. It makes sure that it handles garbage </span><span class="line" data-startTime="2904">collection between the difference segments </span><span class="line" data-startTime="2904">inside Chrome and Blink. Which is JavaScript, </span><span class="line" data-startTime="2910">DOM, eventually Dart. We want to convert the </span><span class="line" data-startTime="2910">reference count in DOM into being traced so </span><span class="line" data-startTime="2920">we can trace through JavaScript ons, through </span><span class="line" data-startTime="2920">DOM nodes and through Dart nodes and make </span><span class="line" data-startTime="2925">sure we know what we have. The cool thing </span><span class="line" data-startTime="2925">about tracing is you can find all pointers </span><span class="line" data-startTime="2931">that point to an object. That means you can </span><span class="line" data-startTime="2931">move the object if you choose to do so. You </span><span class="line" data-startTime="2937">can even do [indiscernible] and start from </span><span class="line" data-startTime="2937">that point on. And if you are really brave, </span><span class="line" data-startTime="2950">we can start doing concurrent manipulation </span><span class="line" data-startTime="2950">of the DOM. So we hope this is all appealing </span><span class="line" data-startTime="2957">for us guys because it basically means we </span><span class="line" data-startTime="2957">get a much faster browser out of it and a </span><span class="line" data-startTime="2962">browser use less memory. One thing about the </span><span class="line" data-startTime="2962">con currency when you have reference counting </span><span class="line" data-startTime="2969">in the objects, you actually have to put in </span><span class="line" data-startTime="2969">a lock around it if you do concurrent access. </span></p>

<p><span class="line" data-startTime="2975">That's expensive. When you get a pointer to </span><span class="line" data-startTime="2975">an object, you have to lock, increment the </span><span class="line" data-startTime="2981">pointer, unlock again. That's not practical </span><span class="line" data-startTime="2981">when using reference counting. We can do all </span><span class="line" data-startTime="2985">this if unify the memory manager for playing. </span> <span class="line" data-startTime="2985">We are excited about this project. </span></p>

<p class="speaker"><span class="line" data-starttime="2992"><span class="speakerName">Kasper Lund</span>: We feel like no presentation </span><span class="line" data-startTime="2992">is really done without a demo of some sort. </span><span class="line" data-startTime="2999">So lately we have been working on making Dart </span><span class="line" data-startTime="2999">even faster. No surprise there. A lot of modern </span><span class="line" data-startTime="3005">CPUs today support what is known as SIMD, </span><span class="line" data-startTime="3005">single instruction multi-data instructions, </span><span class="line" data-startTime="3010">where you have instructions on the CPU that </span><span class="line" data-startTime="3010">can operate on four floating point values </span><span class="line" data-startTime="3016">in parallel making it much, much faster. So </span><span class="line" data-startTime="3016">the Dart VM has been enhanced for support </span><span class="line" data-startTime="3021">for using those instructions and no other </span><span class="line" data-startTime="3021">web language has the support yet. It's very </span><span class="line" data-startTime="3027">nice to see this in action in a browser, just </span><span class="line" data-startTime="3027">making things faster. It's really useful for </span><span class="line" data-startTime="3032">3D calculations, image processing, audio processing. </span><span class="line" data-startTime="3032">We would like to show you a little demo of </span><span class="line" data-startTime="3039">Google Chrome with the Dart VM put in there </span><span class="line" data-startTime="3039">running a 3D animation thing with and without </span><span class="line" data-startTime="3045">the SIMD support to show you the significance </span><span class="line" data-startTime="3045">of this kind of work. So let's switch to the </span><span class="line" data-startTime="3050">other. </span></p>

<p class="speaker"><span class="line" data-starttime="3050"><span class="speakerName">Lars Bak</span>: So here we are running Dart VM </span><span class="line" data-startTime="3061">with a Blink with Dart VM. We have a bunch </span><span class="line" data-startTime="3061">of monsters. They all handle inside Dart. </span><span class="line" data-startTime="3069">So that means that the animation, the skeleton </span><span class="line" data-startTime="3069">positions and all that is happening inside </span><span class="line" data-startTime="3075">Dart. It's not on the GPU. And this is the </span><span class="line" data-startTime="3075">&mdash; somebody is beeping. This benchmark has </span><span class="line" data-startTime="3085">been created so it is trying to always have </span><span class="line" data-startTime="3085">60 frames per second. If it runs too fast, </span><span class="line" data-startTime="3091">it will throw in more monsters. We have 34. </span><span class="line" data-startTime="3091">We can turn it on with using a flag down here. </span><span class="line" data-startTime="3105">Let's try it. SIMD. So this is using SIMD </span><span class="line" data-startTime="3105">in animation in Dart. </span><span class="line" data-startTime="3120">[ Applause ] </span><span class="line" data-startTime="3120">So a factor of three and a half is not too </span><span class="line" data-startTime="3125">bad, I guess. I'm really excited about this </span><span class="line" data-startTime="3125">and it actually gives you a lot more power </span><span class="line" data-startTime="3132">to do computation inside JavaScript. So this </span><span class="line" data-startTime="3132">is coming to you and I'm excited. </span></p>

<p class="speaker"><span class="line" data-starttime="3140"><span class="speakerName">Kasper Lund</span>: So let's conclude this presentation </span><span class="line" data-startTime="3140">so we have time for some questions. So we </span><span class="line" data-startTime="3153">are VM guys. We want to have a job moving </span><span class="line" data-startTime="3153">forward. We think performance is always interesting. </span> <span class="line" data-startTime="3159">I hope you like that, too. And we hope we </span><span class="line" data-startTime="3159">have convinced you that if you really want </span><span class="line" data-startTime="3166">to spark more performance into the browser, </span><span class="line" data-startTime="3166">we need probably a different option than JavaScript. </span> <span class="line" data-startTime="3173">I think Dart is one contender for that. The </span><span class="line" data-startTime="3173">Dart VM is already faster than JavaScript </span><span class="line" data-startTime="3181">and is approaching other programming languages </span><span class="line" data-startTime="3181">out there. Again, just to point it out again </span><span class="line" data-startTime="3188">that higher performance is great for application </span><span class="line" data-startTime="3188">developers. That's where you actually can </span><span class="line" data-startTime="3193">get head room to do more interesting stuff. </span> <span class="line" data-startTime="3193">Right now, the core Dart platform is stable. </span> <span class="line" data-startTime="3201">We will start using the SDK. That doesn't </span><span class="line" data-startTime="3201">mean it's inside Chrome. After we send out </span><span class="line" data-startTime="3209">1.0, that will be our main focus. Right now </span><span class="line" data-startTime="3209">you can see people on the web using Dart. </span> <span class="line" data-startTime="3216">Some have written fairly large bodies of code </span><span class="line" data-startTime="3216">and they are happy with it. And inside Google </span><span class="line" data-startTime="3223">people have started using it. There's critical </span><span class="line" data-startTime="3223">projects start using Dart, hopefully we will </span><span class="line" data-startTime="3229">see some of these applications coming to you </span><span class="line" data-startTime="3229">soon. This will conclude our presentation. </span> <span class="line" data-startTime="3236">We should go to questions. </span></p>

<p><span class="line" data-startTime="3236">[ Applause ] </span></p>

<p class="speaker"><span class="line" data-starttime="3241"><span class="speakerName">Kasper Lund</span>: If we are unable to answer </span><span class="line" data-startTime="3241">your questions here. We have other Dart questions </span><span class="line" data-startTime="3253">at Google I/O today. So if you have found </span><span class="line" data-startTime="3253">this inspiring and you want to see more on </span><span class="line" data-startTime="3258">more specific details, here's a list of things </span><span class="line" data-startTime="3258">in room &mdash; mostly in room 6, I guess, where </span><span class="line" data-startTime="3264">you can see other Dart presentations here. </span><span class="line" data-startTime="3264">Yes? </span></p>

<p class="speaker"><span class="line" data-starttime="3268"><span class="speakerName">Lars Bak</span>: Let's get the first question. </span></p>

<p class="speaker"><span class="line" data-starttime="3268"><span class="speakerName">Audience member</span>: My question is slightly related to that </span><span class="line" data-startTime="3273">first one, coming from a GWT development background, </span><span class="line" data-startTime="3273">wondering if you have done any benchmarks </span><span class="line" data-startTime="3279">in comparison from the Dart to JavaScript </span><span class="line" data-startTime="3279">Compiler to the Java to JavaScript Compiler. </span></p>

<p class="speaker"><span class="line" data-starttime="3286"><span class="speakerName">Lars Bak</span>: I don't have any numbers for you. </span><span class="line" data-startTime="3286">It is easy to try out. DeltaBlue, it is free </span><span class="line" data-startTime="3294">to try out for yourself. One thing I would </span><span class="line" data-startTime="3294">like to see is that we are trying to go beyond </span><span class="line" data-startTime="3308">grit in that we are doing a native Dart VM </span><span class="line" data-startTime="3308">that can boost performance and reduce startup </span><span class="line" data-startTime="3315">time. This is really what we want to get at. </span><span class="line" data-startTime="3315">Especially for mobile platforms where loading </span><span class="line" data-startTime="3320">an application can be a dog and take many </span><span class="line" data-startTime="3320">resources. Faster VM, faster startup means </span><span class="line" data-startTime="3326">less battery. Next question, please. </span></p>

<p class="speaker"><span class="line" data-starttime="3326"><span class="speakerName">Audience member</span>: Hi. Have there been discussions of including </span><span class="line" data-startTime="3333">Dart in other browsers and if not, would it </span><span class="line" data-startTime="3333">be possible to add it through plug-ins? </span></p>

<p class="speaker"><span class="line" data-starttime="3339"><span class="speakerName">Lars Bak</span>: It will be fantastic to have all </span><span class="line" data-startTime="3339">browsers using Dart. Clearly people have strong </span><span class="line" data-startTime="3351">opinions when it comes to programming languages. </span><span class="line" data-startTime="3351">I don't really understand why but that's how </span><span class="line" data-startTime="3355">it is. </span><span class="line" data-startTime="3355">[ Laughter ] </span><span class="line" data-startTime="3358">I just want to make sure that people the right </span><span class="line" data-startTime="3358">tools to build the applications with. Our </span><span class="line" data-startTime="3363">system is completely open source. It has a </span><span class="line" data-startTime="3363">well-defined API. So when other browsers think </span><span class="line" data-startTime="3368">that this extra boost of performance will </span><span class="line" data-startTime="3368">be good for them, they can take it up and </span><span class="line" data-startTime="3372">we will be happy to help them out, basically. </span><span class="line" data-startTime="3372">So we are open for collaboration. </span></p>

<p class="speaker"><span class="line" data-starttime="3377"><span class="speakerName">Kasper Lund</span>: We have a few questions from </span><span class="line" data-startTime="3377">our online audience and maybe just try to </span><span class="line" data-startTime="3383">answer a few of them as well. I can cover </span><span class="line" data-startTime="3383">the second one. I think you covered the grit </span><span class="line" data-startTime="3388">question already. This question is about Android </span><span class="line" data-startTime="3388">studio. And if we are planning on releasing </span><span class="line" data-startTime="3394">something similar for Dart. In a sense we </span><span class="line" data-startTime="3394">already are releasing something similar for </span><span class="line" data-startTime="3399">Dart. We have a fully-featured Dart editor. </span> <span class="line" data-startTime="3399">But in addition to that, and maybe this is </span><span class="line" data-startTime="3405">what the question is really about, we do have </span><span class="line" data-startTime="3405">support for using and working with Dart from </span><span class="line" data-startTime="3409">IntelliJ. It is here. If you are interested </span><span class="line" data-startTime="3409">in this kind of thing, definitely come talk </span><span class="line" data-startTime="3416">to them at the booth. So the short answer </span><span class="line" data-startTime="3416">is really that we are looking into releasing </span><span class="line" data-startTime="3421">all sorts of nice tools for Dart being based </span><span class="line" data-startTime="3421">both on Eclipse and IntelliJ. Definitely. </span></p>

<p></p>

<p class="speaker"><span class="line" data-starttime="3426"><span class="speakerName">Lars Bak</span>: Let's take the next question from </span><span class="line" data-startTime="3426">the audience. </span></p>

<p class="speaker"><span class="line" data-starttime="3429"><span class="speakerName">Audience member</span>: Hi. I have a bit of long &mdash; seemingly </span><span class="line" data-startTime="3429">longstanding wisdom I got a few years ago </span><span class="line" data-startTime="3435">that occurs to me might be out of date which </span><span class="line" data-startTime="3435">is the idea &mdash; this is about V8, that JavaScript </span><span class="line" data-startTime="3441">objects are going to be more performant if </span><span class="line" data-startTime="3441">you define prototype rather than defining </span><span class="line" data-startTime="3446">methods dynamically in a constructor. It occurs </span><span class="line" data-startTime="3446">to me with hidden, you have optimized it so </span><span class="line" data-startTime="3452">it wouldn't make a difference. </span></p>

<p class="speaker"><span class="line" data-starttime="3452"><span class="speakerName">Lars Bak</span>: We certainly try to. We tried </span><span class="line" data-startTime="3459">very hard to optimize in V8. But it's still </span><span class="line" data-startTime="3459">the case that you have to create a new class </span><span class="line" data-startTime="3466">whenever you add a property in a way you haven't </span><span class="line" data-startTime="3466">seen before. So you get a forest of classes </span><span class="line" data-startTime="3472">even for the same constructor. And in Dart, </span><span class="line" data-startTime="3472">you only have one format for one class whereas </span><span class="line" data-startTime="3479">in V8, right, depending on how you add properties </span><span class="line" data-startTime="3479">to an object from a given constructor, you </span><span class="line" data-startTime="3486">can get a sea of them. We have to cut off </span><span class="line" data-startTime="3486">at some point. We have limits inside V8. When </span><span class="line" data-startTime="3490">you reach a certain number of hidden classes </span><span class="line" data-startTime="3490">for constructer. We say, we actually just </span><span class="line" data-startTime="3496">&mdash; we de-optimize now and we make sure that </span><span class="line" data-startTime="3496">objects will only be treated as maps and get </span><span class="line" data-startTime="3504">slow. </span></p>

<p class="speaker"><span class="line" data-starttime="3504"><span class="speakerName">Audience member</span>: So is it true that, then, prototype would </span><span class="line" data-startTime="3507">be more performant in V8 than using construct-defining </span><span class="line" data-startTime="3507">properties, even if you define them the same </span><span class="line" data-startTime="3512">way every time in constructor. </span></p>

<p class="speaker"><span class="line" data-starttime="3512"><span class="speakerName">Lars Bak</span>: I think it depends on exactly </span><span class="line" data-startTime="3516">the setup. You can make it so they perform </span><span class="line" data-startTime="3516">exactly the same. It really depends on how </span><span class="line" data-startTime="3521">the application adds properties to your object </span><span class="line" data-startTime="3521">on the fly. </span></p>

<p class="speaker"><span class="line" data-starttime="3526"><span class="speakerName">Kasper Lund</span>: Little bit of explanation. </span><span class="line" data-startTime="3526">V8 does try to move functions to the class </span><span class="line" data-startTime="3532">side so to share them behind the scenes anyway. </span><span class="line" data-startTime="3532">So you can say adding on the objects is sort </span><span class="line" data-startTime="3537">of optimize too, but it really depends on </span><span class="line" data-startTime="3537">the application if it makes a difference. </span></p>

<p class="speaker"><span class="line" data-starttime="3542"><span class="speakerName">Lars Bak</span>: Next question. </span></p>

<p class="speaker"><span class="line" data-starttime="3542"><span class="speakerName">Audience member</span>: One of the arguments for no JS is that </span><span class="line" data-startTime="3546">you have JavaScript everywhere, service side </span><span class="line" data-startTime="3546">even. Are you looking at Dart service side </span><span class="line" data-startTime="3551">or is there more momentum behind go. </span></p>

<p class="speaker"><span class="line" data-starttime="3551"><span class="speakerName">Lars Bak</span>: That's a great question. Of course, </span><span class="line" data-startTime="3556">we have that. So we have a service side library </span><span class="line" data-startTime="3556">you can use. You can use the Dart VM stand </span><span class="line" data-startTime="3565">alone if you want to. You can use the same </span><span class="line" data-startTime="3565">kind of ace synchronize size style as you </span><span class="line" data-startTime="3570">do in no JS. You saw the performance numbers </span><span class="line" data-startTime="3570">on the slide. This is a performance measurement </span><span class="line" data-startTime="3578">system we are using internally, all written </span><span class="line" data-startTime="3578">in Dart. It controls a lot of machines at </span><span class="line" data-startTime="3585">the same time we use exactly that server side </span><span class="line" data-startTime="3585">system. So, yes, we have a libraries for supporting </span><span class="line" data-startTime="3594">service side Dart execution but our main focus </span><span class="line" data-startTime="3594">right now is the client side and getting it </span><span class="line" data-startTime="3600">to Chrome. </span></p>

<p class="speaker"><span class="line" data-starttime="3600"><span class="speakerName">Kasper Lund</span>: I think we have time for one </span><span class="line" data-startTime="3602">more question. If you have more questions, </span><span class="line" data-startTime="3602">the large line, it will be at the office hours </span><span class="line" data-startTime="3608">booth so come to us and ask those questions </span><span class="line" data-startTime="3608">there. But let's take the final question. </span></p>

<p class="speaker"><span class="line" data-starttime="3614"><span class="speakerName">Audience member</span>: My question is there's a lot of JavaScript </span><span class="line" data-startTime="3614">code already there. Is there a tool, or even </span><span class="line" data-startTime="3619">if it is possible, to convert JavaScript into </span><span class="line" data-startTime="3619">Dart. </span></p>

<p class="speaker"><span class="line" data-starttime="3622"><span class="speakerName">Kasper Lund</span>: Generally we find that people </span><span class="line" data-startTime="3622">that try to rewrite existing code basis from </span><span class="line" data-startTime="3627">JavaScript or from other languages to Dart </span><span class="line" data-startTime="3627">are generally fairly successful. It's also </span><span class="line" data-startTime="3632">possible to use the JavaScript code from Dart </span><span class="line" data-startTime="3632">by wrapping it a little bit and using what </span><span class="line" data-startTime="3636">we called JavaScript interrupt. But generally </span><span class="line" data-startTime="3636">translating from JavaScript, unless you use </span><span class="line" data-startTime="3643">very, very dynamic features of JavaScript </span><span class="line" data-startTime="3643">a lot, it's actually recently easy. A lot </span><span class="line" data-startTime="3648">of people have good success with that. </span></p>

<p class="speaker"><span class="line" data-starttime="3648"><span class="speakerName">Audience member</span>: You guys have a tool. </span></p>

<p class="speaker"><span class="line" data-starttime="3651"><span class="speakerName">Kasper Lund</span>: There is no tool, no. </span></p>

<p class="speaker"><span class="line" data-starttime="3651"><span class="speakerName">Lars Bak</span>: Thank you very much. </span><span class="line" data-startTime="3657">[ Applause ] </span></p>