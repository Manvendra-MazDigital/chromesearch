<p class="speaker"><span class="line" data-starttime="2"><span class="speakerName">Boris Smus</span>: Hi, folks. </span></p>

<p class="speaker"><span class="line" data-starttime="2"><span class="speakerName">Audience member</span>: Hey! </span></p>

<p class="speaker"><span class="line" data-starttime="2"><span class="speakerName">Boris Smus</span>: All right. Welcome to Point, </span><span class="line" data-startTime="2">Click, Tap, Touch, a session about building </span><span class="line" data-startTime="6">multi-device web interfaces. My name is Boris, </span><span class="line" data-startTime="6">and I'm a research engineer working on user </span><span class="line" data-startTime="13">interfaces in the Google research group. </span></p>

<p class="speaker"><span class="line" data-starttime="13"><span class="speakerName">Rick Byers</span>: And I'm Rick. I work on touchscreen </span><span class="line" data-startTime="18">support in Chrome and I'm a member of the </span><span class="line" data-startTime="18">W3C standards groups working on standardizing </span><span class="line" data-startTime="22">touchscreen support on the web. </span></p>

<p class="speaker"><span class="line" data-starttime="22"><span class="speakerName">Boris Smus</span>: So today's talk is mostly going </span><span class="line" data-startTime="25">to be about input and we'll talk a bit about </span><span class="line" data-startTime="25">mouse space input but the bulk of it is going </span><span class="line" data-startTime="31">to be about touchscreens. </span> <span class="line" data-startTime="31">So just to motivate that, I'm sure you've </span><span class="line" data-startTime="36">all got a touchscreen device, or maybe two, </span><span class="line" data-startTime="36">or maybe three, now that you've got Pixels, </span><span class="line" data-startTime="42">and so touch is becoming even more ubiquitous </span><span class="line" data-startTime="42">than it was a year ago. </span> <span class="line" data-startTime="46">Mobile touch &mdash; mobile use in general is projected </span><span class="line" data-startTime="46">to overtake the desktop sometime early next </span><span class="line" data-startTime="52">year, and the revenue forecast of touchscreen </span><span class="line" data-startTime="52">modules only corroborate that. You can see </span><span class="line" data-startTime="58">it's a very up-and-to-the-right kind of graph. </span></p>

<p><span class="line" data-startTime="58">Also we've got this new &mdash; relatively new </span><span class="line" data-startTime="64">form factor of touch laptops, of which the </span><span class="line" data-startTime="64">Pixel is one, and also Windows &mdash; Windows </span><span class="line" data-startTime="70">machines are becoming increasingly touch-enabled. </span> <span class="line" data-startTime="70">Something like a quarter of Windows 8 laptop </span><span class="line" data-startTime="75">sales have a touchscreen. So if you're a developer </span><span class="line" data-startTime="75">working on the web, you should expect your </span><span class="line" data-startTime="82">users to have a touchscreen device increasingly. </span> <span class="line" data-startTime="82">And the good thing here is that the web has </span><span class="line" data-startTime="88">a very powerful touch event API and it's been </span><span class="line" data-startTime="88">around for something like five, six years </span><span class="line" data-startTime="93">and has become standard over the last two </span><span class="line" data-startTime="93">years or so, and the basics of this API is </span><span class="line" data-startTime="98">we've got a touchstart event which fires when </span><span class="line" data-startTime="98">your finger hits the screen, touchmove continually </span><span class="line" data-startTime="103">fires as you're moving around, touchend and </span><span class="line" data-startTime="103">touchcancel are two different ways of ending </span><span class="line" data-startTime="108">that interaction. </span> <span class="line" data-startTime="108">So touchend is the natural thing that happens </span><span class="line" data-startTime="111">when your finger is raised and touchcancel </span><span class="line" data-startTime="111">happens if your finger was &mdash; if your touch </span><span class="line" data-startTime="116">gesture was cancelled for some other reason. </span> <span class="line" data-startTime="116">On Android, for example, if you start scrolling </span><span class="line" data-startTime="120">an area, touchcancel will fire as the browser </span><span class="line" data-startTime="120">begins to scroll. </span></p>

<p><span class="line" data-startTime="128">So to distinguish between these multiple touches, </span><span class="line" data-startTime="128">each one has a consistent identifier, and </span><span class="line" data-startTime="135">this API that I'm describing works really </span><span class="line" data-startTime="135">well across a number of devices. Basically </span><span class="line" data-startTime="141">across the whole modern mobile browser landscape. </span> <span class="line" data-startTime="141">So let me quickly show you how this looks. </span> <span class="line" data-startTime="147">On a Pixel, which is what I'm demoing from, </span><span class="line" data-startTime="147">I've got this paint application. You can see </span><span class="line" data-startTime="152">that as soon as I lower my fingers, I can </span><span class="line" data-startTime="152">do this amazing finger-painting exercise. </span> <span class="line" data-startTime="159">And we support up to 10 points and you can </span><span class="line" data-startTime="159">see each finger has a unique color which is </span><span class="line" data-startTime="166">because they have unique IDs. </span></p>

<p><span class="line" data-startTime="166">Now, if I didn't have a touchscreen, I could </span><span class="line" data-startTime="172">emulate this behavior with just a mouse, and </span><span class="line" data-startTime="172">you can see I can override this by turning </span><span class="line" data-startTime="178">on emulate touch events in the Chrome developer </span><span class="line" data-startTime="178">tools, and when I do that, I get this little </span><span class="line" data-startTime="185">finger-like thing on the screen every time </span><span class="line" data-startTime="185">I move the mouse. </span> <span class="line" data-startTime="188">And it's just a good reminder that says, "Hey, </span><span class="line" data-startTime="188">there's a certain size to your finger," that </span><span class="line" data-startTime="193">it's not as precise as your mouse. And I'll </span><span class="line" data-startTime="193">talk more about that. </span> <span class="line" data-startTime="196">Now, of course because this is a standard </span><span class="line" data-startTime="196">API, it works just as well across a variety </span><span class="line" data-startTime="204">of devices, so here I've got the same exact </span><span class="line" data-startTime="204">code running on a phone, and you can see that </span><span class="line" data-startTime="212">the behavior of this application is the same. </span> <span class="line" data-startTime="212">Okay. So I'll run through a couple of design </span><span class="line" data-startTime="223">suggestions, because designing for touch is </span><span class="line" data-startTime="223">quite different from designing for mouse and </span><span class="line" data-startTime="229">keyboard. </span> <span class="line" data-startTime="229">So the first tip here is obviously touch interfaces </span><span class="line" data-startTime="235">require bigger targets. Your finger is inherently </span><span class="line" data-startTime="235">far less precise than a mouse, which can give </span><span class="line" data-startTime="242">you one- or two-pixel precision, but exactly </span><span class="line" data-startTime="242">how big? </span><span class="line" data-startTime="246">So extensive research has been done to suggest </span><span class="line" data-startTime="246">that 9-by-9 millimeters is something like </span><span class="line" data-startTime="250">the optimal touch target size, but the web </span><span class="line" data-startTime="250">has a few things that complicate matters. </span> <span class="line" data-startTime="258">First, we've got a whole variety of devices </span><span class="line" data-startTime="258">to support, and they vary hugely in their </span><span class="line" data-startTime="265">device density, so DPI varies, and therefore </span><span class="line" data-startTime="265">it's hard to map physical size to device pixels. </span></p>

<p><span class="line" data-startTime="271">And secondly, the web has this concept of </span><span class="line" data-startTime="271">CSS pixels not necessarily being the same </span><span class="line" data-startTime="276">as device pixels because they're modified </span><span class="line" data-startTime="276">by something called device Pixel ratio. </span> <span class="line" data-startTime="281">So with these two things in mind, we can do </span><span class="line" data-startTime="281">some calculations for a variety of popular </span><span class="line" data-startTime="287">devices. </span> <span class="line" data-startTime="287">Here we've got the Nexus line where we convert </span><span class="line" data-startTime="290">9 millimeters into pixels and we can see what </span><span class="line" data-startTime="290">that looks like on these devices. </span> <span class="line" data-startTime="295">On the Chromebook Pixel, it's something &mdash; because </span><span class="line" data-startTime="295">of further distance of interaction, you end </span><span class="line" data-startTime="302">up with screwy &mdash; with a slightly bigger &mdash; with </span><span class="line" data-startTime="302">fewer pixels required to represent the same </span><span class="line" data-startTime="312">physical size. </span></p>

<p><span class="line" data-startTime="312">So while we don't have like a clear guideline </span><span class="line" data-startTime="316">in this case of what size you should use, </span><span class="line" data-startTime="316">something between 42 and 58 pixels is our </span><span class="line" data-startTime="321">recommendation. </span> <span class="line" data-startTime="321">And this is fairly consistent with other guidelines. </span> <span class="line" data-startTime="328">Second tip is related to hover. So hover we </span><span class="line" data-startTime="328">can activate in two ways, generally with a </span><span class="line" data-startTime="333">mouse-based interface, so with CSS, using </span><span class="line" data-startTime="333">the colon hover pseudo-selector and with JavaScript </span><span class="line" data-startTime="339">using mouseover and mouseout events. </span> <span class="line" data-startTime="339">With touchscreens, generally, with some exceptions </span><span class="line" data-startTime="345">like the Samsung S4 which has above-surface </span><span class="line" data-startTime="345">hover, basically we don't have access to hover </span><span class="line" data-startTime="352">state. And even in the case of the S4, that </span><span class="line" data-startTime="352">hover state is only in hardware and available </span><span class="line" data-startTime="357">in Android. It's not exposed to the web yet. </span> <span class="line" data-startTime="357">So what do we do in the case of &mdash; in the </span><span class="line" data-startTime="365">case of touch for hover? </span><span class="line" data-startTime="365">Basically, here's an example of a hover test </span><span class="line" data-startTime="372">page. We've got two hover areas. One of them </span><span class="line" data-startTime="372">has a link, the other does not. And I can </span><span class="line" data-startTime="376">just activate hover by &mdash; by tapping. </span></p>

<p><span class="line" data-startTime="376">So a single tap activates hover on mobile </span><span class="line" data-startTime="381">devices with touchscreens. </span> <span class="line" data-startTime="381">The problem is if you have a hover and a link </span><span class="line" data-startTime="386">underlying that. </span> <span class="line" data-startTime="386">So in this case, if I click this area that </span><span class="line" data-startTime="391">has a link, the hover state was triggered </span><span class="line" data-startTime="391">but for so brief a time that the user didn't </span><span class="line" data-startTime="396">actually get to see it. So this happens a </span><span class="line" data-startTime="396">lot when you have menus, hierarchical menus </span><span class="line" data-startTime="400">that are activated on hover, and it's something </span><span class="line" data-startTime="400">to definitely avoid. </span> <span class="line" data-startTime="406">Okay. The last designing kind of thing that </span><span class="line" data-startTime="406">I want to talk about is the touch laptop form </span><span class="line" data-startTime="414">factor and the kind of untapped potential </span><span class="line" data-startTime="414">that this form factor can bring. </span> <span class="line" data-startTime="419">So there's two sort of axes here. </span> <span class="line" data-startTime="419">First, we can think about switching between </span><span class="line" data-startTime="424">these two modalities of touch and not touch, </span><span class="line" data-startTime="424">and it might look something like this. </span></p>

<p><span class="line" data-startTime="431">So here's a gallery of photos. In this case, </span><span class="line" data-startTime="431">I've got photos of celebrities. You can see </span><span class="line" data-startTime="442">it's a very standard kind of interface and </span><span class="line" data-startTime="442">I can pick new pictures with my mouse. It's </span><span class="line" data-startTime="449">great. </span> <span class="line" data-startTime="449">So what happens if I want to use a touch device, </span><span class="line" data-startTime="453">or my touchscreen in this case? </span><span class="line" data-startTime="453">This is way too small for me to tap. </span> <span class="line" data-startTime="458">So you can see if &mdash; as soon as I tap this </span><span class="line" data-startTime="458">&mdash; this page, I get this responsive input </span><span class="line" data-startTime="463">effect and now everything is far more tappable. </span> <span class="line" data-startTime="463">So when I switch back to mouse, the page readjusts </span><span class="line" data-startTime="470">back. </span> <span class="line" data-startTime="470">So this is an interesting concept that you </span><span class="line" data-startTime="472">might want to explore. </span> <span class="line" data-startTime="472">Another possibility is to use both modes together. </span></p>

<p><span class="line" data-startTime="480">So in this page, I have a map that I have </span><span class="line" data-startTime="480">pointer-locked so whenever I pan around with </span><span class="line" data-startTime="486">my trackpad or pinch zoom &mdash; or sorry, two-finger </span><span class="line" data-startTime="486">scroll, I can navigate the map. And I can </span><span class="line" data-startTime="494">also place waypoints on this map using my </span><span class="line" data-startTime="494">touchscreen. So it's sort of an interesting </span><span class="line" data-startTime="499">interaction using both &mdash; both touch surfaces </span><span class="line" data-startTime="499">simultaneously. </span> <span class="line" data-startTime="504">And along the same veins, in this example </span><span class="line" data-startTime="504">I have a small green rectangle that I can </span><span class="line" data-startTime="509">move around as you'd expect, but I can also </span><span class="line" data-startTime="509">simultaneously move my trackpad to rotate </span><span class="line" data-startTime="516">it and with two fingers I'll create a scaling </span><span class="line" data-startTime="516">effect. </span> <span class="line" data-startTime="521">And I can do these things simultaneously. </span> <span class="line" data-startTime="521">So it's kind of an interesting interaction </span><span class="line" data-startTime="524">that's only possible with these two touch </span><span class="line" data-startTime="524">surfaces simultaneously. </span></p>

<p><span class="line" data-startTime="530">So with that, I'll hand over to Rick to talk </span><span class="line" data-startTime="530">about some common problems and their solutions. </span></p>

<p class="speaker"><span class="line" data-starttime="536"><span class="speakerName">Rick Byers</span>: So in getting the Pixel ready </span><span class="line" data-startTime="536">to ship, we worked with a lot of different </span><span class="line" data-startTime="541">web properties to help them make their Web </span><span class="line" data-startTime="541">sites that were designed for desktop work </span><span class="line" data-startTime="545">better with touch. </span><span class="line" data-startTime="545">So what I want to go through here is some </span><span class="line" data-startTime="547">of the common issues that we came across that </span><span class="line" data-startTime="547">people hit regularly. </span><span class="line" data-startTime="550">The first one is this code. Does anyone realize </span><span class="line" data-startTime="550">off the bat what the problem is with this </span><span class="line" data-startTime="556">code? </span><span class="line" data-startTime="556"> (Speaker is off microphone.) </span></p>

<p class="speaker"><span class="line" data-starttime="559"><span class="speakerName">Rick Byers</span>: Right. If you use it on a Pixel, </span><span class="line" data-startTime="559">you can't use the trackpad. And really this </span><span class="line" data-startTime="563">isn't about the Pixel. This code was &mdash; you </span><span class="line" data-startTime="563">know, the assumption here is if I've got touch </span><span class="line" data-startTime="567">support, like in particular the touch event </span><span class="line" data-startTime="567">APIs are supported on this browser, then I </span><span class="line" data-startTime="572">must be on a mobile device and I shouldn't </span><span class="line" data-startTime="572">listen to mouse events. And this was actually </span><span class="line" data-startTime="575">never correct. BlackBerry devices have a little </span><span class="line" data-startTime="575">trackball that sends mouse events, so this </span><span class="line" data-startTime="579">would also disable that. But this is really </span><span class="line" data-startTime="579">bad for touchscreen laptops. It means someone's </span><span class="line" data-startTime="584">got their laptop and they upgrade to their </span><span class="line" data-startTime="584">spiffy new touchscreen laptop and now a site </span><span class="line" data-startTime="587">that they're used to using with their trackpad </span><span class="line" data-startTime="587">no longer works with the trackpad. Just because </span><span class="line" data-startTime="592">someone has a touchscreen on their laptop </span><span class="line" data-startTime="592">doesn't mean they're going to use it all the </span><span class="line" data-startTime="595">time. In fact, a lot of users only use it </span><span class="line" data-startTime="595">for special circumstances, like maps and whatnot, </span><span class="line" data-startTime="600">and it really varies how much people use their </span><span class="line" data-startTime="600">touchscreen on their laptop. </span></p>

<p><span class="line" data-startTime="602">So you really don't want to disable mouse </span><span class="line" data-startTime="602">support just because there's touch support. </span> <span class="line" data-startTime="607">Let me show you an example of that. </span> <span class="line" data-startTime="607">Not to pick on any particular site in particular, </span><span class="line" data-startTime="611">but this page, this site, just to show you </span><span class="line" data-startTime="611">how frustrating it is, I move my mouse over </span><span class="line" data-startTime="615">these buttons and clearly I should be able </span><span class="line" data-startTime="615">to click on these, but when I click, nothing </span><span class="line" data-startTime="620">happens, and it's really frustrating and you </span><span class="line" data-startTime="620">say, "Why the heck can't I click on this?" </span><span class="line" data-startTime="623">Until you realize, "Oh, actually, I can tap </span><span class="line" data-startTime="623">with touch." </span><span class="line" data-startTime="628">And that's just because they've stopped listening </span><span class="line" data-startTime="628">to the click event because it detects a touchscreen. </span> <span class="line" data-startTime="635">So don't do that. </span> <span class="line" data-startTime="635">So how do you &mdash; what do you do instead? </span><span class="line" data-startTime="638">So when you limit, don't try to predict whether </span><span class="line" data-startTime="638">or not the user is going to do touch. In the </span><span class="line" data-startTime="641">limit, you can't predict it. For example, </span><span class="line" data-startTime="641">they might have a USB touchscreen that's connected </span><span class="line" data-startTime="645">to a KVM switch, so it might come and go during </span><span class="line" data-startTime="645">the lifetime of the page, so you can't predict </span><span class="line" data-startTime="649">whether or not the user's going to use touch. </span> <span class="line" data-startTime="649">Instead, what you should do is always listen </span><span class="line" data-startTime="652">for touch events and mouse events and then </span><span class="line" data-startTime="652">you can decide dynamically, when you see a </span><span class="line" data-startTime="656">touch event get used, then you know the user </span><span class="line" data-startTime="656">is using touch. </span> <span class="line" data-startTime="659">So in this case, we listened for both all </span><span class="line" data-startTime="659">the time, and I think the main reason people </span><span class="line" data-startTime="664">don't do this is for compatibility, touch </span><span class="line" data-startTime="664">events by default, if I tap the screen, it </span><span class="line" data-startTime="668">will send a series of mouse events to emulate </span><span class="line" data-startTime="668">a mouse click, so all these Web sites that </span><span class="line" data-startTime="673">were designed just for mouse will still work </span><span class="line" data-startTime="673">by tapping the touchscreen. </span></p>

<p><span class="line" data-startTime="677">And so I think the reason people stop listening </span><span class="line" data-startTime="677">for mouse events is they want to avoid hitting </span><span class="line" data-startTime="681">that redundant click event, but the right </span><span class="line" data-startTime="681">way to do that is when you've consumed a touch </span><span class="line" data-startTime="685">event is to call preventDefault on the event. </span> <span class="line" data-startTime="685">PreventDefault tells the browser "I've handled </span><span class="line" data-startTime="690">this, please don't do something else with </span><span class="line" data-startTime="690">it." And this is generally what you want to </span><span class="line" data-startTime="693">do anyway in most scenarios. </span> <span class="line" data-startTime="693">You know, if you're using touch to manipulate </span><span class="line" data-startTime="697">an object, you don't want the browser to also </span><span class="line" data-startTime="697">use that touch to pan the page, scroll the </span><span class="line" data-startTime="700">page, for example. </span> <span class="line" data-startTime="700">So let me show you concretely what that looks </span><span class="line" data-startTime="704">like. </span> <span class="line" data-startTime="704">This is a really simple application that just </span><span class="line" data-startTime="708">registers an event handler on this blue box </span><span class="line" data-startTime="708">here, so you can see if I move my mouse over, </span><span class="line" data-startTime="712">it just lists the events that are fired. </span> <span class="line" data-startTime="712">So if I touch and drag, I get touchstart, </span><span class="line" data-startTime="719">touchmove, and then &mdash; oops &mdash; if I touch </span><span class="line" data-startTime="719">and drag, you can see I get touchmove and </span><span class="line" data-startTime="723">then touchend. </span></p>

<p><span class="line" data-startTime="723">But if I tap on this, you see I get touchstart, </span><span class="line" data-startTime="729">touchend, as you'd expect, but then I also </span><span class="line" data-startTime="729">get this compatibility mouse move &mdash; mousedown, </span><span class="line" data-startTime="733">mouseout click &mdash; sequence that's emulated </span><span class="line" data-startTime="733">in the click. </span> <span class="line" data-startTime="736">So to prevent that, I just go into my event </span><span class="line" data-startTime="736">handler here and say ease out preventDefault, </span><span class="line" data-startTime="741">just say "I've handled the event, please don't </span><span class="line" data-startTime="741">do anything else with it." And now when I </span><span class="line" data-startTime="744">tap I just get the touch events. </span> <span class="line" data-startTime="744">So if you leave here knowing &mdash; remembering </span><span class="line" data-startTime="752">nothing else, this is the most important thing: </span><span class="line" data-startTime="752">Don't make your users suffer just because </span><span class="line" data-startTime="756">they happen to have a touchscreen. </span> <span class="line" data-startTime="756">And now that you all have Pixels, this will </span><span class="line" data-startTime="760">probably become pretty obvious to you. Try </span><span class="line" data-startTime="760">it at your sites. </span> <span class="line" data-startTime="761">Now, you don't have to have a Pixel to test </span><span class="line" data-startTime="761">this out. So those of you watching the extended </span><span class="line" data-startTime="765">or on YouTube that weren't as lucky to get </span><span class="line" data-startTime="765">a Pixel yet, just go to Chrome flags and turn </span><span class="line" data-startTime="771">on enable touch events. </span></p>

<p><span class="line" data-startTime="771">We'd actually like to &mdash; we'd actually like </span><span class="line" data-startTime="774">Chrome to always support touch events and </span><span class="line" data-startTime="774">the only reason we don't today is because </span><span class="line" data-startTime="778">so many Web sites have this bug, but hopefully </span><span class="line" data-startTime="778">at some point in the future we'll make this </span><span class="line" data-startTime="781">the default mode. So you should turn this </span><span class="line" data-startTime="781">on and test your Web sites to make sure the </span><span class="line" data-startTime="784">mouse still works on your Web sites with this </span><span class="line" data-startTime="784">on. </span> <span class="line" data-startTime="788">Another problem we see a lot is there's a </span><span class="line" data-startTime="788">subtle difference in how the events are targeted, </span><span class="line" data-startTime="797">so a lot of people will often in many scenarios </span><span class="line" data-startTime="797">want to delegate to the same code for touch </span><span class="line" data-startTime="801">and mouse, and there's a difference between </span><span class="line" data-startTime="801">the mouse event model and the touch event </span><span class="line" data-startTime="806">model in where the events go. So as you probably </span><span class="line" data-startTime="806">know, with the mouse if I move my mouse cursor </span><span class="line" data-startTime="811">over like this blue rectangle here and press </span><span class="line" data-startTime="811">down and then drag outside the rectangle, </span><span class="line" data-startTime="816">I'll get a mousedown, some mouse moves, and </span><span class="line" data-startTime="816">a mouseout event targeted at the rectangle, </span><span class="line" data-startTime="821">and then &mdash; and then I'll continue receiving </span><span class="line" data-startTime="821">events on whatever the background element </span><span class="line" data-startTime="824">is, the white element in this case. It will </span><span class="line" data-startTime="824">get the mouseover, mousemoves, and mouseup </span><span class="line" data-startTime="827">when I lift. </span></p>

<p><span class="line" data-startTime="827">This isn't the same for touch. For touch, </span><span class="line" data-startTime="832">the events always target the node where the </span><span class="line" data-startTime="832">touch started, as opposed to the node that's </span><span class="line" data-startTime="836">currently under the cursor as for mouse. </span> <span class="line" data-startTime="836">So for touch, if I touch on this blue rectangle </span><span class="line" data-startTime="841">and drag across and lift, the touch old events </span><span class="line" data-startTime="841">are going to go to the rectangle, including </span><span class="line" data-startTime="845">the end. And this make a lot of sense for </span><span class="line" data-startTime="845">common scenarios. I've got a slider that I'm </span><span class="line" data-startTime="849">manipulating with touch. You'd really rather </span><span class="line" data-startTime="849">not have to worry about what happens if the </span><span class="line" data-startTime="852">user's finger falls off the slider slightly </span><span class="line" data-startTime="852">as they're sliding it. It make sense to say </span><span class="line" data-startTime="856">conceptually when the user starts touching </span><span class="line" data-startTime="856">something, they're manipulating that thing </span><span class="line" data-startTime="859">for the duration of their touch. But this </span><span class="line" data-startTime="859">gets tricky if you think about what if &mdash; what </span><span class="line" data-startTime="863">if you have got a container with some elements </span><span class="line" data-startTime="863">inside of it and it's changing over time. </span> <span class="line" data-startTime="868">In particular, what if the element the user </span><span class="line" data-startTime="868">touched on happens to get deleted while the </span><span class="line" data-startTime="873">user's in the middle of their touch. And this </span><span class="line" data-startTime="873">actually happened to me in some code I was </span><span class="line" data-startTime="878">working on, and I was really surprised. I </span><span class="line" data-startTime="878">didn't know what was going on. </span></p>

<p><span class="line" data-startTime="882">What happens is we followed this model. The </span><span class="line" data-startTime="882">events continue to go to the element where </span><span class="line" data-startTime="886">you started touching. Even if that element </span><span class="line" data-startTime="886">is no longer in the DOM, that's where the </span><span class="line" data-startTime="889">events go. They'll bubble up to the point </span><span class="line" data-startTime="889">that there's no ancestor and they'll fall </span><span class="line" data-startTime="891">on the floor. So if you've got an event handler </span><span class="line" data-startTime="891">on the container, you're not going to get </span><span class="line" data-startTime="895">the events once the inner node is removed, </span><span class="line" data-startTime="895">and that will look to your app like a finger </span><span class="line" data-startTime="901">is just stuck down. I've got a demo of that, </span><span class="line" data-startTime="901">so this is a really simple app that just transforms </span><span class="line" data-startTime="908">this rectangle to match with my touch events. </span> <span class="line" data-startTime="908">And this is &mdash; this works fine because it's </span><span class="line" data-startTime="913">just a simple rectangle. But, you know, if </span><span class="line" data-startTime="913">this was a ticker or something with some changing </span><span class="line" data-startTime="918">content inside of it or a list of email or </span><span class="line" data-startTime="918">something, then it would be more complicated. </span> <span class="line" data-startTime="922">So I'm going to simulate that by just adding </span><span class="line" data-startTime="922">this red div every two seconds and then deleting </span><span class="line" data-startTime="927">it and then adding a new one. </span></p>

<p><span class="line" data-startTime="927">So if I happen to start touching on the red </span><span class="line" data-startTime="930">div and drag around, as soon as the red div's </span><span class="line" data-startTime="930">removed from the DOM, it's what's receiving </span><span class="line" data-startTime="936">the events and so the container doesn't know </span><span class="line" data-startTime="936">about the events anymore and it thinks my </span><span class="line" data-startTime="940">finger is stuck down and now my code gets </span><span class="line" data-startTime="940">confused. If I try to touch it again, it's </span><span class="line" data-startTime="944">confused because it missed the end. It never </span><span class="line" data-startTime="944">got an end. You see I got touchstart and I </span><span class="line" data-startTime="948">got another touchstart, which is really confusing </span><span class="line" data-startTime="948">for the code. </span> <span class="line" data-startTime="951">So to fix that, an easy way to fix it is to </span><span class="line" data-startTime="951">just take my event handlers here, my move, </span><span class="line" data-startTime="955">end, and cancel event handlers. Really I don't </span><span class="line" data-startTime="955">want those on the container. In this case, </span><span class="line" data-startTime="960">I want to take them &mdash; instead of putting </span><span class="line" data-startTime="960">them on the container, I can go up here to </span><span class="line" data-startTime="965">my touchstart handler and I'll put the event </span><span class="line" data-startTime="965">handlers instead on whatever the target of </span><span class="line" data-startTime="970">the touchstart was. </span></p>

<p><span class="line" data-startTime="970">So in this case, it's going to be &mdash; if I </span><span class="line" data-startTime="975">started touching on the red element, it's </span><span class="line" data-startTime="975">going to be on the red element. </span> <span class="line" data-startTime="977">Now, in theory you might also want to go and </span><span class="line" data-startTime="977">remove these event handlers and the end event </span><span class="line" data-startTime="981">but actually it's not necessary because adding </span><span class="line" data-startTime="981">the same event handler more than once is a </span><span class="line" data-startTime="985">"no op." So there's no disadvantage here to </span><span class="line" data-startTime="985">just adding them and leaving them there. So </span><span class="line" data-startTime="988">now you can see if I start touching this red </span><span class="line" data-startTime="988">guy, now it's removed from the DOM. It doesn't </span><span class="line" data-startTime="992">really exist anywhere except it's being kept </span><span class="line" data-startTime="992">alive by the events that are being sent to </span><span class="line" data-startTime="997">it, and so the JavaScript code can still be </span><span class="line" data-startTime="997">fired and see those events even though the </span><span class="line" data-startTime="1000">node is not reachable in the DOM anywhere. </span></p>

<p><span class="line" data-startTime="1000">So that's how to fix that one. </span> <span class="line" data-startTime="1010">Just like that. </span> <span class="line" data-startTime="1010">Another common problem is dealing with small </span><span class="line" data-startTime="1015">targets. Lots of the web is designed for a </span><span class="line" data-startTime="1015">mouse today, so the browser's got to do something </span><span class="line" data-startTime="1019">to make it easier for touchscreen users to </span><span class="line" data-startTime="1019">hit small things. </span> <span class="line" data-startTime="1023">If we just relied on looking at the center </span><span class="line" data-startTime="1023">point of your finger, it would be way too </span><span class="line" data-startTime="1027">small. As Boris said, you know, you ideally </span><span class="line" data-startTime="1027">have larger targets. But if it's a site that's </span><span class="line" data-startTime="1032">designed for a mouse or if you want to try </span><span class="line" data-startTime="1032">to strike some compromise on your site where </span><span class="line" data-startTime="1035">you don't want things to be giant, then the </span><span class="line" data-startTime="1035">browser's got to do something to make it easier </span><span class="line" data-startTime="1039">for people to touch large &mdash; touch small targets. </span> <span class="line" data-startTime="1039">So what Chrome does, it's got a feature called </span><span class="line" data-startTime="1043">touch adjustment, and what it does, the green </span><span class="line" data-startTime="1043">rectangle here represents the bounding box </span><span class="line" data-startTime="1048">of my touch. You know, using the radius from </span><span class="line" data-startTime="1048">the hardware on Pixel, we know the radius </span><span class="line" data-startTime="1053">of the touch, but if we don't know the radius </span><span class="line" data-startTime="1053">on other hardware, we can use a suitable default. </span></p>

<p><span class="line" data-startTime="1057">And then we look at all of the elements inside </span><span class="line" data-startTime="1057">that bounding box and we look at &mdash; we'd find </span><span class="line" data-startTime="1061">every one that has some signal that it's activatable </span><span class="line" data-startTime="1061">by tapping somehow. So it's got a click event </span><span class="line" data-startTime="1066">handler or it's got an active CSS pseudo-class. </span> <span class="line" data-startTime="1066">Anything that we expect something will happen </span><span class="line" data-startTime="1071">when it's tapped. And we score those based </span><span class="line" data-startTime="1071">on how far away the edge of that element is </span><span class="line" data-startTime="1078">from the center of the touch and how much </span><span class="line" data-startTime="1078">of that element gets overlapped by the touch. </span> <span class="line" data-startTime="1082">And we pick the one with the highest score </span><span class="line" data-startTime="1082">and then we adjust the touch. We don't change </span><span class="line" data-startTime="1086">the raw touch events. Touch events are a low-level </span><span class="line" data-startTime="1086">API. We don't want to muck with those. But </span><span class="line" data-startTime="1090">for the compatibility of most events, we'll </span><span class="line" data-startTime="1090">shift them. We'll change what element is targeted </span><span class="line" data-startTime="1094">and we'll change the coordinates so that it </span><span class="line" data-startTime="1094">actually gets delivered to what we think the </span><span class="line" data-startTime="1099">user is trying to touch. Let me show you that </span><span class="line" data-startTime="1099">in a demo. </span> <span class="line" data-startTime="1103">Oh, pro tip, by the way, for all of you with </span><span class="line" data-startTime="1103">your new Pixels. Control shift plus. We haven't </span><span class="line" data-startTime="1107">put in the UI yet but we have a nice UI restore </span><span class="line" data-startTime="1107">feature. You can zoom in and out the whole </span><span class="line" data-startTime="1111">Chrome OS UI. So I'm going to do that for </span><span class="line" data-startTime="1111">this demo and show you &mdash; well, let me just </span><span class="line" data-startTime="1117">show &mdash; if I just tap here, I've got the rectangle </span><span class="line" data-startTime="1117">showing where my tap was, and the blue shows </span><span class="line" data-startTime="1121">where the click event went, and in this case, </span><span class="line" data-startTime="1121">there's nothing touchable underneath so there's </span><span class="line" data-startTime="1126">nothing unusual here. </span></p>

<p><span class="line" data-startTime="1126">And if I tap on top of a link, again, there's </span><span class="line" data-startTime="1131">nothing really unusual. </span> <span class="line" data-startTime="1131">But if I tap on the boundary of a link like </span><span class="line" data-startTime="1133">this, you can see my touchend event, which </span><span class="line" data-startTime="1133">is the red dot, occurred on the "x" and "t" </span><span class="line" data-startTime="1139">in the word "text" here and down in the log </span><span class="line" data-startTime="1139">you can see the touchend event occurred on </span><span class="line" data-startTime="1143">this ID called "content," which is the text </span><span class="line" data-startTime="1143">content. </span> <span class="line" data-startTime="1147">But I overlapped the link and so the browser </span><span class="line" data-startTime="1147">sees that overlap and it adjusts the click </span><span class="line" data-startTime="1152">event, so that the click is actually going </span><span class="line" data-startTime="1152">to the link, which is the blue dot next to </span><span class="line" data-startTime="1155">it. And there's also two different signals </span><span class="line" data-startTime="1155">that we use so, you know, the link is the </span><span class="line" data-startTime="1158">obvious one but anything with a hover effect, </span><span class="line" data-startTime="1158">like right here, this text turns red when </span><span class="line" data-startTime="1163">you hover on top of it, so you can see I'm </span><span class="line" data-startTime="1163">adjusting down towards it. </span> <span class="line" data-startTime="1167">Or something with a tab index, right? A tab </span><span class="line" data-startTime="1167">index indicates that you can focus it by tapping </span><span class="line" data-startTime="1172">&mdash; by clicking on it or activating it. Or </span><span class="line" data-startTime="1172">even just a mousedown event handler because </span><span class="line" data-startTime="1176">we fired those on tap as well. These are all </span><span class="line" data-startTime="1176">signals to tell us that something is touchable. </span> <span class="line" data-startTime="1180">And so this works great most of the time, </span><span class="line" data-startTime="1180">but it is possible to confuse it. </span> <span class="line" data-startTime="1186">In particular, we need some signal that &mdash; that </span><span class="line" data-startTime="1186">what you've got is designed to be activated </span><span class="line" data-startTime="1190">somehow, and if you're relying on event delegation, </span><span class="line" data-startTime="1190">so for example, you've got an event handler </span><span class="line" data-startTime="1196">on your entire document and then in JavaScript </span><span class="line" data-startTime="1196">you're deciding, oh, this event actually really </span><span class="line" data-startTime="1201">was on this element and I'm imperatively in </span><span class="line" data-startTime="1201">JavaScript going to rewrite the event to the </span><span class="line" data-startTime="1205">right element, that gives the browsers no </span><span class="line" data-startTime="1205">real signal of &mdash; of where &mdash; what is touchable </span><span class="line" data-startTime="1210">and what isn't. </span></p>

<p><span class="line" data-startTime="1210">Not only is that going to disable touch adjustment, </span><span class="line" data-startTime="1215">but if there's other signals like hover effect </span><span class="line" data-startTime="1215">and active effects, it might actually make </span><span class="line" data-startTime="1219">touch adjustment behave worse than not having </span><span class="line" data-startTime="1219">it at all. </span> <span class="line" data-startTime="1222">My favorite example of this is Gmail, unfortunately. </span> <span class="line" data-startTime="1222">And we will get this fixed at some point soon. </span> <span class="line" data-startTime="1226">Oops. Let me go back here. </span> <span class="line" data-startTime="1226">So I can tap these stars and activate them, </span><span class="line" data-startTime="1232">no problem. And that's because the star in </span><span class="line" data-startTime="1232">its unactive state has a hover effect that </span><span class="line" data-startTime="1237">makes it look slightly different when you </span><span class="line" data-startTime="1237">hover over it. So it looks tappable to us. </span> <span class="line" data-startTime="1242">Every time I touch near it, it will adjust </span><span class="line" data-startTime="1242">towards it. If I try to tap to turn off the </span><span class="line" data-startTime="1245">star, it is incredibly frustrating. I just </span><span class="line" data-startTime="1245">keep hitting the things next to it. That's </span><span class="line" data-startTime="1250">because these other things on either side </span><span class="line" data-startTime="1250">of it appear to us to be tappable, but there </span><span class="line" data-startTime="1254">is no longer any signal on the star telling </span><span class="line" data-startTime="1254">us that it is tappable. </span></p>

<p><span class="line" data-startTime="1258">Gmail is using event delegations, so there </span><span class="line" data-startTime="1258">is no event handler on it and there is no </span><span class="line" data-startTime="1261">longer a hover effect or anything to tell </span><span class="line" data-startTime="1261">us it is random background content. </span> <span class="line" data-startTime="1265">And so we don't think it is something the </span><span class="line" data-startTime="1265">user is trying to touch. </span> <span class="line" data-startTime="1273">Another question I get a lot is how should </span><span class="line" data-startTime="1273">you recognize more complex gestures like pinch </span><span class="line" data-startTime="1277">or rotate. Mobile Safari has a proprietary </span><span class="line" data-startTime="1277">API for this called gestureevent. And IE10 </span><span class="line" data-startTime="1283">has a proprietary API for this called MSGestureevent. </span> <span class="line" data-startTime="1283">So in Chrome, we are not going to add another </span><span class="line" data-startTime="1290">proprietary gesture API. We think proprietary </span><span class="line" data-startTime="1290">APIs are bad for the Web. We would love to </span><span class="line" data-startTime="1294">have a standardized API that works across </span><span class="line" data-startTime="1294">all browsers. </span> <span class="line" data-startTime="1296">[ Applause ] </span><span class="line" data-startTime="1296">That's the first time I got a applause for </span><span class="line" data-startTime="1301">not doing a feature. I love it. </span></p>

<p><span class="line" data-startTime="1301">We love to have a standard API that all browsers </span><span class="line" data-startTime="1307">can implement. But for various reasons, that's </span><span class="line" data-startTime="1307">not going to happen any time soon. </span> <span class="line" data-startTime="1312">So &mdash; but the good news is, you actually don't </span><span class="line" data-startTime="1312">need the browser to do this for you. This </span><span class="line" data-startTime="1316">is something that can be done perfectly well </span><span class="line" data-startTime="1316">by libraries, built on top of the touch events. </span> <span class="line" data-startTime="1319">There is a wide variety of different libraries. </span> <span class="line" data-startTime="1319">And then you can use one of these libraries </span><span class="line" data-startTime="1323">and have it work across all these browsers, </span><span class="line" data-startTime="1323">not have to worry about the differences in </span><span class="line" data-startTime="1326">the browsers. </span> <span class="line" data-startTime="1326">So I wrote a little demo here using hammer.js </span><span class="line" data-startTime="1330">which exposes a whole slew of different types </span><span class="line" data-startTime="1330">of gestures. But the transform gesture in </span><span class="line" data-startTime="1334">particular recognizes pinch and rotate. Let </span><span class="line" data-startTime="1334">me just show you what this looks like. </span> <span class="line" data-startTime="1339">So with a very small amount of code, I can </span><span class="line" data-startTime="1339">handle moving this box around, pinching it </span><span class="line" data-startTime="1344">to zoom it, and rotating it. I haven't had </span><span class="line" data-startTime="1344">to listen to touch events at all. I have just </span><span class="line" data-startTime="1349">done this and listened for transformer events </span><span class="line" data-startTime="1349">and imported the hammer library. </span> <span class="line" data-startTime="1352">So if you want to do it with gestures, I encourage </span><span class="line" data-startTime="1352">you to explore these libraries and contribute </span><span class="line" data-startTime="1356">to them. Most of them I believe are open source </span><span class="line" data-startTime="1356">projects. Much better than a proprietary browser </span><span class="line" data-startTime="1361">API in my opinion. </span></p>

<p><span class="line" data-startTime="1361">And now back to Boris to talk about performance. </span></p>

<p class="speaker"><span class="line" data-starttime="1369"><span class="speakerName">Boris Smus</span>: All right. So, one performance </span><span class="line" data-startTime="1369">issue you may have seen are heard of is this </span><span class="line" data-startTime="1376">infamous click delay. So the idea here is </span><span class="line" data-startTime="1376">the clicks on mobile browsers are generally </span><span class="line" data-startTime="1382">delayed by something like 300 milliseconds </span><span class="line" data-startTime="1382">because the browser needs to decide if your </span><span class="line" data-startTime="1386">click was a genuine click or if it was actually </span><span class="line" data-startTime="1386">a double tap. So there is this gesture where </span><span class="line" data-startTime="1391">you want to zoom into some content that's </span><span class="line" data-startTime="1391">very small and you double tapped that and </span><span class="line" data-startTime="1395">the browser zooms in. And so This behavior </span><span class="line" data-startTime="1395">can cause pages to feel very slow and unresponsive. </span> <span class="line" data-startTime="1402">And if you have been working in this space, </span><span class="line" data-startTime="1402">you have probably heard of fastclick as a </span><span class="line" data-startTime="1405">solution for this. What fastclick basically </span><span class="line" data-startTime="1405">does is instead of using click, it uses just </span><span class="line" data-startTime="1410">the touchend event, which is something we </span><span class="line" data-startTime="1410">described earlier. </span> <span class="line" data-startTime="1414">So, of course, you know now that there's some </span><span class="line" data-startTime="1414">drawbacks to using touchend versus click such </span><span class="line" data-startTime="1419">as the touchfuzzing that Rick described earlier. </span> <span class="line" data-startTime="1419">And you lose that if you use a fastclick library. </span> <span class="line" data-startTime="1427">In cases where we don't need a fastclick library, </span><span class="line" data-startTime="1427">we should avoid it. </span></p>

<p><span class="line" data-startTime="1431">A couple things also changed over the last </span><span class="line" data-startTime="1431">year or os in Chrome. Firstly, Chrome desktop, </span><span class="line" data-startTime="1437">which has touch support in some cases, like </span><span class="line" data-startTime="1437">in this Pixel or on Windows devices, there's </span><span class="line" data-startTime="1443">no click delay because we don't actually support </span><span class="line" data-startTime="1443">the double tap to zoom gesture. </span></p>

<p class="speaker"><span class="line" data-starttime="1447"><span class="speakerName">Rick Byers</span>: That's another feature, by the </span><span class="line" data-startTime="1447">way, we are never going to support because </span><span class="line" data-startTime="1450">we are not going to add 300 milliseconds to </span><span class="line" data-startTime="1450">the click events. </span></p>

<p class="speaker"><span class="line" data-starttime="1451"><span class="speakerName">Boris Smus</span>: Excellent. </span></p>

<p class="speaker"><span class="line" data-starttime="1451"><span class="speakerName">Rick Byers</span>: If I have anything to say about </span><span class="line" data-startTime="1455">it. Sorry. </span></p>

<p class="speaker"><span class="line" data-starttime="1455"><span class="speakerName">Boris Smus</span>: In Chrome for Android, we have </span><span class="line" data-startTime="1457">an optimization that landed over the last </span><span class="line" data-startTime="1457">year that doesn't create a click delay in </span><span class="line" data-startTime="1464">the case of a fixed viewport. So you can fix </span><span class="line" data-startTime="1464">your viewport with user scalable equals no. </span> <span class="line" data-startTime="1469">And in that case, again, the double tap gesture </span><span class="line" data-startTime="1469">doesn't exist. So there is no need for us </span><span class="line" data-startTime="1472">to delay. </span> <span class="line" data-startTime="1472">So it is important that the fastclick library </span><span class="line" data-startTime="1476">that you use is aware of these changes. Otherwise, </span><span class="line" data-startTime="1476">you lose the benefits. So we worked with FT </span><span class="line" data-startTime="1480">Labs, which support one of the most popular </span><span class="line" data-startTime="1480">fastclick libraries. And they've patched their </span><span class="line" data-startTime="1485">code to make sure that their library is smart </span><span class="line" data-startTime="1485">about this. </span> <span class="line" data-startTime="1490">So keep that in mind next time you're using </span><span class="line" data-startTime="1490">a fastclick approach. </span> <span class="line" data-startTime="1496">Okay. Another performance issue, you may have </span><span class="line" data-startTime="1496">written or seen code that looks like this. </span> <span class="line" data-startTime="1504">So this code essentially just renders every </span><span class="line" data-startTime="1504">time you get a touchmove event. The problem </span><span class="line" data-startTime="1510">with this is that touchmove can fire very </span><span class="line" data-startTime="1510">quickly. Often it fires much faster than your </span><span class="line" data-startTime="1516">render loop, which is 60 hertz if you're getting </span><span class="line" data-startTime="1516">a smooth performance &mdash; smooth visual display. </span> <span class="line" data-startTime="1525">In some browsers, this problem is mitigated </span><span class="line" data-startTime="1525">by coalescing multiple touch events into one. </span></p>

<p><span class="line" data-startTime="1532">So there's touch arrays that come with every </span><span class="line" data-startTime="1532">touch event. And it is up to the browser, </span><span class="line" data-startTime="1537">basically, to decide if it should put all </span><span class="line" data-startTime="1537">the events together or if it should create </span><span class="line" data-startTime="1541">separate touchmove events. </span> <span class="line" data-startTime="1541">So let me just quickly show you here on a </span><span class="line" data-startTime="1547">mobile device the possible issue. So here </span><span class="line" data-startTime="1547">I've got some code that basically does this </span><span class="line" data-startTime="1556">naive approach where it renders everything </span><span class="line" data-startTime="1556">on touch. You can see I have got one finger. </span> <span class="line" data-startTime="1560">I'm just drawing the point and that works </span><span class="line" data-startTime="1560">really well. I can add a second finger and </span><span class="line" data-startTime="1565">a third finger. You can sort of see the slowdown </span><span class="line" data-startTime="1565">now. But as I add the fourth finger, things </span><span class="line" data-startTime="1572">really degrade. </span></p>

<p></p>

<p class="speaker"><span class="line" data-starttime="1572"><span class="speakerName">Audience member</span>: Ahhh. </span></p>

<p class="speaker"><span class="line" data-starttime="1574"><span class="speakerName">Boris Smus</span>: So this is not what we want. </span> <span class="line" data-startTime="1574">[ Laughter ] </span><span class="line" data-startTime="1578">So touch events are piling up and, basically, </span><span class="line" data-startTime="1578">we're not able to render quickly enough and </span><span class="line" data-startTime="1584">there is a big backlog of touches which is </span><span class="line" data-startTime="1584">why you see this delay. </span> <span class="line" data-startTime="1589">So the solution to this is to avoid expense </span><span class="line" data-startTime="1589">operations in your touch handlers. In general, </span><span class="line" data-startTime="1599">this is good practice. But this is especially </span><span class="line" data-startTime="1599">important for touch. </span> <span class="line" data-startTime="1603">So rather than rendering, you can store the </span><span class="line" data-startTime="1603">touches and then set up a separate animation </span><span class="line" data-startTime="1607">loop with something like requestAnimationframe </span><span class="line" data-startTime="1607">which makes sure that every single render </span><span class="line" data-startTime="1612">is tied to the vsync of your display. </span> <span class="line" data-startTime="1612">Just by doing this small optimization, let </span><span class="line" data-startTime="1618">me show you the difference. So I will switch </span><span class="line" data-startTime="1618">to the requestAnimationframe version. There </span><span class="line" data-startTime="1625">we go. And you can see that same four-finger </span><span class="line" data-startTime="1625">gesture is now extremely responsive just with </span><span class="line" data-startTime="1634">that one small change. </span></p>

<p><span class="line" data-startTime="1634">Okay. Another performance issue is related </span><span class="line" data-startTime="1643">to scroll jank. So in case you are not familiar </span><span class="line" data-startTime="1643">with scroll jank, the basic idea is sometimes </span><span class="line" data-startTime="1649">scrolling can be very uneven and just not </span><span class="line" data-startTime="1649">be very responsive to your actual input. This </span><span class="line" data-startTime="1656">can come in many forms. </span> <span class="line" data-startTime="1656">But we've done some studies, and it's very </span><span class="line" data-startTime="1661">important for engagement. So if your users </span><span class="line" data-startTime="1661">are dealing with a janky site, it's likely </span><span class="line" data-startTime="1665">that they won't come back. </span> <span class="line" data-startTime="1665">And Chrome team has spent a lot of effort </span><span class="line" data-startTime="1670">of trying to optimize this scrolling. And </span><span class="line" data-startTime="1670">the big push has been to move scrolling to </span><span class="line" data-startTime="1675">a separate hardware-accelerated GPU thread. </span> <span class="line" data-startTime="1675">Event handling, though, is still, of course, </span><span class="line" data-startTime="1680">on the main thread. </span></p>

<p><span class="line" data-startTime="1680">So there's something that can happen if you </span><span class="line" data-startTime="1684">have fairly busy main thread because every </span><span class="line" data-startTime="1684">time you scroll, as Rick pointed out earlier, </span><span class="line" data-startTime="1691">you can prevent the default behavior of the </span><span class="line" data-startTime="1691">scroll. And the way we do that is in JavaScript </span><span class="line" data-startTime="1696">by using event prevent default. </span> <span class="line" data-startTime="1696">What happens is every time you scroll, we </span><span class="line" data-startTime="1700">need to call back &mdash; well, Chrome calls back </span><span class="line" data-startTime="1700">into the main thread to see if it is allowed </span><span class="line" data-startTime="1706">to. And if the main thread is really busy, </span><span class="line" data-startTime="1706">that causes the GPU thread to wait. So here's </span><span class="line" data-startTime="1712">how this looks. I have got an artificially </span><span class="line" data-startTime="1712">busy main thread in this page. And I have </span><span class="line" data-startTime="1719">also enabled an empty touchmove handler. So </span><span class="line" data-startTime="1719">it just it looks like this. It is a no op. </span> <span class="line" data-startTime="1726">And if you see me scrolling here, my finger </span><span class="line" data-startTime="1726">is moving smoothly, it's very janky. So by </span><span class="line" data-startTime="1735">simply turning this off, I have a very different </span><span class="line" data-startTime="1735">experience. And that's a no op touch handler. </span> <span class="line" data-startTime="1743">So what's the story here? </span><span class="line" data-startTime="1743">How can we avoid this? Well, first, and quite </span><span class="line" data-startTime="1750">obviously, we can just not use that touch </span><span class="line" data-startTime="1750">event handler. If it is unnecessary, there's </span><span class="line" data-startTime="1756">no need for you to put it there and you will </span><span class="line" data-startTime="1756">save &mdash; you will save yourself from seeing </span><span class="line" data-startTime="1759">this issue at all. </span></p>

<p><span class="line" data-startTime="1759">And, of course, remember that in some cases, </span><span class="line" data-startTime="1765">it's not so bad to have &mdash; to rely on synthesized </span><span class="line" data-startTime="1765">DOM events like click, scroll, and context </span><span class="line" data-startTime="1770">menu which all fire on touch devices. </span> <span class="line" data-startTime="1770">So, basically, what I'm saying is, you don't </span><span class="line" data-startTime="1775">need to implement touch-specific event handlers </span><span class="line" data-startTime="1775">necessarily to have a good experience on touchscreens. </span> <span class="line" data-startTime="1783">And another approach to solving this problem </span><span class="line" data-startTime="1783">is if you definitely do need a touch handler, </span><span class="line" data-startTime="1788">make sure you've contained that touch region </span><span class="line" data-startTime="1788">to be as small as possible. </span> <span class="line" data-startTime="1792">So Chrome has optimizations that says if the </span><span class="line" data-startTime="1792">part of the page that the user is scrolling </span><span class="line" data-startTime="1799">doesn't have a touch handler, then there is </span><span class="line" data-startTime="1799">no need for us to call back to the main thread. </span> <span class="line" data-startTime="1803">And we can just do the thing very quickly. </span></p>

<p><span class="line" data-startTime="1803">So, essentially, if you think of your page </span><span class="line" data-startTime="1808">&mdash; if you think of subdividing your page into </span><span class="line" data-startTime="1808">regions, you can decide whether or not you </span><span class="line" data-startTime="1813">want to optimize for smooth scrolling or for </span><span class="line" data-startTime="1813">touch event handling. </span> <span class="line" data-startTime="1818">So this example that I showed you earlier </span><span class="line" data-startTime="1818">is the worst case where you've got a touch </span><span class="line" data-startTime="1824">handler on your whole body for not good reason. </span> <span class="line" data-startTime="1824">Okay. Back to Rick. </span></p>

<p class="speaker"><span class="line" data-starttime="1832"><span class="speakerName">Rick Byers</span>: So we told you a bit about the </span><span class="line" data-startTime="1832">state of touch on the Web today. </span> <span class="line" data-startTime="1837">I want to touch briefly on some of the directions </span><span class="line" data-startTime="1837">that we want to head going forward. </span> <span class="line" data-startTime="1842">So, first of all, here's just a rough idea </span><span class="line" data-startTime="1842">of some of the goals that we've got. First </span><span class="line" data-startTime="1847">of all, as we talked before, touch events </span><span class="line" data-startTime="1847">are pretty low-level API. And a lot of times </span><span class="line" data-startTime="1851">you want to express your intent in a higher-level </span><span class="line" data-startTime="1851">fashion. So we would like to do more to eliminate </span><span class="line" data-startTime="1855">the need for you to drop down to this low-level </span><span class="line" data-startTime="1855">API. </span> <span class="line" data-startTime="1858">For example, a really common scenario is to </span><span class="line" data-startTime="1858">want to support dragging things around, right, </span><span class="line" data-startTime="1863">drag and drop-type UIs. There is actually </span><span class="line" data-startTime="1863">a high-level drag and drop API for the Web </span><span class="line" data-startTime="1868">today. Unfortunately, it is only implemented </span><span class="line" data-startTime="1868">from mouse. Every browser that's drag and </span><span class="line" data-startTime="1872">drop only does it with mouse input, which </span><span class="line" data-startTime="1872">seems a real shame. So we are starting to </span><span class="line" data-startTime="1876">experiment with this in Chrome OS. You can </span><span class="line" data-startTime="1876">try it on your Pixel. You can turn it on in </span><span class="line" data-startTime="1879">"about" flags. It is touch-based drag and </span><span class="line" data-startTime="1879">drop. Long press will initiate a drag and </span><span class="line" data-startTime="1883">drop. And we are hoping we will get that on </span><span class="line" data-startTime="1883">by default in M29, which is coming up in a </span><span class="line" data-startTime="1888">little bit. </span> <span class="line" data-startTime="1888">And then once we're happy with it there, we </span><span class="line" data-startTime="1892">will turn it on in the other platforms as </span><span class="line" data-startTime="1892">well, Android and Windows. </span></p>

<p><span class="line" data-startTime="1897">We also want to give you more control over </span><span class="line" data-startTime="1897">the browser's default behavior so you don't </span><span class="line" data-startTime="1900">have to fall back to touch events. A really </span><span class="line" data-startTime="1900">common scenario with touch events is an image </span><span class="line" data-startTime="1904">carousel where you want to support swiping </span><span class="line" data-startTime="1904">between the different images. </span> <span class="line" data-startTime="1907">And really that's just a scrollable div except </span><span class="line" data-startTime="1907">that you really want to snap where it stops </span><span class="line" data-startTime="1912">to image boundaries. And so what people end </span><span class="line" data-startTime="1912">up doing is they use a library or they write </span><span class="line" data-startTime="1916">custom code to listen for touch events and </span><span class="line" data-startTime="1916">then they have to implement all the scrolling </span><span class="line" data-startTime="1920">themselves, which doesn't sound that bad until </span><span class="line" data-startTime="1920">you realize that there is a certain physics </span><span class="line" data-startTime="1924">that people are used to and they are used </span><span class="line" data-startTime="1924">to a certain momentum when you fling and then </span><span class="line" data-startTime="1927">trying to match that to the browser's behavior </span><span class="line" data-startTime="1927">which is changing in between browsers is very </span><span class="line" data-startTime="1932">hard. And then this whole &mdash; all the work </span><span class="line" data-startTime="1932">we do to try to do to scroll on a GPU thread </span><span class="line" data-startTime="1935">so we're not subject to jank for the main </span><span class="line" data-startTime="1935">thread, all that goes out the window when </span><span class="line" data-startTime="1938">you implement scrolling in JavaScript. </span> <span class="line" data-startTime="1938">So we love for common scrolling scenarios </span><span class="line" data-startTime="1942">like that. We would like to just give you </span><span class="line" data-startTime="1942">features that let you customize the behavior </span><span class="line" data-startTime="1946">like add snap points. IE10 has a feature for </span><span class="line" data-startTime="1946">this, so we are talking with Microsoft about </span><span class="line" data-startTime="1951">how we can standardize that and bring it to </span><span class="line" data-startTime="1951">the standard Web. </span></p>

<p><span class="line" data-startTime="1955">And we're working with other browser vendors </span><span class="line" data-startTime="1955">to bring new Web standards to help with touch </span><span class="line" data-startTime="1960">as well. So, in particular, IE10 has a number </span><span class="line" data-startTime="1960">of touch features that are pretty nice. So </span><span class="line" data-startTime="1967">we're talking with Microsoft about those. </span> <span class="line" data-startTime="1967">In particular, pointer events is a new input </span><span class="line" data-startTime="1971">model in IE10. IE10 doesn't support the touch </span><span class="line" data-startTime="1971">event model that we have been talking throughout </span><span class="line" data-startTime="1975">this slide for. They have got a different </span><span class="line" data-startTime="1975">input model called pointer events. </span> <span class="line" data-startTime="1978">It has some design properties that we are </span><span class="line" data-startTime="1978">pretty excited about. First of all, it abstracts </span><span class="line" data-startTime="1984">different types of input. You still need to </span><span class="line" data-startTime="1984">think to think about touch and mouse separately </span><span class="line" data-startTime="1988">when you are designing your site. Sometimes </span><span class="line" data-startTime="1988">the right thing to do is to handle them the </span><span class="line" data-startTime="1990">same. If the right thing to do is to handle </span><span class="line" data-startTime="1990">touch and mouse the same, you should be able </span><span class="line" data-startTime="1994">to use the same code to do it. This model </span><span class="line" data-startTime="1994">extends the mouse even model, which means </span><span class="line" data-startTime="1999">if you have already got a big investment in </span><span class="line" data-startTime="1999">code that's designed for the mouse model, </span><span class="line" data-startTime="2002">you can &mdash; rather than having to worry about </span><span class="line" data-startTime="2002">things like the difference in targeting model </span><span class="line" data-startTime="2006">and the lack of over-and-out events, you can </span><span class="line" data-startTime="2006">update that code to work with point events </span><span class="line" data-startTime="2009">very easily. </span></p>

<p><span class="line" data-startTime="2009">We would love to see more discussion on pointer </span><span class="line" data-startTime="2013">events. This is the mailing list for the standards </span><span class="line" data-startTime="2013">group. Love to hear discussion there. </span> <span class="line" data-startTime="2017">The implementation, obviously, IE has implementation </span><span class="line" data-startTime="2017">and Firefox has said they have started to </span><span class="line" data-startTime="2021">work on an implementation. Microsoft built </span><span class="line" data-startTime="2021">a prototype for Chrome, which is great. And </span><span class="line" data-startTime="2026">now we have just announced that we're going </span><span class="line" data-startTime="2026">to start landing some experimental support </span><span class="line" data-startTime="2030">in Blink for pointer events. </span> <span class="line" data-startTime="2030">But adding a new input model isn't something </span><span class="line" data-startTime="2035">we take lightly especially when it is redundant </span><span class="line" data-startTime="2035">with existing models and not necessarily something </span><span class="line" data-startTime="2040">that browser vendors are going to embrace. </span></p>

<p><span class="line" data-startTime="2040">We are starting by adding some features that </span><span class="line" data-startTime="2046">are going to make it easy to build high-performance, </span><span class="line" data-startTime="2046">high-quality polyfills for pointer events. </span> <span class="line" data-startTime="2050">And then we really want to get feedback from </span><span class="line" data-startTime="2050">you guys. We want to see if you vote with </span><span class="line" data-startTime="2053">your feet by using the polyfills and send </span><span class="line" data-startTime="2053">us signals that you really want this model </span><span class="line" data-startTime="2058">natively in the browser, then we will add </span><span class="line" data-startTime="2058">it to Chrome. </span> <span class="line" data-startTime="2061">So today there is a few early polyfills. None </span><span class="line" data-startTime="2061">of them are perfect, Butt hey are all pretty </span><span class="line" data-startTime="2065">good and a good way to get a handle on how </span><span class="line" data-startTime="2065">pointer events work. </span> <span class="line" data-startTime="2069">If you went to the Web components talk earlier, </span><span class="line" data-startTime="2069">the application of Web components, the polymer </span><span class="line" data-startTime="2075">framework, they decided that pointer events </span><span class="line" data-startTime="2075">was the right input model for polymer. So </span><span class="line" data-startTime="2079">they built a polyfill that emulates pointer </span><span class="line" data-startTime="2079">events that you can use completely independently. </span> <span class="line" data-startTime="2086">So please check those out and send us feedback. </span></p>

<p><span class="line" data-startTime="2086">I will not go into full details of the pointer </span><span class="line" data-startTime="2091">events API. Microsoft has a bunch of good </span><span class="line" data-startTime="2091">links. There's lots of full talks on their </span><span class="line" data-startTime="2095">own. I want to touch on two things I'm particularly </span><span class="line" data-startTime="2095">excited about. First of all, I said that you </span><span class="line" data-startTime="2099">can &mdash; they let you specify declaratively </span><span class="line" data-startTime="2099">what to do with touch. And this is done through </span><span class="line" data-startTime="2104">a CSS property called touch action. </span> <span class="line" data-startTime="2104">When you say touch action none, it means you </span><span class="line" data-startTime="2107">don't want the browser to take a default action </span><span class="line" data-startTime="2107">on touch, like scrolling. And instead you </span><span class="line" data-startTime="2111">just want to deliver events. Where if you </span><span class="line" data-startTime="2111">say touch action auto, then that means you </span><span class="line" data-startTime="2115">want the browser to determine what to do. </span> <span class="line" data-startTime="2115">So, for example, as soon as you start scrolling, </span><span class="line" data-startTime="2118">the browser says I'm supposed to scroll now </span><span class="line" data-startTime="2118">and it can start scrolling immediately and </span><span class="line" data-startTime="2121">just send a cancel event to JavaScript to </span><span class="line" data-startTime="2121">say you will not get any more events now that </span><span class="line" data-startTime="2124">these started scrolling. And it doesn't have </span><span class="line" data-startTime="2124">to block on the main thread. So that scroll </span><span class="line" data-startTime="2128">jank problem that Boris showed which can be </span><span class="line" data-startTime="2128">a real problem especially on mobile devices </span><span class="line" data-startTime="2133">just goes away completely with this. </span></p>

<p><span class="line" data-startTime="2133">I also said that this can be better for code </span><span class="line" data-startTime="2139">sharing. We want to enable you to build sites </span><span class="line" data-startTime="2139">that work well across a range of devices. </span> <span class="line" data-startTime="2144">And so let me show you an example here. This </span><span class="line" data-startTime="2144">is a really simple demo of &mdash; this is a really </span><span class="line" data-startTime="2152">simple demo of drag and drop that's kind of </span><span class="line" data-startTime="2152">modeled after the Google+ circle editor. </span> <span class="line" data-startTime="2156">The idea is I can touch on a card and drag </span><span class="line" data-startTime="2156">it &mdash; let me get all three of the circles </span><span class="line" data-startTime="2161">&mdash; touch on a card and drag it to one of these </span><span class="line" data-startTime="2161">circles. This is designed to work with multiple </span><span class="line" data-startTime="2166">inputs. I can touch two cards at once, or </span><span class="line" data-startTime="2166">I can even use a mouse and touchscreen at </span><span class="line" data-startTime="2170">once to drag things around. </span> <span class="line" data-startTime="2170">And so let me show you what was involved to </span><span class="line" data-startTime="2175">make this work. There's a bit of code here. </span></p>

<p><span class="line" data-startTime="2175">I won't go through all of it. The move handlers </span><span class="line" data-startTime="2179">perhaps is the most interesting. When the </span><span class="line" data-startTime="2179">mouse moves, I just have a little bit of work </span><span class="line" data-startTime="2185">to do really and then I delegate to this common </span><span class="line" data-startTime="2185">move function. </span> <span class="line" data-startTime="2187">But when I get a touchmove event, I am going </span><span class="line" data-startTime="2187">to delegate to the common move function. But </span><span class="line" data-startTime="2192">then I have got to do a lot of other stuff </span><span class="line" data-startTime="2192">to compensate for the difference in targeting </span><span class="line" data-startTime="2195">model. </span> <span class="line" data-startTime="2195">This is all specific to the touchmodel. </span> <span class="line" data-startTime="2199">And then the common function for handling </span><span class="line" data-startTime="2199">movements is, like, a couple of lines. It </span><span class="line" data-startTime="2202">is unfortunate, this is the only thing I can </span><span class="line" data-startTime="2202">do in common. The start and end events are </span><span class="line" data-startTime="2206">like that as well. It is a pretty small amount </span><span class="line" data-startTime="2206">of common code for the two cases. </span> <span class="line" data-startTime="2210">If I use pointer events, I can get the amount </span><span class="line" data-startTime="2210">of shared code for about half the lines of </span><span class="line" data-startTime="2217">code being shared for the two scenarios up </span><span class="line" data-startTime="2217">to 97% in this case. And get the number of </span><span class="line" data-startTime="2221">lines of code I had to write down from 131 </span><span class="line" data-startTime="2221">down to 89. </span> <span class="line" data-startTime="2224">Let me show you what that looks like. In this </span><span class="line" data-startTime="2224">case, since Chrome here doesn't have pointer </span><span class="line" data-startTime="2228">event support, I'm using the points.js polyfill. </span></p>

<p><span class="line" data-startTime="2228">So with much less code, now I can still support </span><span class="line" data-startTime="2235">dragging things around with touch and a mouse </span><span class="line" data-startTime="2235">simultaneously. </span> <span class="line" data-startTime="2240">And you can see that there is very little </span><span class="line" data-startTime="2240">code here that to handle the difference between </span><span class="line" data-startTime="2243">mouse events and pointer events. I basically </span><span class="line" data-startTime="2243">just have to check to see if the browser supports </span><span class="line" data-startTime="2246">pointer events. If so, I will use events that </span><span class="line" data-startTime="2246">start with the word "pointer" instead of the </span><span class="line" data-startTime="2250">word "mouse." Otherwise, the events are the </span><span class="line" data-startTime="2250">same. </span> <span class="line" data-startTime="2253">And in order to handle multiple things moving </span><span class="line" data-startTime="2253">around at once, if I'm using pointer events, </span><span class="line" data-startTime="2258">I'm using the unique identifier for pointer. </span> <span class="line" data-startTime="2258">Otherwise, if I am using mouse events, I will </span><span class="line" data-startTime="2262">just use this constant one. And, otherwise, </span><span class="line" data-startTime="2262">all the code is the same. The move event handler </span><span class="line" data-startTime="2267">is just this here. </span> <span class="line" data-startTime="2267">And then I have over-and-out handlers. And </span><span class="line" data-startTime="2272">so for this scenario where I really want the </span><span class="line" data-startTime="2272">same thing to happen regardless the type of </span><span class="line" data-startTime="2275">input, I can dramatically reduce the amount </span><span class="line" data-startTime="2275">of code I have to write and have to test, </span><span class="line" data-startTime="2279">which is a big part of it. </span> <span class="line" data-startTime="2279">That's a big part of it. So those are the </span><span class="line" data-startTime="2281">reasons that I'm exciting about pointer events. </span> <span class="line" data-startTime="2281">We would love to get your feedback, start </span><span class="line" data-startTime="2284">using the polyfills. And, hopefully, we will </span><span class="line" data-startTime="2284">see it in Chrome at some point in the future. </span> <span class="line" data-startTime="2291">That's it for the future. </span></p>

<p><span class="line" data-startTime="2291">And we have given you a few tips now for how </span><span class="line" data-startTime="2295">to make your site work great on touch. Now </span><span class="line" data-startTime="2295">that you all have Pixels, please try out your </span><span class="line" data-startTime="2299">Web sites and apply these tips and make your </span><span class="line" data-startTime="2299">sites awesome on touchscreen laptops. If you </span><span class="line" data-startTime="2305">have any problems doing that, we want to hear </span><span class="line" data-startTime="2305">about them. This is an area of the Web we </span><span class="line" data-startTime="2308">are trying to make better and make more consistent </span><span class="line" data-startTime="2308">across different form factors and different </span><span class="line" data-startTime="2311">browsers. So, please, we want to hear about </span><span class="line" data-startTime="2311">it. </span> <span class="line" data-startTime="2313">The public Web events mailing list, this the </span><span class="line" data-startTime="2313">group of the W3C that I'm a member of that </span><span class="line" data-startTime="2317">works on touch events. That's a great mailing </span><span class="line" data-startTime="2317">list to give us feedback on the touch event </span><span class="line" data-startTime="2322">model. </span> <span class="line" data-startTime="2322">You can also reach out to me directly on Google+ </span><span class="line" data-startTime="2325">or Twitter. And Boris and I are going to be </span><span class="line" data-startTime="2325">to available to take questions. We have got, </span><span class="line" data-startTime="2331">like, one minute, I guess. </span> <span class="line" data-startTime="2331">Why don't we take one question from our extended </span><span class="line" data-startTime="2336">audience. We have got thousands of people </span><span class="line" data-startTime="2336">watching around the world and take one quick </span><span class="line" data-startTime="2340">question. Please submit feedback using this </span><span class="line" data-startTime="2340">URL, and then we will be down here to take </span><span class="line" data-startTime="2343">any live questions. </span></p>

<p><span class="line" data-startTime="2343">You got the Dory up? Do we have any? </span></p>

<p class="speaker"><span class="line" data-starttime="2349"><span class="speakerName">Boris Smus</span>: Maybe a live question, how's </span><span class="line" data-startTime="2349">that? We'll take one. </span></p>

<p class="speaker"><span class="line" data-starttime="2353"><span class="speakerName">Rick Byers</span>: One live question. Okay. </span></p>

<p class="speaker"><span class="line" data-starttime="2353"><span class="speakerName">Audience member</span>: Do you know we're awesome? </span></p>

<p class="speaker"><span class="line" data-starttime="2362"><span class="speakerName">Rick Byers</span>: We do now. Thank you very much. </span></p>

<p class="speaker"><span class="line" data-starttime="2362"><span class="speakerName">Boris Smus</span>: Thank you very much. </span><span class="line" data-startTime="2363">[ Applause ] </span></p>

<p class="speaker"><span class="line" data-starttime="2363"><span class="speakerName">Audience member</span>: You were talking at the beginning about </span><span class="line" data-startTime="2364">the hover. I was wondering if there is any </span><span class="line" data-startTime="2364">standards work going on of sort of creating </span><span class="line" data-startTime="2364">an alternative to hover when you do the touchdown, </span><span class="line" data-startTime="2364">that that activates another style and touchup? </span><span class="line" data-startTime="2364">Instead of hover, you know, have that in the </span><span class="line" data-startTime="2364">CSS rather than having to do that in JavaScript? </span></p>

<p class="speaker"><span class="line" data-starttime="2364"><span class="speakerName">Rick Byers</span>: Right. That's what the active </span><span class="line" data-startTime="2364">CSS pseudoclass is for. The active CSS pseudoclass </span><span class="line" data-startTime="2364">is defined in the standard to say when the </span><span class="line" data-startTime="2364">user is actively manipulating this thing, </span><span class="line" data-startTime="2364">then active should be applied. So we apply </span><span class="line" data-startTime="2364">that &mdash; on touchdown, we apply that and we </span><span class="line" data-startTime="2364">stop applying on touchup. There is a couple </span><span class="line" data-startTime="2364">of details. We don't want to apply when you </span><span class="line" data-startTime="2365">are scrolling, so there is a slight delay </span><span class="line" data-startTime="2365">before it kicks in. But that's effectively </span><span class="line" data-startTime="2365">exactly what active is for. </span></p>

<p class="speaker"><span class="line" data-starttime="2365"><span class="speakerName">Audience member</span>: Does that work in multiple &mdash; does that </span><span class="line" data-startTime="2365">work in other browsers? </span></p>

<p class="speaker"><span class="line" data-starttime="2365"><span class="speakerName">Rick Byers</span>: It works in many. I think there </span><span class="line" data-startTime="2365">is a caveat with iOS that I'm not too familiar </span><span class="line" data-startTime="2365">with. But I think there is some detail where </span><span class="line" data-startTime="2365">you have to do something extra to make sure </span><span class="line" data-startTime="2365">it works in iOS. Certainly in Chrome, it works </span><span class="line" data-startTime="2366">fine. </span><span class="line" data-startTime="2366">(Speaker off microphone.) </span></p>

<p class="speaker"><span class="line" data-starttime="2366"><span class="speakerName">Rick Byers</span>: Depends upon your layout. It </span><span class="line" data-startTime="2366">can be made to work. </span></p>

<p class="speaker"><span class="line" data-starttime="2366"><span class="speakerName">Audience member</span>: I seem to recall having tried that and </span><span class="line" data-startTime="2366">it didn't work. </span></p>

<p class="speaker"><span class="line" data-starttime="2366"><span class="speakerName">Rick Byers</span>: Certainly, that's an example </span><span class="line" data-startTime="2366">of something we don't want you to have a touchevent </span><span class="line" data-startTime="2366">handler to just change the style when something </span><span class="line" data-startTime="2366">is being touched like depressing a button. </span></p>

<p class="speaker"><span class="line" data-starttime="2366"><span class="speakerName">Audience member</span>: Thanks. </span></p>

<p class="speaker"><span class="line" data-starttime="2366"><span class="speakerName">Rick Byers</span>: All right. Thanks very much. </span><span class="line" data-startTime="2366">We will be down here for questions and then </span><span class="line" data-startTime="2366">up in the Chrome office hours area. </span></p>