<p><span class="line" data-startTime="1"> Fisher: So this is Chrome </span><span class="line" data-startTime="1">Multi-Process Architecture, </span><span class="line" data-startTime="4">seat of the pants edition, </span><span class="line" data-startTime="5">and, you know, </span><span class="line" data-startTime="6">I just wanna take some time </span><span class="line" data-startTime="7">and give everybody sort of </span><span class="line" data-startTime="7">the lay of the land, </span><span class="line" data-startTime="11">try to explain, </span><span class="line" data-startTime="11">paint the broad picture </span><span class="line" data-startTime="15">of how everything works, </span><span class="line" data-startTime="16">and talk about </span><span class="line" data-startTime="16">some of the things </span><span class="line" data-startTime="18">that we had to do </span><span class="line" data-startTime="19">in order to make </span><span class="line" data-startTime="21">make it all work well. </span> <span class="line" data-startTime="22">And then I wanna </span><span class="line" data-startTime="22">try to leave some time &mdash; </span><span class="line" data-startTime="24">enough time for people </span><span class="line" data-startTime="24">to ask questions, </span><span class="line" data-startTime="26">and hopefully there will be </span><span class="line" data-startTime="26">some interesting questions, </span><span class="line" data-startTime="28">and we can dive into </span><span class="line" data-startTime="28">some interesting things. </span> <span class="line" data-startTime="30">So some of this will be review </span><span class="line" data-startTime="32">if you've read </span><span class="line" data-startTime="32">some of the design docs, </span><span class="line" data-startTime="34">but I'll just </span><span class="line" data-startTime="34">get right into it. </span> <span class="line" data-startTime="36">So first of all, </span><span class="line" data-startTime="38">what are some of the goals </span><span class="line" data-startTime="40">of Multi-Process Architecture? </span><span class="line" data-startTime="45">Well, </span><span class="line" data-startTime="45">we wanted to make sure that &mdash; </span><span class="line" data-startTime="47">What we were basically </span><span class="line" data-startTime="47">going after is, </span><span class="line" data-startTime="49">we really wanted to make </span><span class="line" data-startTime="49">a very stable browser, </span><span class="line" data-startTime="51">fast and secure, </span><span class="line" data-startTime="54">and we recognized </span><span class="line" data-startTime="57">that one really great way </span><span class="line" data-startTime="59">to improve on all these fronts </span><span class="line" data-startTime="61">was to divide up the browser </span><span class="line" data-startTime="64">into multiple processes. </span></p>

<p><span class="line" data-startTime="67">So when I talk about </span><span class="line" data-startTime="67">stability, though, </span><span class="line" data-startTime="71">there's more than just </span><span class="line" data-startTime="71">dividing the processes up </span><span class="line" data-startTime="73">into multiple processes </span><span class="line" data-startTime="74">in case the renderer crashes. </span> <span class="line" data-startTime="75">We also want to make sure </span><span class="line" data-startTime="75">that the renderer </span><span class="line" data-startTime="76">can't do anything </span><span class="line" data-startTime="77">to make your browser hang </span><span class="line" data-startTime="80">or lockup in interesting ways, </span><span class="line" data-startTime="82">and we also wanted to make sure </span><span class="line" data-startTime="84">that essentially </span><span class="line" data-startTime="84">the main process </span><span class="line" data-startTime="87">that was actually driving </span><span class="line" data-startTime="87">the whole user interface </span><span class="line" data-startTime="90">would always be able to show </span><span class="line" data-startTime="92">some recent representation </span><span class="line" data-startTime="92">of the web page </span><span class="line" data-startTime="94">such that even if the renderer </span><span class="line" data-startTime="94">was out to lunch </span><span class="line" data-startTime="97">or running garbage collection </span><span class="line" data-startTime="99">or doing some crazy thing, </span><span class="line" data-startTime="100">we'd be able to show </span><span class="line" data-startTime="101">something meaningful </span><span class="line" data-startTime="101">to the users. </span> <span class="line" data-startTime="103">And this was sort of </span><span class="line" data-startTime="103">a guiding principle </span><span class="line" data-startTime="105">for a lot of things, </span><span class="line" data-startTime="106">which I'll get into later. </span></p>

<p><span class="line" data-startTime="108">We wanted to make sure </span><span class="line" data-startTime="108">that all &mdash; </span><span class="line" data-startTime="109">Related to this, </span><span class="line" data-startTime="110">we wanted to make sure </span><span class="line" data-startTime="110">all the communication </span><span class="line" data-startTime="111">was very asynchronous, </span><span class="line" data-startTime="113">and not blocking in weird ways </span><span class="line" data-startTime="115">that would cause </span><span class="line" data-startTime="115">the user interface </span><span class="line" data-startTime="116">to &mdash; to be janky, </span><span class="line" data-startTime="120">and so that's "stable," </span><span class="line" data-startTime="122">and "fast," well, </span><span class="line" data-startTime="124">we recognized that </span><span class="line" data-startTime="124">by dividing the browser up </span><span class="line" data-startTime="126">into multiple processes, </span><span class="line" data-startTime="127">we could see benefits </span><span class="line" data-startTime="127">on multi-core systems. </span></p>

<p><span class="line" data-startTime="130">That's one thing. </span> <span class="line" data-startTime="132">We saw that, you know, </span><span class="line" data-startTime="133">if you have many </span><span class="line" data-startTime="133">different applications going, </span><span class="line" data-startTime="134">well, they can all </span><span class="line" data-startTime="134">be running independently. </span> <span class="line" data-startTime="136">Great. </span> <span class="line" data-startTime="137">But what I wanna talk about </span><span class="line" data-startTime="137">here also is that </span><span class="line" data-startTime="139">we found that even in the case </span><span class="line" data-startTime="139">of running a single web page, </span><span class="line" data-startTime="142">we could derive some benefits </span><span class="line" data-startTime="142">from multi-core, </span><span class="line" data-startTime="144">so I'll talk about that </span><span class="line" data-startTime="144">in a bit. </span> <span class="line" data-startTime="147">"Secure." </span><span class="line" data-startTime="148">Well, in the very beginning, </span><span class="line" data-startTime="149">we thought, well, </span><span class="line" data-startTime="150">in the very beginning, </span><span class="line" data-startTime="152">we had no idea we'd be so lucky </span><span class="line" data-startTime="153">as to hire a team </span><span class="line" data-startTime="153">of sandboxing experts, </span><span class="line" data-startTime="156">but it seemed reasonable </span><span class="line" data-startTime="158">that if you </span><span class="line" data-startTime="158">had a separate process </span><span class="line" data-startTime="160">for your rendering agent </span><span class="line" data-startTime="161">that you could probably </span><span class="line" data-startTime="161">do something </span><span class="line" data-startTime="162">to limit the harm </span><span class="line" data-startTime="163">if it were ever corrupted. </span></p>

<p><span class="line" data-startTime="165">Turns out that, you know, </span><span class="line" data-startTime="168">we're able to bring on the team </span><span class="line" data-startTime="168">of experts in this area, </span><span class="line" data-startTime="172">and that led to us </span><span class="line" data-startTime="172">pushing really hard </span><span class="line" data-startTime="176">to separate the renderer </span><span class="line" data-startTime="176">as much as possible </span><span class="line" data-startTime="178">from the operating system, </span><span class="line" data-startTime="179">so that it was easy </span><span class="line" data-startTime="179">to sandbox it, </span><span class="line" data-startTime="181">so I'll talk about </span><span class="line" data-startTime="181">some of that. </span> <span class="line" data-startTime="183">So here's some of the goals. </span> <span class="line" data-startTime="184">First of all, though, </span><span class="line" data-startTime="185">I wanna draw another picture </span><span class="line" data-startTime="186">just to give you a diagram </span><span class="line" data-startTime="186">of sort of some of the terms. </span></p>

<p><span class="line" data-startTime="191">So what we were trying to do </span><span class="line" data-startTime="191">here really </span><span class="line" data-startTime="195">is bring WebKit into the browser </span><span class="line" data-startTime="199">in this multi-process way, </span><span class="line" data-startTime="200">so WebKit represents </span><span class="line" data-startTime="200">a rendering area </span><span class="line" data-startTime="203">using something </span><span class="line" data-startTime="203">called a WebView, </span><span class="line" data-startTime="205">and so we basically </span><span class="line" data-startTime="205">have this thing </span><span class="line" data-startTime="209">that renders a web page </span><span class="line" data-startTime="210">that we need to have running </span><span class="line" data-startTime="211">in the subprocess, </span><span class="line" data-startTime="212">and then get its pixels </span><span class="line" data-startTime="214">and put it on the screen </span><span class="line" data-startTime="214">in the main process, </span><span class="line" data-startTime="215">so we wrap the WebView </span><span class="line" data-startTime="217">with something called </span><span class="line" data-startTime="217">a RenderView, </span><span class="line" data-startTime="219">and then this guy talks, </span><span class="line" data-startTime="223">as I'll talk later </span><span class="line" data-startTime="223">over IPC, </span><span class="line" data-startTime="225">to something called </span><span class="line" data-startTime="225">a RenderView post, </span><span class="line" data-startTime="229">so this is in the browser. </span></p>

<p><span class="line" data-startTime="235">And then here's in </span><span class="line" data-startTime="235">the renderer process. </span> <span class="line" data-startTime="238">The renderer. </span> <span class="line" data-startTime="241">[man speaks indistinct] </span><span class="line" data-startTime="243">Okay, yeah. </span> <span class="line" data-startTime="244">Peter made the comment </span><span class="line" data-startTime="245">that when we say "view" here, </span><span class="line" data-startTime="248">we're not actually </span><span class="line" data-startTime="248">talking at all </span><span class="line" data-startTime="249">about Chrome views, </span><span class="line" data-startTime="251">which was actually </span><span class="line" data-startTime="251">developed much later. </span> <span class="line" data-startTime="253">And to add confusion, </span><span class="line" data-startTime="255">there's actually a class </span><span class="line" data-startTime="255">in WebKit </span><span class="line" data-startTime="257">called RenderView, </span><span class="line" data-startTime="258">but we're not &mdash; </span><span class="line" data-startTime="258">We don't mean that. </span> <span class="line" data-startTime="259">We mean the class in Chrome </span><span class="line" data-startTime="261">called RenderView. </span> <span class="line" data-startTime="262">[laughter] </span><span class="line" data-startTime="263">So this is the WebKit side... </span></p>

<p><span class="line" data-startTime="269">over here, </span><span class="line" data-startTime="271">and essentially </span><span class="line" data-startTime="271">what you'll see in the code </span><span class="line" data-startTime="273">is that there's a WebView </span><span class="line" data-startTime="274">contained by RenderView, </span><span class="line" data-startTime="275">which then does IPC plumbing </span><span class="line" data-startTime="277">to something in the browser </span><span class="line" data-startTime="278">called a RenderView host. </span> <span class="line" data-startTime="279">So another picture. </span> <span class="line" data-startTime="280">Okay. </span> <span class="line" data-startTime="283">Stitching it all together, </span><span class="line" data-startTime="285">if you actually get down </span><span class="line" data-startTime="285">and look at the code, </span><span class="line" data-startTime="288">what we have in the browser </span><span class="line" data-startTime="288">as I mentioned here, </span><span class="line" data-startTime="290">we have these things </span><span class="line" data-startTime="290">called RenderView hosts, </span><span class="line" data-startTime="292">which is actually corresponds </span><span class="line" data-startTime="295">to a native widget, </span><span class="line" data-startTime="296">like an hWnd in Windows, </span><span class="line" data-startTime="299">and we can have </span><span class="line" data-startTime="299">multiple of these, </span><span class="line" data-startTime="301">one for every tab, </span><span class="line" data-startTime="303">okay, and then </span><span class="line" data-startTime="303">on the other renderer side, </span><span class="line" data-startTime="305">we have a corresponding </span><span class="line" data-startTime="305">RenderView, </span><span class="line" data-startTime="307">again, one for each tab, </span><span class="line" data-startTime="310">and these guys, </span><span class="line" data-startTime="311">if they're all corr &mdash; </span><span class="line" data-startTime="313">As I've drawn it here, </span><span class="line" data-startTime="315">these are all </span><span class="line" data-startTime="315">in one renderer process, </span><span class="line" data-startTime="316">so these are the corresponding </span><span class="line" data-startTime="316">objects in the browser </span><span class="line" data-startTime="319">for those guys. </span></p>

<p><span class="line" data-startTime="320">And they talk to something </span><span class="line" data-startTime="322">called a render process host, </span><span class="line" data-startTime="328">who then over IPC </span><span class="line" data-startTime="331">is communicating </span><span class="line" data-startTime="332">to a corresponding </span><span class="line" data-startTime="332">renderer process. </span> <span class="line" data-startTime="337">So this is actually &mdash; </span><span class="line" data-startTime="338">This diagram shows the IPC flow. </span> <span class="line" data-startTime="341">If a RenderView interview host </span><span class="line" data-startTime="343">wants to talk to his peer, </span><span class="line" data-startTime="344">he has to send a message </span><span class="line" data-startTime="345">through his render process host </span><span class="line" data-startTime="347">over an IPC channel </span><span class="line" data-startTime="348">to that guy, </span><span class="line" data-startTime="349">and so messages between </span><span class="line" data-startTime="351">RenderView hosts </span><span class="line" data-startTime="351">in RenderView, </span><span class="line" data-startTime="352">we call them routed messages. </span> <span class="line" data-startTime="354">Just wanna get </span><span class="line" data-startTime="354">all the terminology down. </span> <span class="line" data-startTime="356">Routed messages. </span> <span class="line" data-startTime="358">And then messages that just </span><span class="line" data-startTime="358">terminate at the process level, </span><span class="line" data-startTime="362">at the render process host </span><span class="line" data-startTime="363">or at the render process, </span><span class="line" data-startTime="364">we call those control messages. </span></p>

<p><span class="line" data-startTime="368">Okay, so as I talk about </span><span class="line" data-startTime="368">some of the other stuff, </span><span class="line" data-startTime="371">this hopefully will help. </span> <span class="line" data-startTime="373">One more thing you'll see </span><span class="line" data-startTime="374">if you're in the code, </span><span class="line" data-startTime="374">actually, </span><span class="line" data-startTime="377">is that RenderView </span><span class="line" data-startTime="377">and RenderView host, </span><span class="line" data-startTime="379">they have a base class </span><span class="line" data-startTime="379">called RenderWidget, </span><span class="line" data-startTime="382">RenderWidget host. </span> <span class="line" data-startTime="387">I bring that up because </span><span class="line" data-startTime="390">there's also over here </span><span class="line" data-startTime="392">something called a web widget. </span> <span class="line" data-startTime="395">And conceptually, </span><span class="line" data-startTime="396">this divide is simply between </span><span class="line" data-startTime="398">things that are purely </span><span class="line" data-startTime="398">just graphics related, </span><span class="line" data-startTime="401">and things that add to that </span><span class="line" data-startTime="403">web page related stuff, </span><span class="line" data-startTime="404">so the concept of loading URLs </span><span class="line" data-startTime="407">is at the RenderView level, </span><span class="line" data-startTime="407">WebView level. </span> <span class="line" data-startTime="409">The concept </span><span class="line" data-startTime="409">of just displaying pixels </span><span class="line" data-startTime="411">and dealing with input </span><span class="line" data-startTime="412">and scrolling </span><span class="line" data-startTime="412">and cursors and so on </span><span class="line" data-startTime="414">is at the widget level. </span></p>

<p><span class="line" data-startTime="416">And we also reuse RenderWidget </span><span class="line" data-startTime="418">web widget and so on </span><span class="line" data-startTime="420">for other types of UI elements </span><span class="line" data-startTime="422">that are driven by WebKit </span><span class="line" data-startTime="423">that actually don't </span><span class="line" data-startTime="423">have anything to do </span><span class="line" data-startTime="424">with loading pages, </span><span class="line" data-startTime="425">which are things like </span><span class="line" data-startTime="425">drop-down selects, </span><span class="line" data-startTime="428">so if you have a select menu </span><span class="line" data-startTime="428">in the web page </span><span class="line" data-startTime="431">and you click on it, </span><span class="line" data-startTime="432">it brings down </span><span class="line" data-startTime="432">a little pop-up window. </span> <span class="line" data-startTime="434">That pop-up window's contents </span><span class="line" data-startTime="435">are rendered by WebKit, </span><span class="line" data-startTime="436">but it's important to note </span><span class="line" data-startTime="438">that that pop-up content area </span><span class="line" data-startTime="439">isn't contained </span><span class="line" data-startTime="439">by the owning RenderView. </span> <span class="line" data-startTime="444">It can actually extend </span><span class="line" data-startTime="444">beyond the bounds of the frame, </span><span class="line" data-startTime="447">so it really needs to be its own </span><span class="line" data-startTime="448">top-level hWnd, </span><span class="line" data-startTime="449">so we reuse the RenderWidget </span><span class="line" data-startTime="451">for that kind of stuff. </span></p>

<p><span class="line" data-startTime="453">Okay. </span> <span class="line" data-startTime="457">So then a little bit about IPC. </span> <span class="line" data-startTime="460">When we first </span><span class="line" data-startTime="460">started this project, </span><span class="line" data-startTime="461">a lot of people were like, </span><span class="line" data-startTime="463">"We'll just use COM. </span> <span class="line" data-startTime="464">"That'll solve </span><span class="line" data-startTime="464">all your IPC problems, </span><span class="line" data-startTime="466">and it kinda gets you </span><span class="line" data-startTime="466">everything for free." </span><span class="line" data-startTime="468">WebKit already at that time </span><span class="line" data-startTime="470">had a COM interface on Windows, </span><span class="line" data-startTime="473">so we tried that a little bit. </span> <span class="line" data-startTime="475">COM had this sort of fundamental </span><span class="line" data-startTime="475">limitation, though, </span><span class="line" data-startTime="478">that the IPC was synchronous, </span><span class="line" data-startTime="480">or if you tried to do it </span><span class="line" data-startTime="480">asynchronous, </span><span class="line" data-startTime="482">it's not fully asynchronous, </span><span class="line" data-startTime="484">and so the performance </span><span class="line" data-startTime="484">wasn't there. </span> <span class="line" data-startTime="486">The kinds </span><span class="line" data-startTime="486">of stability properties </span><span class="line" data-startTime="488">we were looking for </span><span class="line" data-startTime="488">weren't there </span><span class="line" data-startTime="489">that I talked about earlier. </span> <span class="line" data-startTime="490">Essentially, if we were </span><span class="line" data-startTime="490">blocked on a renderer </span><span class="line" data-startTime="493">from the browser side, </span><span class="line" data-startTime="494">if we were blocked </span><span class="line" data-startTime="494">on a renderer, </span><span class="line" data-startTime="496">we were hanging the browser, </span><span class="line" data-startTime="498">and then we were having bad UI, </span><span class="line" data-startTime="499">so we really wanted to make sure </span><span class="line" data-startTime="500">we had a very </span><span class="line" data-startTime="500">asynchronous model for IPC. </span></p>

<p><span class="line" data-startTime="503">So then we went and just said, </span><span class="line" data-startTime="504">"Well, let's just use a pipe," </span><span class="line" data-startTime="505">and we ended up </span><span class="line" data-startTime="505">using a named pipe, </span><span class="line" data-startTime="506">then we used a synchronous I/O </span><span class="line" data-startTime="509">over a named pipe. </span> <span class="line" data-startTime="510">That's great. </span> <span class="line" data-startTime="511">Now we can send </span><span class="line" data-startTime="511">asynchronous messages, </span><span class="line" data-startTime="513">and what we ended up doing, </span><span class="line" data-startTime="513">though, </span><span class="line" data-startTime="516">we ended up meeting, </span><span class="line" data-startTime="516">in some cases, </span><span class="line" data-startTime="520">synchronous messages, </span><span class="line" data-startTime="521">and so we &mdash; for example, </span><span class="line" data-startTime="524">we found that there are </span><span class="line" data-startTime="524">plenty of times </span><span class="line" data-startTime="526">when WebKit </span><span class="line" data-startTime="526">needs some information, </span><span class="line" data-startTime="528">and we need it now, </span><span class="line" data-startTime="530">and so that's a synchronous IPC, </span><span class="line" data-startTime="532">where he blocks it </span><span class="line" data-startTime="532">till he gets a result. </span> <span class="line" data-startTime="534">But we decided </span><span class="line" data-startTime="534">that we will never </span><span class="line" data-startTime="536">do blocking IPCs </span><span class="line" data-startTime="536">from the browser side, </span><span class="line" data-startTime="539">because of this whole problem </span><span class="line" data-startTime="540">of maybe the renderer </span><span class="line" data-startTime="540">won't respond, </span><span class="line" data-startTime="542">and we wanna make sure </span><span class="line" data-startTime="543">the browser's always responsive. </span></p>

<p><span class="line" data-startTime="545">Okay. </span> <span class="line" data-startTime="546">So this sort of segues </span><span class="line" data-startTime="548">to talking about threads </span><span class="line" data-startTime="548">a little bit, </span><span class="line" data-startTime="550">so I thought </span><span class="line" data-startTime="550">as part of this talk </span><span class="line" data-startTime="551">I should give </span><span class="line" data-startTime="551">a little bit of description </span><span class="line" data-startTime="554">of the threads in Chrome, </span><span class="line" data-startTime="556">'cause it's not always obvious. </span> <span class="line" data-startTime="560">You hear people talk about </span><span class="line" data-startTime="561">the I/O thread, the DB thread, </span><span class="line" data-startTime="563">the file thread, </span><span class="line" data-startTime="564">the, you know, </span><span class="line" data-startTime="564">"What the F" thread, </span><span class="line" data-startTime="566">and maybe it would help </span><span class="line" data-startTime="568">to know why we have </span><span class="line" data-startTime="568">the threads we have. </span> <span class="line" data-startTime="570">So in the browser side </span><span class="line" data-startTime="570">over here, </span><span class="line" data-startTime="573">we have something </span><span class="line" data-startTime="573">called a UI thread, </span><span class="line" data-startTime="576">which is where almost all </span><span class="line" data-startTime="576">the native widgetry runs, </span><span class="line" data-startTime="580">okay? </span><span class="line" data-startTime="581">And we have an I/O thread, </span><span class="line" data-startTime="584">which is where we handle </span><span class="line" data-startTime="584">the IPC traffic, </span><span class="line" data-startTime="588">network... </span></p>

<p><span class="line" data-startTime="591">network loading, </span><span class="line" data-startTime="595">and various other kinds of </span><span class="line" data-startTime="597">what I'll call... </span> <span class="line" data-startTime="602">routing type events. </span> <span class="line" data-startTime="604">So this thread tries really hard </span><span class="line" data-startTime="606">to never be stopped on anything. </span> <span class="line" data-startTime="608">It tries to be </span><span class="line" data-startTime="608">purely asynchronous, </span><span class="line" data-startTime="611">so then we necessarily meet </span><span class="line" data-startTime="611">a different thread </span><span class="line" data-startTime="615">for cases when we need </span><span class="line" data-startTime="615">blocking I/O, </span><span class="line" data-startTime="617">and that ended up just </span><span class="line" data-startTime="617">as the evolution of things </span><span class="line" data-startTime="619">being called the file thread, </span><span class="line" data-startTime="621">and this is where we do </span><span class="line" data-startTime="621">blocking I/O </span><span class="line" data-startTime="625">as well as use COM </span><span class="line" data-startTime="627">when we need to talk to the OS, </span><span class="line" data-startTime="629">or Shell32 calls, </span><span class="line" data-startTime="631">because all these things </span><span class="line" data-startTime="631">just are really awful. </span></p>

<p><span class="line" data-startTime="633">They can hang your browser </span><span class="line" data-startTime="633">for a long time, </span><span class="line" data-startTime="635">so we don't want to use them </span><span class="line" data-startTime="637">on the UI thread </span><span class="line" data-startTime="637">if we can help it. </span> <span class="line" data-startTime="639">There's some small exceptions, </span><span class="line" data-startTime="640">because we used </span><span class="line" data-startTime="640">a CRichEditCtrl here, </span><span class="line" data-startTime="644">which turns out to use COM, </span><span class="line" data-startTime="646">and is actually </span><span class="line" data-startTime="646">a huge contributor </span><span class="line" data-startTime="648">to why Chrome </span><span class="line" data-startTime="648">might not be as fast </span><span class="line" data-startTime="650">as it could be to start up. </span> <span class="line" data-startTime="651">Ask Peter about that one. </span> <span class="line" data-startTime="654">Then there's the DB thread </span><span class="line" data-startTime="657">where we used SQLite, </span><span class="line" data-startTime="659">and there's a few other </span><span class="line" data-startTime="659">random threads, </span><span class="line" data-startTime="663">but these are the main ones </span><span class="line" data-startTime="664">you'll hear people talk about. </span> <span class="line" data-startTime="665">Now on this side, </span><span class="line" data-startTime="666">on the renderer side, </span><span class="line" data-startTime="668">we also have &mdash; </span><span class="line" data-startTime="670">we have an I/O thread as well, </span><span class="line" data-startTime="673">which again, used </span><span class="line" data-startTime="673">the receive IPCs, process IPCs, </span><span class="line" data-startTime="676">and then we have something </span><span class="line" data-startTime="676">called the render thread... </span></p>

<p><span class="line" data-startTime="678">[person sneezes] </span><span class="line" data-startTime="681">...and this is the &mdash; </span><span class="line" data-startTime="683">this turns out to be </span><span class="line" data-startTime="683">the WebKit main thread, </span><span class="line" data-startTime="690">so WebKit is a single thread, </span><span class="line" data-startTime="693">except for more recently </span><span class="line" data-startTime="694">where it handles worker threads, </span><span class="line" data-startTime="696">but traditionally </span><span class="line" data-startTime="696">it's always been </span><span class="line" data-startTime="698">a single-threaded </span><span class="line" data-startTime="698">kind of library, </span><span class="line" data-startTime="701">and this is the main thread </span><span class="line" data-startTime="703">where all </span><span class="line" data-startTime="703">the WebKit action happens. </span> <span class="line" data-startTime="705">And so to implement things </span><span class="line" data-startTime="705">like synchronous IPCs, </span><span class="line" data-startTime="708">the renderer thread </span><span class="line" data-startTime="708">gets blocked on a me text, </span><span class="line" data-startTime="711">but the I/O thread here </span><span class="line" data-startTime="713">services the IPCs </span><span class="line" data-startTime="714">to this thread here, </span><span class="line" data-startTime="716">where then some answer </span><span class="line" data-startTime="716">is provided </span><span class="line" data-startTime="718">and back to this guy. </span> <span class="line" data-startTime="723">There's one thing that I just </span><span class="line" data-startTime="723">really wanna bring up </span><span class="line" data-startTime="725">while we're talking </span><span class="line" data-startTime="725">about threads, </span><span class="line" data-startTime="726">'cause I think it's something </span><span class="line" data-startTime="728">that is really easy </span><span class="line" data-startTime="728">to get bitten by, </span><span class="line" data-startTime="731">which is that when dealing with </span><span class="line" data-startTime="731">synchronous IPCs, </span><span class="line" data-startTime="734">like, say you were implementing </span><span class="line" data-startTime="734">some new web API, </span><span class="line" data-startTime="736">or you, like &mdash; local storage </span><span class="line" data-startTime="736">or session storage, </span><span class="line" data-startTime="739">or things of this nature </span><span class="line" data-startTime="740">where you need it now, </span><span class="line" data-startTime="742">'cause the JavaScript </span><span class="line" data-startTime="742">application wants a result. </span></p>

<p><span class="line" data-startTime="745">It's tempting to &mdash; </span><span class="line" data-startTime="747">You start out with this </span><span class="line" data-startTime="747">synchronous IPC, </span><span class="line" data-startTime="749">and the traditional way </span><span class="line" data-startTime="750">that one might handle an IPC </span><span class="line" data-startTime="750">coming from a RenderView, </span><span class="line" data-startTime="752">is to handle it </span><span class="line" data-startTime="752">in the RenderView host, </span><span class="line" data-startTime="754">but the RenderView host </span><span class="line" data-startTime="754">is an hWnd, </span><span class="line" data-startTime="758">has an hWnd, </span><span class="line" data-startTime="759">and it's actually </span><span class="line" data-startTime="759">living on the UI thread, </span><span class="line" data-startTime="761">and so if a synchronous IPC </span><span class="line" data-startTime="763">comes from here </span><span class="line" data-startTime="763">all the way to the UI thread, </span><span class="line" data-startTime="765">this actually turns out to be </span><span class="line" data-startTime="765">a huge problem for us, </span><span class="line" data-startTime="768">and it's not obvious </span><span class="line" data-startTime="770">from what I've written </span><span class="line" data-startTime="770">up here why, </span><span class="line" data-startTime="771">but plug-ins </span><span class="line" data-startTime="771">are the source of this problem, </span><span class="line" data-startTime="776">and you can end up </span><span class="line" data-startTime="776">with deadlocks, </span><span class="line" data-startTime="778">and I'll spend a little bit </span><span class="line" data-startTime="778">of time explaining this, </span><span class="line" data-startTime="782">'cause I think it's really </span><span class="line" data-startTime="782">helpful for people to know. </span> <span class="line" data-startTime="785">So in Windows, </span><span class="line" data-startTime="787">when you have hWnds &mdash; </span><span class="line" data-startTime="788">I'm gonna draw pictures </span><span class="line" data-startTime="788">of hWnds here, </span><span class="line" data-startTime="791">where the green one </span><span class="line" data-startTime="791">is a plug-in. </span></p>

<p><span class="line" data-startTime="796">Like Flash. </span> <span class="line" data-startTime="798">Flash allocates its own hWnd, </span><span class="line" data-startTime="801">and Chrome has its outer hWnd. </span> <span class="line" data-startTime="803">Well, </span><span class="line" data-startTime="803">when you do this kind of thing, </span><span class="line" data-startTime="806">because we're running plug-ins </span><span class="line" data-startTime="806">out of process, </span><span class="line" data-startTime="809">there's actual </span><span class="line" data-startTime="809">synchronous communication </span><span class="line" data-startTime="811">that Windows does </span><span class="line" data-startTime="811">between parent and child hWnds. </span> <span class="line" data-startTime="815">So it's possible </span><span class="line" data-startTime="815">for our browser UI thread </span><span class="line" data-startTime="819">thanks to Windows, </span><span class="line" data-startTime="821">to be blocked, waiting </span><span class="line" data-startTime="821">for Flash to do something, </span><span class="line" data-startTime="823">like paint itself </span><span class="line" data-startTime="823">or service an input event. </span> <span class="line" data-startTime="827">And it turns out </span><span class="line" data-startTime="827">that Flash itself </span><span class="line" data-startTime="830">can also do things </span><span class="line" data-startTime="830">like script a page. </span> <span class="line" data-startTime="833">He can execute script </span><span class="line" data-startTime="833">in the outer page. </span> <span class="line" data-startTime="839">When he executes script </span><span class="line" data-startTime="839">in the outer page, </span><span class="line" data-startTime="842">because we're running Flash </span><span class="line" data-startTime="842">out of process, </span><span class="line" data-startTime="844">what he's really doing is </span><span class="line" data-startTime="844">sending a synchronous IPC </span><span class="line" data-startTime="846">to the renderer, </span><span class="line" data-startTime="847">to the render thread, </span><span class="line" data-startTime="848">saying, "Please execute </span><span class="line" data-startTime="848">this script for me." </span><span class="line" data-startTime="850">Well, while that's happening, </span><span class="line" data-startTime="852">he's not gonna be responsive </span><span class="line" data-startTime="855">to these incoming </span><span class="line" data-startTime="855">Windows events. </span></p>

<p><span class="line" data-startTime="858">And so if the renderer thread </span><span class="line" data-startTime="860">were actually at that time </span><span class="line" data-startTime="862">trying to communicate </span><span class="line" data-startTime="862">over to the browser UI thread, </span><span class="line" data-startTime="864">we could deadlock, </span><span class="line" data-startTime="865">because the browser UI thread </span><span class="line" data-startTime="866">might be blocked on the plug-in, </span><span class="line" data-startTime="867">and you get </span><span class="line" data-startTime="867">these nasty deadlocks, </span><span class="line" data-startTime="869">so we just have this </span><span class="line" data-startTime="869">very simple rule in Chrome. </span> <span class="line" data-startTime="872">Any synchronous IPC </span><span class="line" data-startTime="872">coming from the renderer </span><span class="line" data-startTime="874">should terminate </span><span class="line" data-startTime="874">at the I/O thread </span><span class="line" data-startTime="876">or one of these other </span><span class="line" data-startTime="876">background threads, </span><span class="line" data-startTime="878">but it should never be &mdash; </span><span class="line" data-startTime="879">never terminate here, </span><span class="line" data-startTime="881">never at the UI thread, </span><span class="line" data-startTime="883">and then we're safe. </span> <span class="line" data-startTime="884">We can allow all kinds </span><span class="line" data-startTime="884">of crazy synchronous IPCs </span><span class="line" data-startTime="887">that are doing weird things, </span><span class="line" data-startTime="888">and everything's happy. </span> <span class="line" data-startTime="893">So then, okay, </span><span class="line" data-startTime="893">now I really wanna move on </span><span class="line" data-startTime="896">to some more interesting things. </span></p>

<p><span class="line" data-startTime="898">Like painting. </span> <span class="line" data-startTime="905">Everybody got this? </span><span class="line" data-startTime="914">So painting... </span> <span class="line" data-startTime="919">scrolling... </span> <span class="line" data-startTime="922">resizing, restoring tabs. </span> <span class="line" data-startTime="929">All of these things, </span><span class="line" data-startTime="930">what they have in common is &mdash; </span><span class="line" data-startTime="933">these all have a lot in common </span><span class="line" data-startTime="933">which I wanna talk about. </span> <span class="line" data-startTime="936">So when we &mdash; </span><span class="line" data-startTime="937">I mentioned very early on, </span><span class="line" data-startTime="939">in order to achieve </span><span class="line" data-startTime="939">these nice stability properties, </span><span class="line" data-startTime="941">where it looks like the browser </span><span class="line" data-startTime="942">can always be responsive </span><span class="line" data-startTime="942">to the user, </span><span class="line" data-startTime="944">we were showing a possibly </span><span class="line" data-startTime="944">old representation </span><span class="line" data-startTime="947">of the pixels for the page. </span> <span class="line" data-startTime="948">So every RenderView host </span><span class="line" data-startTime="951">has a backing store, </span><span class="line" data-startTime="955">which is the bitmap </span><span class="line" data-startTime="958">of the last rendered version </span><span class="line" data-startTime="958">of the page, </span><span class="line" data-startTime="960">and the pixels for that </span><span class="line" data-startTime="960">come from the RenderView, </span><span class="line" data-startTime="965">which has functions like paint, </span><span class="line" data-startTime="969">and to produce pixels </span><span class="line" data-startTime="969">and WebKit through this area </span><span class="line" data-startTime="973">will call back and do things </span><span class="line" data-startTime="973">like invalidate... </span></p>

<p><span class="line" data-startTime="977">a Rect. </span> <span class="line" data-startTime="981">So we will observe &mdash; </span><span class="line" data-startTime="983">the RenderView will be </span><span class="line" data-startTime="984">observing invalidates </span><span class="line" data-startTime="984">from WebKit, </span><span class="line" data-startTime="986">and when he wants to, </span><span class="line" data-startTime="988">he can ask WebKit to paint </span><span class="line" data-startTime="988">and produce pixels, </span><span class="line" data-startTime="990">and then what he does </span><span class="line" data-startTime="990">is shifts those pixels </span><span class="line" data-startTime="992">over to the RenderView host, </span><span class="line" data-startTime="993">and the RenderView host </span><span class="line" data-startTime="994">puts those pixels </span><span class="line" data-startTime="994">into his backing store, </span><span class="line" data-startTime="996">and now we have a representation </span><span class="line" data-startTime="996">stored of the page </span><span class="line" data-startTime="1000">that we can always </span><span class="line" data-startTime="1000">put on the screen, </span><span class="line" data-startTime="1002">and he gets a WM_PAINT. </span></p>

<p><span class="line" data-startTime="1004">This is the Windows message </span><span class="line" data-startTime="1004">saying, </span><span class="line" data-startTime="1006">"Hey, look, you gotta put </span><span class="line" data-startTime="1006">something on the screen, </span><span class="line" data-startTime="1008">'cause I don't have anything." </span><span class="line" data-startTime="1010">And so what we'll do then </span><span class="line" data-startTime="1011">is just on the backing store </span><span class="line" data-startTime="1011">put it on the screen. </span> <span class="line" data-startTime="1014">So painting in the browser now </span><span class="line" data-startTime="1016">doesn't involve </span><span class="line" data-startTime="1016">the renderer at all. </span> <span class="line" data-startTime="1018">We can always just paint </span><span class="line" data-startTime="1018">from the backing store, </span><span class="line" data-startTime="1020">and things are fast. </span> <span class="line" data-startTime="1021">[indistinct] from </span><span class="line" data-startTime="1021">the backing store is fast. </span> <span class="line" data-startTime="1023">Asynchronous to that, </span><span class="line" data-startTime="1025">the renderer can update it. </span> <span class="line" data-startTime="1027">Early on, we built this system </span><span class="line" data-startTime="1027">and it was working, </span><span class="line" data-startTime="1031">but I noticed some funny things. </span> <span class="line" data-startTime="1033">Like, if you take Google Maps </span><span class="line" data-startTime="1035">and you grab the tile &mdash; </span><span class="line" data-startTime="1036">grab the Google Map </span><span class="line" data-startTime="1038">and you actually try to move it, </span><span class="line" data-startTime="1040">sometimes it would never see </span><span class="line" data-startTime="1042">the pixels </span><span class="line" data-startTime="1042">on the screen changing, </span><span class="line" data-startTime="1044">but the CPU usage </span><span class="line" data-startTime="1044">would spike way up, </span><span class="line" data-startTime="1046">and you're wondering </span><span class="line" data-startTime="1046">what's going on. </span></p>

<p><span class="line" data-startTime="1048">Turns out that over here </span><span class="line" data-startTime="1051">we were doing fun invalidate </span><span class="line" data-startTime="1051">paint kinds of operations, </span><span class="line" data-startTime="1055">and getting lots of invalidates, </span><span class="line" data-startTime="1057">doing lots of painting, </span><span class="line" data-startTime="1058">shipping bitmaps over, </span><span class="line" data-startTime="1060">and meanwhile </span><span class="line" data-startTime="1060">on the RenderView host side, </span><span class="line" data-startTime="1062">we were receiving mouse inputs, </span><span class="line" data-startTime="1064">sending mouse events over, </span><span class="line" data-startTime="1066">and all this was going on, </span><span class="line" data-startTime="1069">but we were never </span><span class="line" data-startTime="1069">getting a WM_PAINT. </span> <span class="line" data-startTime="1071">Turns out that input events </span><span class="line" data-startTime="1072">on Windows always trump, </span><span class="line" data-startTime="1074">always take precedent </span><span class="line" data-startTime="1074">over painting, </span><span class="line" data-startTime="1076">and so that was fun. </span> <span class="line" data-startTime="1079">So we had to then add something </span><span class="line" data-startTime="1080">to make sure that </span><span class="line" data-startTime="1080">we never produced a bitmap </span><span class="line" data-startTime="1083">unless we got it on screen, </span><span class="line" data-startTime="1085">so that was some interesting </span><span class="line" data-startTime="1085">counting that we just had to do, </span><span class="line" data-startTime="1088">and then as a result, </span><span class="line" data-startTime="1091">we don't have this problem, </span><span class="line" data-startTime="1092">so we built </span><span class="line" data-startTime="1092">an acknowledgment basis </span><span class="line" data-startTime="1094">so there's an IPC that says, </span><span class="line" data-startTime="1096">you know, something, like, </span><span class="line" data-startTime="1098">I think it's called Paint, </span><span class="line" data-startTime="1099">PaintRect or something, </span><span class="line" data-startTime="1101">and he carries with it </span><span class="line" data-startTime="1102">some shared memory bitmap </span><span class="line" data-startTime="1107">containing the data </span><span class="line" data-startTime="1109">for the invalid region, </span><span class="line" data-startTime="1111">the newly updated region, </span><span class="line" data-startTime="1113">and then he has to send back </span><span class="line" data-startTime="1113">an acknowledgement. </span></p>

<p><span class="line" data-startTime="1116">And then based on that </span><span class="line" data-startTime="1117">everything works much better. </span> <span class="line" data-startTime="1121">Because of most of our &mdash; </span><span class="line" data-startTime="1122">most everybody </span><span class="line" data-startTime="1122">was on dual-core at the time. </span> <span class="line" data-startTime="1124">No one ever saw that problem </span><span class="line" data-startTime="1124">with Google Maps. </span> <span class="line" data-startTime="1126">It was only when you got on </span><span class="line" data-startTime="1126">as the new-core machine. </span> <span class="line" data-startTime="1128">But an acknowledgement-based </span><span class="line" data-startTime="1128">system works great there. </span> <span class="line" data-startTime="1133">Scrolling. </span> <span class="line" data-startTime="1134">Scrolling is very similar. </span> <span class="line" data-startTime="1136">The thing you wanna do </span><span class="line" data-startTime="1136">with scrolling </span><span class="line" data-startTime="1139">to get very good performance </span><span class="line" data-startTime="1140">is you wanna basically &mdash; </span><span class="line" data-startTime="1141">Suppose you have &mdash; </span><span class="line" data-startTime="1142">These are all the pixels </span><span class="line" data-startTime="1142">on the screen. </span> <span class="line" data-startTime="1144">What you really wanna do is &mdash; </span><span class="line" data-startTime="1145">Suppose you're scrolling down. </span> <span class="line" data-startTime="1146">You wanna take the region </span><span class="line" data-startTime="1148">that's still to be </span><span class="line" data-startTime="1148">on the screen, </span><span class="line" data-startTime="1150">and just shift </span><span class="line" data-startTime="1150">all those pixels down to here, </span><span class="line" data-startTime="1153">and then back. </span> <span class="line" data-startTime="1156">Fill the exposed region. </span> <span class="line" data-startTime="1158">So scrolling &mdash; </span><span class="line" data-startTime="1159">[man speaks indistinctly] </span><span class="line" data-startTime="1162">Yeah, he worked </span><span class="line" data-startTime="1162">on the scroll work. </span></p>

<p><span class="line" data-startTime="1164">He's right. </span> <span class="line" data-startTime="1166">But what's going on here </span><span class="line" data-startTime="1169">is that an input event </span><span class="line" data-startTime="1169">makes its way to WebKit, </span><span class="line" data-startTime="1172">WebKit's like, "Hey." </span><span class="line" data-startTime="1173">That hit a scrollbar. </span> <span class="line" data-startTime="1174">Scrollbar did its thing, </span><span class="line" data-startTime="1176">said, "Move," </span><span class="line" data-startTime="1177">it scrolled the page, </span><span class="line" data-startTime="1178">we get a command here </span><span class="line" data-startTime="1179">that looks very different </span><span class="line" data-startTime="1179">and invalidated. </span> <span class="line" data-startTime="1181">It's called something like </span><span class="line" data-startTime="1181">ScrollRect. </span> <span class="line" data-startTime="1186">It gives us the rect </span><span class="line" data-startTime="1186">that should be scrolled, </span><span class="line" data-startTime="1189">and then DX UI. </span> <span class="line" data-startTime="1191">Then what we do is, </span><span class="line" data-startTime="1193">we set up </span><span class="line" data-startTime="1193">the same kind of thing. </span> <span class="line" data-startTime="1194">We wanna send an IPC </span><span class="line" data-startTime="1194">that says, "ScrollRect... </span> <span class="line" data-startTime="1198">passing the same parameters." </span><span class="line" data-startTime="1200">We also called paint </span><span class="line" data-startTime="1203">in order </span><span class="line" data-startTime="1203">to generate this region, </span><span class="line" data-startTime="1205">sending that bitmap </span><span class="line" data-startTime="1205">along with the DX UI and so on. </span></p>

<p><span class="line" data-startTime="1210">RenderView host then says, </span><span class="line" data-startTime="1212">"Well, I need to perform </span><span class="line" data-startTime="1212">the same operations </span><span class="line" data-startTime="1214">on my backing store." </span><span class="line" data-startTime="1215">He takes his backing store, </span><span class="line" data-startTime="1216">he shifts the pixels down, </span><span class="line" data-startTime="1217">fills in the exposed region, </span><span class="line" data-startTime="1219">and now he can, you know, </span><span class="line" data-startTime="1222">tell the hWnd, "Hey, look, </span><span class="line" data-startTime="1225">we need to do a scroll </span><span class="line" data-startTime="1225">operation," </span><span class="line" data-startTime="1226">and then when that </span><span class="line" data-startTime="1226">scroll operation happens, </span><span class="line" data-startTime="1229">he's reading all the pixels </span><span class="line" data-startTime="1231">out of his backing store again, </span><span class="line" data-startTime="1232">so they're very decoupled. </span> <span class="line" data-startTime="1233">The renderers decouple, </span><span class="line" data-startTime="1235">painting, actually, the screen, </span><span class="line" data-startTime="1237">but because </span><span class="line" data-startTime="1237">we were actually getting </span><span class="line" data-startTime="1239">DX UI and the bitmap, </span><span class="line" data-startTime="1240">we can do things </span><span class="line" data-startTime="1240">like use Windows APIs </span><span class="line" data-startTime="1243">like ScrollDC and ScrollWindow </span><span class="line" data-startTime="1245">to actually do </span><span class="line" data-startTime="1245">optimized scrolling on the hWnd </span><span class="line" data-startTime="1248">and to give </span><span class="line" data-startTime="1248">the graphics system knowledge </span><span class="line" data-startTime="1251">that we just want to do </span><span class="line" data-startTime="1252">these shift of pixels </span><span class="line" data-startTime="1252">and backfill, </span><span class="line" data-startTime="1254">which allows scrolling </span><span class="line" data-startTime="1254">to be low CPU usage. </span></p>

<p><span class="line" data-startTime="1258">It turns out </span><span class="line" data-startTime="1258">that some pages have, like, </span><span class="line" data-startTime="1261">exposition content </span><span class="line" data-startTime="1261">defeat optimized scrolling, </span><span class="line" data-startTime="1264">because you can't just </span><span class="line" data-startTime="1264">shift pixels down, </span><span class="line" data-startTime="1267">you have to re-render stuff </span><span class="line" data-startTime="1268">because of overlapping things. </span> <span class="line" data-startTime="1270">This is a problem in Gmail, </span><span class="line" data-startTime="1272">like, with the little </span><span class="line" data-startTime="1272">chat windows that come up. </span> <span class="line" data-startTime="1273">That's why </span><span class="line" data-startTime="1273">Gmail scrolling's slow, </span><span class="line" data-startTime="1275">because that chat window might &mdash; </span><span class="line" data-startTime="1278">it's always interfering </span><span class="line" data-startTime="1280">with the content below it. </span> <span class="line" data-startTime="1282">Anyhow. </span> <span class="line" data-startTime="1284">Resizing. </span> <span class="line" data-startTime="1286">Resizing is kind of interesting, </span><span class="line" data-startTime="1287">because </span><span class="line" data-startTime="1287">what's happening there is &mdash; </span><span class="line" data-startTime="1290">I'll just erase part of this. </span> <span class="line" data-startTime="1293">With resizing, </span><span class="line" data-startTime="1295">what's happening is that </span><span class="line" data-startTime="1295">we have the outer hWnd, </span><span class="line" data-startTime="1299">user grabs the corner, </span><span class="line" data-startTime="1301">Windows tells us, </span><span class="line" data-startTime="1303">"Hey, look, your size changed," </span><span class="line" data-startTime="1305">and then right after that </span><span class="line" data-startTime="1305">he says, "Now paint." </span><span class="line" data-startTime="1307">And this is a case </span><span class="line" data-startTime="1309">where the backing store's </span><span class="line" data-startTime="1309">not good enough. </span> <span class="line" data-startTime="1310">Our backing store is small, </span><span class="line" data-startTime="1312">and Windows just &mdash; </span><span class="line" data-startTime="1314">and we we're &mdash; </span><span class="line" data-startTime="1314">Now I need new pixels, </span><span class="line" data-startTime="1316">so what do we do? </span><span class="line" data-startTime="1317">This is where we ended up </span><span class="line" data-startTime="1319">sending an IPC </span><span class="line" data-startTime="1319">down to the renderer </span><span class="line" data-startTime="1322">to have him produce </span><span class="line" data-startTime="1322">the new pixels </span><span class="line" data-startTime="1324">for the whole thing, </span><span class="line" data-startTime="1325">and then we do wait. </span></p>

<p><span class="line" data-startTime="1327">Then we wait a little bit. </span> <span class="line" data-startTime="1330">Like, I forget how much. </span> <span class="line" data-startTime="1332">Maybe up to 40 milliseconds, </span><span class="line" data-startTime="1334">or something reasonably small. </span> <span class="line" data-startTime="1335">We wait for our I/O thread </span><span class="line" data-startTime="1338">to receive an IPC </span><span class="line" data-startTime="1338">that actually carries with it </span><span class="line" data-startTime="1341">the shared memory </span><span class="line" data-startTime="1341">for the new rendering, </span><span class="line" data-startTime="1344">and so if we get it </span><span class="line" data-startTime="1344">in not enough time, </span><span class="line" data-startTime="1346">then what we would actually </span><span class="line" data-startTime="1346">be able to display is, </span><span class="line" data-startTime="1348">unperceptible to the user, </span><span class="line" data-startTime="1351">we actually </span><span class="line" data-startTime="1351">now got the new pixels, </span><span class="line" data-startTime="1352">and they never see </span><span class="line" data-startTime="1352">the old representation </span><span class="line" data-startTime="1355">at the wrong size. </span> <span class="line" data-startTime="1357">However, I'm sure </span><span class="line" data-startTime="1357">anybody who's used Chrome </span><span class="line" data-startTime="1358">knows that often times </span><span class="line" data-startTime="1360">you'll get </span><span class="line" data-startTime="1360">this little white border here </span><span class="line" data-startTime="1362">where we didn't have pixels yet, </span><span class="line" data-startTime="1364">and we're just </span><span class="line" data-startTime="1364">still catching up. </span></p>

<p><span class="line" data-startTime="1366">And mostly that's limited </span><span class="line" data-startTime="1366">by how fast WebKit </span><span class="line" data-startTime="1369">can relay out the whole page </span><span class="line" data-startTime="1369">as a result of a recess. </span> <span class="line" data-startTime="1373">So, Gmail, </span><span class="line" data-startTime="1373">this will always happen. </span> <span class="line" data-startTime="1375">Google.com, </span><span class="line" data-startTime="1375">it'll never happen. </span> <span class="line" data-startTime="1380">Anyways, Google.com </span><span class="line" data-startTime="1380">has a white background. </span> <span class="line" data-startTime="1385">So turns out that because </span><span class="line" data-startTime="1385">we're using these backing stores </span><span class="line" data-startTime="1389">to get good performance </span><span class="line" data-startTime="1389">of the browser, </span><span class="line" data-startTime="1391">we're also </span><span class="line" data-startTime="1391">using a lot of memory, </span><span class="line" data-startTime="1392">and so if we have </span><span class="line" data-startTime="1392">a lot of tabs. </span> <span class="line" data-startTime="1395">we'll be using a lot of memory </span><span class="line" data-startTime="1397">'cause we have </span><span class="line" data-startTime="1397">a ton of backing stores, </span><span class="line" data-startTime="1399">and that's kinda bad, </span><span class="line" data-startTime="1400">so we need a cache, obviously. </span></p>

<p><span class="line" data-startTime="1402">We have only </span><span class="line" data-startTime="1402">so many backing stores. </span> <span class="line" data-startTime="1404">So then what about tabs that </span><span class="line" data-startTime="1404">you haven't been to in a while, </span><span class="line" data-startTime="1406">and you go back to them, </span><span class="line" data-startTime="1407">what are you gonna do? </span><span class="line" data-startTime="1408">Well, it's kinda similar </span><span class="line" data-startTime="1408">to the resize problem. </span> <span class="line" data-startTime="1410">You don't have a backing store, </span><span class="line" data-startTime="1410">but you need it now, </span><span class="line" data-startTime="1412">so we used the same trick &mdash; </span><span class="line" data-startTime="1413">asked the renderer </span><span class="line" data-startTime="1413">to produce pixels, </span><span class="line" data-startTime="1416">wait just a little bit, </span><span class="line" data-startTime="1417">see if he can produce them </span><span class="line" data-startTime="1417">in enough time. </span> <span class="line" data-startTime="1419">If he does, </span><span class="line" data-startTime="1419">then it's all seamless, </span><span class="line" data-startTime="1421">and we actually </span><span class="line" data-startTime="1421">ended up extending this. </span> <span class="line" data-startTime="1424">We said that </span><span class="line" data-startTime="1424">even foreground tabs, </span><span class="line" data-startTime="1426">'cause you have </span><span class="line" data-startTime="1426">a lot of windows, </span><span class="line" data-startTime="1427">even foreground tabs </span><span class="line" data-startTime="1429">can potentially lose </span><span class="line" data-startTime="1429">their backing store, </span><span class="line" data-startTime="1430">and if the user interacts </span><span class="line" data-startTime="1430">with that page now, </span><span class="line" data-startTime="1434">we have to go get </span><span class="line" data-startTime="1434">the backing store </span><span class="line" data-startTime="1435">and fill it again, </span><span class="line" data-startTime="1436">and the same trick </span><span class="line" data-startTime="1436">is used there. </span> <span class="line" data-startTime="1437">It all kinda works. </span> <span class="line" data-startTime="1442">I said I would save time </span><span class="line" data-startTime="1442">for questions, </span><span class="line" data-startTime="1444">so I'm gonna just end there, </span><span class="line" data-startTime="1446">and ask if people </span><span class="line" data-startTime="1446">have questions. </span></p>

<p><span class="line" data-startTime="1447">Is there anything </span><span class="line" data-startTime="1447">you want me to talk about, </span><span class="line" data-startTime="1449">or should I go on? </span><span class="line" data-startTime="1453">Five minutes? </span><span class="line" data-startTime="1453">I'll just go on. </span> <span class="line" data-startTime="1458">Okay, sure. </span> <span class="line" data-startTime="1460">So I mentioned a little bit </span><span class="line" data-startTime="1462">in the beginning about events. </span> <span class="line" data-startTime="1466">Turns out that we &mdash; </span><span class="line" data-startTime="1469">Or actually, </span><span class="line" data-startTime="1469">I won't talk about that. </span> <span class="line" data-startTime="1471">I'll talk about sandboxing </span><span class="line" data-startTime="1471">a little bit more, </span><span class="line" data-startTime="1473">and some of the security steps, </span><span class="line" data-startTime="1475">some of the stuff we did </span><span class="line" data-startTime="1475">to facilitate security. </span> <span class="line" data-startTime="1477">So as I mentioned with plug-ins, </span><span class="line" data-startTime="1479">hWnds can be multi-process. </span></p>

<p><span class="line" data-startTime="1482">You can have a different hWnd </span><span class="line" data-startTime="1482">for a child process, </span><span class="line" data-startTime="1485">so why not just use hWnds </span><span class="line" data-startTime="1485">for the renderer? </span><span class="line" data-startTime="1488">Why do all this crazy stuff </span><span class="line" data-startTime="1490">I just got done describing? </span><span class="line" data-startTime="1491">Well, turns out that we just </span><span class="line" data-startTime="1491">lose the ability </span><span class="line" data-startTime="1494">to sandbox it as effectively, </span><span class="line" data-startTime="1496">because there's </span><span class="line" data-startTime="1496">these connections </span><span class="line" data-startTime="1497">between child and parent hWnd, </span><span class="line" data-startTime="1499">it'd be possible </span><span class="line" data-startTime="1499">for the renderer, </span><span class="line" data-startTime="1501">a corrupt renderer, </span><span class="line" data-startTime="1502">to mess with </span><span class="line" data-startTime="1502">the window hierarchy, </span><span class="line" data-startTime="1504">and thereby screw up the browser </span><span class="line" data-startTime="1506">in interesting ways. </span> <span class="line" data-startTime="1507">Also, hWnds like this </span><span class="line" data-startTime="1508">would reveal information </span><span class="line" data-startTime="1508">about the desktop, </span><span class="line" data-startTime="1510">and one of the things </span><span class="line" data-startTime="1510">that the sandbox achieved </span><span class="line" data-startTime="1513">was literally </span><span class="line" data-startTime="1513">running the renderer </span><span class="line" data-startTime="1516">with a different desktop, </span><span class="line" data-startTime="1517">so it's running on its own </span><span class="line" data-startTime="1517">virtual desktop, </span><span class="line" data-startTime="1519">so it's such </span><span class="line" data-startTime="1519">that if there were ever </span><span class="line" data-startTime="1521">any kind of hole in the sandbox </span><span class="line" data-startTime="1522">that allowed people to play </span><span class="line" data-startTime="1522">with user32 libraries, </span><span class="line" data-startTime="1525">all they'd be getting </span><span class="line" data-startTime="1526">is user resources </span><span class="line" data-startTime="1526">for a different desktop. </span></p>

<p><span class="line" data-startTime="1530">And so this adds </span><span class="line" data-startTime="1530">another level of security, </span><span class="line" data-startTime="1532">just to kind of keep user input </span><span class="line" data-startTime="1534">and other kinds of things </span><span class="line" data-startTime="1535">away from this renderer, </span><span class="line" data-startTime="1536">as far away as possible. </span> <span class="line" data-startTime="1541">Right. </span> <span class="line" data-startTime="1543">So this really necessitated, </span><span class="line" data-startTime="1545">getting all the Windowsisms </span><span class="line" data-startTime="1545">out of the renderer, </span><span class="line" data-startTime="1549">and moving to this sort of more </span><span class="line" data-startTime="1551">in-memory kind of approach. </span> <span class="line" data-startTime="1554"> Peter: </span><span class="line" data-startTime="1554">Isn't there one other reason </span><span class="line" data-startTime="1555">to not use hWnds for renderers, </span><span class="line" data-startTime="1557">which is to not interlock </span><span class="line" data-startTime="1557">the message views, </span><span class="line" data-startTime="1559">and thus possibly </span><span class="line" data-startTime="1559">hang our browser </span><span class="line" data-startTime="1561">if the renderer hangs up? </span><span class="line" data-startTime="1563"> Fisher: </span><span class="line" data-startTime="1563">Yes, what Peter said. </span> <span class="line" data-startTime="1564">With all the synchronist </span><span class="line" data-startTime="1564">IPCs to happen </span><span class="line" data-startTime="1567">between hWnds in Windows, </span><span class="line" data-startTime="1569">we have a potential problem </span><span class="line" data-startTime="1572">that the child window </span><span class="line" data-startTime="1572">is blocked, </span><span class="line" data-startTime="1573">waiting on its parent </span><span class="line" data-startTime="1573">for something, </span><span class="line" data-startTime="1575">and I explained earlier </span><span class="line" data-startTime="1576">that whenever </span><span class="line" data-startTime="1576">we have a situation </span><span class="line" data-startTime="1577">where the renderer thread </span><span class="line" data-startTime="1580">is blocked, potentially, </span><span class="line" data-startTime="1580">on the UI thread of Chrome, </span><span class="line" data-startTime="1582">bad things can happen. </span></p>

<p><span class="line" data-startTime="1584">So this actually, </span><span class="line" data-startTime="1584">for a number of reasons, </span><span class="line" data-startTime="1586">turned out to be very necessary </span><span class="line" data-startTime="1588">to just get the hWnds </span><span class="line" data-startTime="1588">out of the rendering process. </span> <span class="line" data-startTime="1590"> Peter: Which means </span><span class="line" data-startTime="1590">we can still lock the browser </span><span class="line" data-startTime="1591">to rely on hung plug-ins, </span><span class="line" data-startTime="1593">assessing a hung </span><span class="line" data-startTime="1593">plug-in detector, right? </span><span class="line" data-startTime="1595"> Darin: </span><span class="line" data-startTime="1595">Yes, so if anybody's seen &mdash; </span><span class="line" data-startTime="1597">If you wait long enough </span><span class="line" data-startTime="1597">after Flash locks up, </span><span class="line" data-startTime="1600">if you wait 30 seconds, </span><span class="line" data-startTime="1600">I think, </span><span class="line" data-startTime="1602">you'll see </span><span class="line" data-startTime="1602">a little dialogue come up </span><span class="line" data-startTime="1603">offering to kill Flash, </span><span class="line" data-startTime="1605">because we've detected </span><span class="line" data-startTime="1605">that it's not responsive, </span><span class="line" data-startTime="1609">and that it's </span><span class="line" data-startTime="1609">brought down or wedged </span><span class="line" data-startTime="1611">the whole widget hierarchy </span><span class="line" data-startTime="1611">it's associated with. </span> <span class="line" data-startTime="1613">We use the same kinda API </span><span class="line" data-startTime="1615">that Windows does to figure out </span><span class="line" data-startTime="1617">that it should put up </span><span class="line" data-startTime="1617">the little "end task" dialogue </span><span class="line" data-startTime="1620">for unresponsive treatment </span><span class="line" data-startTime="1622">in the title bar </span><span class="line" data-startTime="1622">of your application. </span> <span class="line" data-startTime="1625">Any other questions? </span><span class="line" data-startTime="1628">Okay, then I'll just throw out </span><span class="line" data-startTime="1628">one more interesting thing. </span></p>

<p><span class="line" data-startTime="1632">Turns out because </span><span class="line" data-startTime="1632">we're multi-process &mdash; </span><span class="line" data-startTime="1634">Ojan reminded me of this. </span> <span class="line" data-startTime="1636">Turns out because </span><span class="line" data-startTime="1636">we're multi-process, </span><span class="line" data-startTime="1638">we can do things like </span><span class="line" data-startTime="1639">potentially just kill, </span><span class="line" data-startTime="1644">terminate the child process </span><span class="line" data-startTime="1645">when we close a tab. </span> <span class="line" data-startTime="1647">If the child process </span><span class="line" data-startTime="1647">has no unload handlers, </span><span class="line" data-startTime="1650">if the web pages in there </span><span class="line" data-startTime="1652">have no unload handlers </span><span class="line" data-startTime="1653">and no [indistinct] </span><span class="line" data-startTime="1653">load handlers, </span><span class="line" data-startTime="1654">then the web page anyways </span><span class="line" data-startTime="1654">has no idea if it's gone, </span><span class="line" data-startTime="1657">so we look to see </span><span class="line" data-startTime="1659">did the web page have </span><span class="line" data-startTime="1660">any of those kinds </span><span class="line" data-startTime="1660">of event handlers, </span><span class="line" data-startTime="1662">and if it doesn't, </span><span class="line" data-startTime="1663">then when we wanna kill it, </span><span class="line" data-startTime="1664">we just alt terminate process, </span><span class="line" data-startTime="1667">and turns out to be really nice, </span><span class="line" data-startTime="1669">'cause then tabs close quickly. </span> <span class="line" data-startTime="1673">Okay. End. </span></p>

<p><span class="line" data-startTime="1676">[applause] </span></p>