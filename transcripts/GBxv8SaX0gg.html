<p><span class="line" data-startTime="4">Jorge Lucangeli Obes: Good morning, everyone, </span><span class="line" data-startTime="4">and thanks for joining the session. My name </span><span class="line" data-startTime="6">is Jorge, and I work with the Chrome Security </span><span class="line" data-startTime="6">team. Today I'll be talking about how to make </span><span class="line" data-startTime="11">Chrome apps and extensions be more secure. </span> <span class="line" data-startTime="11">And as the subtitle of the talk says, we want </span><span class="line" data-startTime="17">to focus on keeping the users of these apps </span><span class="line" data-startTime="17">and extensions safe. </span> <span class="line" data-startTime="21">Now, a lot of work has been done, not only </span><span class="line" data-startTime="21">by Google, but by other browser vendors as </span><span class="line" data-startTime="27">well, to make browsers more secure. </span> <span class="line" data-startTime="27">What does this mean? It's harder now for a </span><span class="line" data-startTime="33">malicious Web site, any random Web site to </span><span class="line" data-startTime="33">compromise a browser in a way in which it </span><span class="line" data-startTime="37">would allow the attacker to execute arbitrary </span><span class="line" data-startTime="37">code in the user's device. </span></p>

<p><span class="line" data-startTime="42">However, in order to also protect the user's </span><span class="line" data-startTime="42">data, the data that the user keeps in your </span><span class="line" data-startTime="48">Web app or Chrome app or Chrome extension, </span><span class="line" data-startTime="48">we need the help of you, the developers. The </span><span class="line" data-startTime="54">browser by itself cannot completely protect </span><span class="line" data-startTime="54">the user's data from attack. </span> <span class="line" data-startTime="58">Now, the good news is that the Web platform </span><span class="line" data-startTime="58">itself has been exposed to untrusted content </span><span class="line" data-startTime="65">or malicious content basically from the start. </span> <span class="line" data-startTime="65">That doesn't mean we're always scared about </span><span class="line" data-startTime="71">this malicious content, but we've made a lot </span><span class="line" data-startTime="71">of progress integrating features that allow </span><span class="line" data-startTime="75">developers to make their Web apps more secure. </span> <span class="line" data-startTime="75">However, we haven't seen the level of adoption </span><span class="line" data-startTime="81">that we would have liked. And an objective </span><span class="line" data-startTime="81">of the session is to tell you about these </span><span class="line" data-startTime="86">features so that you can use them and make </span><span class="line" data-startTime="86">your applications more secure. The browser, </span><span class="line" data-startTime="91">together with the application developers, </span><span class="line" data-startTime="91">will really make applications secure. </span></p>

<p><span class="line" data-startTime="96">Now, of course, a 45-minute long talk is not </span><span class="line" data-startTime="96">enough to cover every single aspect of Web </span><span class="line" data-startTime="105">app security, so I'm going to focus on the </span><span class="line" data-startTime="105">client side. I'm going to try to go over the </span><span class="line" data-startTime="108">features that can be leveraged both by regular </span><span class="line" data-startTime="108">Web apps, by Chrome apps, Chrome extensions, </span><span class="line" data-startTime="114">even the ones that run offline. </span> <span class="line" data-startTime="114">Now, I talked about the Web platform and how </span><span class="line" data-startTime="120">we have incorporated features that help developers </span><span class="line" data-startTime="120">make more secure Web apps. I'm going to focus </span><span class="line" data-startTime="125">on two of them which we believe, the security </span><span class="line" data-startTime="125">community at large believe provide the best </span><span class="line" data-startTime="130">bang for the buck. </span> <span class="line" data-startTime="130">Number one, content security policy. If people </span><span class="line" data-startTime="135">here attended a talk on Wednesday about Manifest </span><span class="line" data-startTime="135">Version 2 and Extensions Version 2, they probably </span><span class="line" data-startTime="142">have heard about CSP. And they probably also </span><span class="line" data-startTime="142">have heard about HTML5 sandboxed iFrames. </span> <span class="line" data-startTime="147">I'm going to talk about these two technologies </span><span class="line" data-startTime="147">and show how you use them, common pitfalls </span><span class="line" data-startTime="151">that occur when you use them, so that you </span><span class="line" data-startTime="151">can leave the talk and at least if you leave </span><span class="line" data-startTime="158">the talk and try to use some of these features </span><span class="line" data-startTime="158">in your apps and extensions, I will be very, </span><span class="line" data-startTime="162">very happy indeed. </span> <span class="line" data-startTime="162">Now, before going in-depth into the features </span><span class="line" data-startTime="167">I want to take a couple of seconds to go over </span><span class="line" data-startTime="167">the same origin policy real quick. The same </span><span class="line" data-startTime="171">origin policy is the basic security policy </span><span class="line" data-startTime="171">that browsers and user agents try to get Web </span><span class="line" data-startTime="180">sites to comply to in the Web. And the same </span><span class="line" data-startTime="180">origin policy basically says that two objects </span><span class="line" data-startTime="185">can interact directly if and only if they </span><span class="line" data-startTime="185">belong to the same origin. An origin, which </span><span class="line" data-startTime="190">is taken from the URI of those subjects by </span><span class="line" data-startTime="190">looking into the schema, the host and the </span><span class="line" data-startTime="197">port of that URI. </span></p>

<p><span class="line" data-startTime="197">Now, the good thing about talking and reasoning </span><span class="line" data-startTime="201">about origins is that the most common security </span><span class="line" data-startTime="201">vulnerabilities can be described in terms </span><span class="line" data-startTime="207">of origins. When untrusted content or script </span><span class="line" data-startTime="207">gains the authority or runs in the context </span><span class="line" data-startTime="212">of a particular origin, we talk about cross-site </span><span class="line" data-startTime="212">scripting. </span> <span class="line" data-startTime="215">When a possibly malicious origin gets the </span><span class="line" data-startTime="215">network access privileges, the Web request </span><span class="line" data-startTime="219">privileges of another origin, we talk about </span><span class="line" data-startTime="219">cross-site request forgery. And for some reason </span><span class="line" data-startTime="223">which I don't understand, people really like </span><span class="line" data-startTime="223">to say cross-site scripting with an X and </span><span class="line" data-startTime="227">cross-site request forgery with a C. I will </span><span class="line" data-startTime="227">never get that. </span> <span class="line" data-startTime="231">Now, a lot of the features that I'm going </span><span class="line" data-startTime="231">to talk about today can be very easily implemented </span><span class="line" data-startTime="237">in an extensions manifest or a Chrome apps </span><span class="line" data-startTime="237">manifest. But after helping many teams at </span><span class="line" data-startTime="243">Google write more secure apps and extensions, </span><span class="line" data-startTime="243">either for Chrome or for Chrome OS, I notice </span><span class="line" data-startTime="248">that people made the same mistakes over and </span><span class="line" data-startTime="248">over again not because they didn't know what </span><span class="line" data-startTime="254">they had to do, but because there's some tricky, </span><span class="line" data-startTime="254">like, nuances that one has to know in order </span><span class="line" data-startTime="260">to make CSP or sandbox iFrames work correctly. </span></p>

<p><span class="line" data-startTime="260">So I wrote a very simple app, which I call </span><span class="line" data-startTime="267">Manifest Lint. Not very creative, but that's </span><span class="line" data-startTime="267">what I got. It will highlight sections of </span><span class="line" data-startTime="274">the manifest that are okay from a security </span><span class="line" data-startTime="274">perspective and sections that might need help. </span> <span class="line" data-startTime="279">In this case I am feeding the actual manifest </span><span class="line" data-startTime="279">of the Manifest Lint application to itself </span><span class="line" data-startTime="283">and it's telling me that I'm not setting a </span><span class="line" data-startTime="283">content security policy. Now, I will go deeper </span><span class="line" data-startTime="287">into content security policy in a couple of </span><span class="line" data-startTime="287">slides. </span> <span class="line" data-startTime="294">But first I want to show you what happens </span><span class="line" data-startTime="294">when one develops an application and doesn't </span><span class="line" data-startTime="297">really take into account security. </span> <span class="line" data-startTime="297">Now, I wrote this application in time to demo </span><span class="line" data-startTime="305">it at I/O, and one could wonder what happens </span><span class="line" data-startTime="305">if the application takes a manifest in that </span><span class="line" data-startTime="313">text area and displays the highlighted manifest </span><span class="line" data-startTime="313">on the other side. </span></p>

<p><span class="line" data-startTime="318">Now, what happens if the application receives </span><span class="line" data-startTime="318">a manifest that is not necessarily benign, </span><span class="line" data-startTime="324">that is malicious or malformed? Well, let's </span><span class="line" data-startTime="324">try that. I'm going to switch video, and if </span><span class="line" data-startTime="330">I cannot make this demo work after what Sergey </span><span class="line" data-startTime="330">did on Wednesday, I'm going to feel really, </span><span class="line" data-startTime="335">really bad. </span> <span class="line" data-startTime="335">[ Laughter ] </span><span class="line" data-startTime="338">Jorge Lucangeli Obes: Okay. Awesome. </span> <span class="line" data-startTime="338">Now, the extension &mdash; the app basically takes </span><span class="line" data-startTime="348">a manifest and displays it highlighted on </span><span class="line" data-startTime="348">the other side. It also saves the manifests </span><span class="line" data-startTime="353">to local storage so that I can bring them </span><span class="line" data-startTime="353">back and not have to input them all the time. </span> <span class="line" data-startTime="359">Now, what happens if I input this manifest? </span><span class="line" data-startTime="359">I hope &mdash; yeah, font size is okay. </span> <span class="line" data-startTime="367">Which has a very weird description. It's got </span><span class="line" data-startTime="367">HTML tags in its description and image tag </span><span class="line" data-startTime="372">and JavaScript. It's not looking good. </span> <span class="line" data-startTime="372">If I input this manifest into my extension, </span><span class="line" data-startTime="383">nothing will happen, but maybe eventually </span><span class="line" data-startTime="383">the user might go over a part of the manifest </span><span class="line" data-startTime="389">and I hope it reads, but that's one of the </span><span class="line" data-startTime="389">things that's stored in local storage. </span></p>

<p><span class="line" data-startTime="395">Now, we don't expect just random input to </span><span class="line" data-startTime="395">be able to read local storage of the application. </span> <span class="line" data-startTime="403">And in this case it's just manifest. It's </span><span class="line" data-startTime="403">not really secret or private, but this could </span><span class="line" data-startTime="407">be user's data, private data, email, whatever, </span><span class="line" data-startTime="407">anything that's stored in the app or the extensions </span><span class="line" data-startTime="413">origin is now available just one confusion, </span><span class="line" data-startTime="413">one trick away from an attacker. </span> <span class="line" data-startTime="422">I'm going to go back to the slides. </span> <span class="line" data-startTime="422">What's the problem? That's the problem. I'm </span><span class="line" data-startTime="437">using eval to parse JSON and I'm using inner </span><span class="line" data-startTime="437">HTML to display the highlighted manifest. </span> <span class="line" data-startTime="446">Now, I'm not going to go very deep into what </span><span class="line" data-startTime="446">the exploit does, but it's basically using </span><span class="line" data-startTime="454">the fact that I'm using inner HTML to inject </span><span class="line" data-startTime="454">script into the application that is triggered </span><span class="line" data-startTime="461">when the user mouses over the image. </span> <span class="line" data-startTime="461">Now, since I'm &mdash; since the use of inner HTML </span><span class="line" data-startTime="466">basically allows me to inject any sort of </span><span class="line" data-startTime="466">tag or script that I want, that's basically </span><span class="line" data-startTime="470">giving a straight way for an attacker to get </span><span class="line" data-startTime="470">malicious input into my application. </span></p>

<p><span class="line" data-startTime="476">And this is where content security policy </span><span class="line" data-startTime="476">comes in. </span> <span class="line" data-startTime="480">In a nutshell, content security policy is </span><span class="line" data-startTime="480">a way for me, the application or extension </span><span class="line" data-startTime="485">developer, to tell the browser, only allow </span><span class="line" data-startTime="485">me, the application, to load resources or </span><span class="line" data-startTime="493">script from this whitelist or trusted sources. </span> <span class="line" data-startTime="493">Now, it might be &mdash; might sound kind of weird </span><span class="line" data-startTime="500">since I'm telling the browser to restrict </span><span class="line" data-startTime="500">what I'm &mdash; what me, the application, is allowed </span><span class="line" data-startTime="506">to do, but since we've seen in the demo that </span><span class="line" data-startTime="506">it's very easy to hijack the behavior of an </span><span class="line" data-startTime="513">application, it's a very powerful tool, CSP, </span><span class="line" data-startTime="513">and it allows me to &mdash; beforehand to say I </span><span class="line" data-startTime="521">don't want to be able to load anything outside </span><span class="line" data-startTime="521">of these trusted sources. </span></p>

<p><span class="line" data-startTime="528">By doing this, by not allowing the application </span><span class="line" data-startTime="528">to load script or resources from untrusted </span><span class="line" data-startTime="534">sources, we prevent most cross-site scripting </span><span class="line" data-startTime="534">attacks; however, in order to be able to tell </span><span class="line" data-startTime="544">whether the script or the resource that we </span><span class="line" data-startTime="544">are loading actually belongs in the whitelist </span><span class="line" data-startTime="549">or not, we need to be able to tell where that </span><span class="line" data-startTime="549">script comes from. And the problem is that </span><span class="line" data-startTime="555">we are not always able to do that if the script </span><span class="line" data-startTime="555">that we're loading is included in-line, in </span><span class="line" data-startTime="563">the application. </span> <span class="line" data-startTime="563">There's no way for the browser to tell whether </span><span class="line" data-startTime="566">inline script has been put there by the developer </span><span class="line" data-startTime="566">or has been injected due to a bug in the application. </span></p>

<p><span class="line" data-startTime="577">The only way in which CSP can fulfill its </span><span class="line" data-startTime="577">purpose and actually block things that are </span><span class="line" data-startTime="582">not in the whitelist is to ban all the uses </span><span class="line" data-startTime="582">of inline script or features in JavaScript </span><span class="line" data-startTime="589">that turn strings into code because you can </span><span class="line" data-startTime="589">never be sure whether the inline script was </span><span class="line" data-startTime="596">malicious or not or whether the string that's </span><span class="line" data-startTime="596">been turned into code by eval is malicious </span><span class="line" data-startTime="599">or not. </span> <span class="line" data-startTime="599">Now, how do we use it? If you're writing Chrome </span><span class="line" data-startTime="604">app or in extension it's really, really simple. </span> <span class="line" data-startTime="604">You just add one line to the manifest called, </span><span class="line" data-startTime="610">very creatively, content security policy. </span> <span class="line" data-startTime="610">And a content security policy itself is just </span><span class="line" data-startTime="616">a list of allowed sources for different types </span><span class="line" data-startTime="616">of resources. </span> <span class="line" data-startTime="621">In this case what we're saying is that by </span><span class="line" data-startTime="621">default the application is only allowed to </span><span class="line" data-startTime="625">load resources from its own origin. That's </span><span class="line" data-startTime="625">what the, quote, self quote, token says. </span> <span class="line" data-startTime="633">Now in case of scripts we want to allow the </span><span class="line" data-startTime="633">application to load scripts from its own origin, </span><span class="line" data-startTime="638">the extension package, as well as the googleapis.com </span><span class="line" data-startTime="638">site. </span></p>

<p><span class="line" data-startTime="645">And in case of styles, CSP does include a </span><span class="line" data-startTime="645">token called unsafe inline, also with quotes. </span> <span class="line" data-startTime="653">This can &mdash; this can be used to turn off the </span><span class="line" data-startTime="653">requirement for a script not to be inline; </span><span class="line" data-startTime="660">however, if we use an unsafe inline token </span><span class="line" data-startTime="660">in the script source line we're basically </span><span class="line" data-startTime="665">defeating the purpose of CSP. We are not gaining </span><span class="line" data-startTime="665">any advantage. </span> <span class="line" data-startTime="672">Styles are not the same thing in the sense </span><span class="line" data-startTime="672">that they don't directly execute code. </span> <span class="line" data-startTime="677">And in most cases it's the trade-off between </span><span class="line" data-startTime="677">not being able to use inline style and the </span><span class="line" data-startTime="684">possible exposure to malicious CSS. And buggy </span><span class="line" data-startTime="684">parsing CSS code in the browser is really </span><span class="line" data-startTime="690">not that problematic. </span> <span class="line" data-startTime="690">The most important thing in this case is we </span><span class="line" data-startTime="695">cannot load script from anywhere else but </span><span class="line" data-startTime="695">those two sources. </span> <span class="line" data-startTime="700">Now, if I try to load this, my application, </span><span class="line" data-startTime="700">with this new manifest, I'm not going to do </span><span class="line" data-startTime="708">it in the computer because the text of a JavaScript </span><span class="line" data-startTime="708">console is very hard to make bigger. So that's </span><span class="line" data-startTime="713">exactly what Chrome prints if I try to load </span><span class="line" data-startTime="713">my existing application with this new manifest. </span> <span class="line" data-startTime="721">And it's basically saying what we expected </span><span class="line" data-startTime="721">it to say. If content security policy doesn't </span><span class="line" data-startTime="726">allow inline script, then, of course, Chrome </span><span class="line" data-startTime="726">is refusing to run inline script. If content </span><span class="line" data-startTime="730">security policy doesn't allow in-line event </span><span class="line" data-startTime="730">handling, which is basically the same as in-line </span><span class="line" data-startTime="734">script, it's JavaScript code that's included </span><span class="line" data-startTime="734">in-line in HTML. </span></p>

<p><span class="line" data-startTime="739">And Chrome has complained about one more thing. </span> <span class="line" data-startTime="739">It complaining about the fact that I'm loading </span><span class="line" data-startTime="744">jQuery or HTTP. </span> <span class="line" data-startTime="744">Now, in a regular Web site this wouldn't necessarily </span><span class="line" data-startTime="749">be a problem since you're already loading </span><span class="line" data-startTime="749">the Web site over HTTP. The fact that you're </span><span class="line" data-startTime="754">loading script over HTTP, it's really not </span><span class="line" data-startTime="754">that problematic. However, if you're running </span><span class="line" data-startTime="758">on extensions, extensions get more privileged </span><span class="line" data-startTime="758">access to the browser compared to regular </span><span class="line" data-startTime="764">sites. They have access to APIs. The normal </span><span class="line" data-startTime="764">sites don't have access to. </span> <span class="line" data-startTime="768">If you're leading script over HTTP, you're </span><span class="line" data-startTime="768">exposed to what we call mine-in-the-middle </span><span class="line" data-startTime="772">attacks. If you're using your extension at </span><span class="line" data-startTime="772">a Starbucks hot spot, then any person sitting </span><span class="line" data-startTime="779">at that Starbucks hot spot can intercept the </span><span class="line" data-startTime="779">loading of that &mdash; that script loading over </span><span class="line" data-startTime="786">HTTP, change it and make you run malicious </span><span class="line" data-startTime="786">script in the origin of your extension, which </span><span class="line" data-startTime="791">has privileged access to the browser's API. </span> <span class="line" data-startTime="791">And as we've seen, from there to stealing </span><span class="line" data-startTime="796">private data is just some code away. </span> <span class="line" data-startTime="796">Now, we need to change, of course, these few </span><span class="line" data-startTime="801">things in order to make my teeny-tiny application </span><span class="line" data-startTime="801">work with CSP. </span> <span class="line" data-startTime="810">That's basically what we're going to do. </span></p>

<p><span class="line" data-startTime="810">I change the jQuery loading to load over HTTP, </span><span class="line" data-startTime="816">which is a source that I have enabled in CSP. </span> <span class="line" data-startTime="816">And I'm going to &mdash; I'm going to extract all </span><span class="line" data-startTime="826">my JavaScript code into a .js file, which </span><span class="line" data-startTime="826">is something I should have done in the beginning. </span> <span class="line" data-startTime="831">Best practices for Web development call for </span><span class="line" data-startTime="831">separation of the structure of the document </span><span class="line" data-startTime="836">in HTTP, the behavior in JavaScript and the </span><span class="line" data-startTime="836">style in CSS. </span> <span class="line" data-startTime="840">This is the easy part. I also have to get </span><span class="line" data-startTime="840">rid of inline event handling, which I can </span><span class="line" data-startTime="846">very easily translate to native JavaScript </span><span class="line" data-startTime="846">using a bit of jQuery magic. </span> <span class="line" data-startTime="853">I'm saying that the lint function is going </span><span class="line" data-startTime="853">to be the handler of the link that I use to </span><span class="line" data-startTime="860">tell my application to process the manifest. </span> <span class="line" data-startTime="860">And finally, I have to change my eval function </span><span class="line" data-startTime="868">into JSON parse. </span> <span class="line" data-startTime="868">Now, I didn't use the fact that the application </span><span class="line" data-startTime="871">was using eval to run my exploit. I just used </span><span class="line" data-startTime="871">the fact that it was running HTML; however, </span><span class="line" data-startTime="878">since the application was using eval to parse </span><span class="line" data-startTime="878">JSON, instead of doing crazy things with tasks, </span><span class="line" data-startTime="882">I could just send a JavaScript statement as </span><span class="line" data-startTime="882">a manifest. </span></p>

<p><span class="line" data-startTime="887">Now, that would have been slightly cheating </span><span class="line" data-startTime="887">in my opinion because there needs to be at </span><span class="line" data-startTime="897">least an impression of, well, this could have </span><span class="line" data-startTime="897">seemed like a regular manifest in order for </span><span class="line" data-startTime="902">the exploit chain to be somewhat credible. </span> <span class="line" data-startTime="902">If I'm just telling the user to paste something </span><span class="line" data-startTime="907">that starts with alert as a manifest, then </span><span class="line" data-startTime="907">I'm kind of cheating. </span> <span class="line" data-startTime="911">The good thing is that I'm not going to get </span><span class="line" data-startTime="911">rid of inner HTML. And now we'll see why. </span> <span class="line" data-startTime="919">I don't really need to get rid of inner HTML, </span><span class="line" data-startTime="919">although it would be very good to do. </span></p>

<p><span class="line" data-startTime="926">What happens if I try to do the same thing? </span><span class="line" data-startTime="926">Just so you see that I'm not faking it, I'm </span><span class="line" data-startTime="934">going to go back to the demo and I'm going </span><span class="line" data-startTime="934">to try to load the same &mdash; it happens. </span> <span class="line" data-startTime="944">We broke everything. </span> <span class="line" data-startTime="944">I'm going to use exactly the same manifest </span><span class="line" data-startTime="956">in the safe version of the application that </span><span class="line" data-startTime="956">loads with the content security policy that </span><span class="line" data-startTime="960">you guys have seen. If I try to do that, it </span><span class="line" data-startTime="960">will load, but if I mouse over the little </span><span class="line" data-startTime="967">square, which have the onload attribute, nothing </span><span class="line" data-startTime="967">happens. And the console, which clearly you </span><span class="line" data-startTime="974">guys cannot read that, but it says "Refuse </span><span class="line" data-startTime="974">to execute event handler because of content </span><span class="line" data-startTime="979">security policy." So I'm protected, which </span><span class="line" data-startTime="979">is really cool. </span> <span class="line" data-startTime="983">It's the same thing that is on the slide, </span><span class="line" data-startTime="983">my demo failure slide. </span> <span class="line" data-startTime="992">And the interesting thing is that the way </span><span class="line" data-startTime="992">I see it, CSP allows the application or extension </span><span class="line" data-startTime="1001">developer to rely on the browser as a safety </span><span class="line" data-startTime="1001">net. I'm pretty sure that I covered every </span><span class="line" data-startTime="1010">single base, I'm pretty sure that I tied every </span><span class="line" data-startTime="1010">loose end, but just in case I haven't, please, </span><span class="line" data-startTime="1017">you browser, make sure that I don't screw </span><span class="line" data-startTime="1017">up. </span></p>

<p><span class="line" data-startTime="1021">This is what I'm talking about when I say </span><span class="line" data-startTime="1021">that application developers and browser developers </span><span class="line" data-startTime="1025">have to work together in order to protect </span><span class="line" data-startTime="1025">users. </span> <span class="line" data-startTime="1029">The browser can make sure that your application </span><span class="line" data-startTime="1029">never uses unsafe script. You guys have to </span><span class="line" data-startTime="1035">use the feature that the browser provides </span><span class="line" data-startTime="1035">in order to allow the browser to do this. </span> <span class="line" data-startTime="1042">Now, people might say, "Well, that's a really, </span><span class="line" data-startTime="1042">really simple app. It doesn't really do anything </span><span class="line" data-startTime="1048">useful." And you might very well be right. </span> <span class="line" data-startTime="1048">So I want to move over to something that's </span><span class="line" data-startTime="1055">very dear to my heart, which is the Chrome </span><span class="line" data-startTime="1055">OS document viewer. We applied these two security </span><span class="line" data-startTime="1062">features to the Chrome OS document viewer. </span> <span class="line" data-startTime="1062">The Chrome OS document viewer allows Chrome </span><span class="line" data-startTime="1066">OS users to open a lot of different document </span><span class="line" data-startTime="1066">types, including Office files, online on their </span><span class="line" data-startTime="1073">Chrome OS devices directly from the Chrome </span><span class="line" data-startTime="1073">OS file manager. </span> <span class="line" data-startTime="1077">Everything runs on the Web/Chrome platform </span><span class="line" data-startTime="1077">and it runs offline. </span></p>

<p><span class="line" data-startTime="1083">Now, when the developers of the development </span><span class="line" data-startTime="1083">viewer were working on the application, we </span><span class="line" data-startTime="1088">wanted to make sure that it was a safe application. </span> <span class="line" data-startTime="1088">Opening Office documents, it's dangerous, </span><span class="line" data-startTime="1095">and we wanted to make sure that we could do </span><span class="line" data-startTime="1095">it in a safe way. </span> <span class="line" data-startTime="1099">So the first thing the developers did was </span><span class="line" data-startTime="1099">apply a content security policy to this app </span><span class="line" data-startTime="1105">or extension. </span> <span class="line" data-startTime="1105">In this case it's an app. </span> <span class="line" data-startTime="1108">It doesn't really change that much from what </span><span class="line" data-startTime="1108">I did with my demo app, but it's interesting </span><span class="line" data-startTime="1114">that they are also using unsafe inline for </span><span class="line" data-startTime="1114">styles, and this makes a lot of sense because </span><span class="line" data-startTime="1119">if you're writing a document viewer you cannot </span><span class="line" data-startTime="1119">really predict what kinds of crazy document </span><span class="line" data-startTime="1125">formatting the author of those documents might </span><span class="line" data-startTime="1125">do. </span> <span class="line" data-startTime="1129">So you need to create script &mdash; sorry, styles </span><span class="line" data-startTime="1129">on the fly dynamically and load them inline. </span> <span class="line" data-startTime="1134">Now, in this case, again, this is a matter </span><span class="line" data-startTime="1134">of it's a trade-off between the functionality </span><span class="line" data-startTime="1139">of the application, basic functionality of </span><span class="line" data-startTime="1139">the application, which is displaying the styles </span><span class="line" data-startTime="1144">that are included in the document I want to </span><span class="line" data-startTime="1144">view, and security, which is I'm not really </span><span class="line" data-startTime="1149">happy with loading inline CSS because it might </span><span class="line" data-startTime="1149">open me to be &mdash; to injection for malicious </span><span class="line" data-startTime="1156">CSS, but we trust the CSS parser in Chrome. </span></p>

<p><span class="line" data-startTime="1156">If killing inline styles kills the purpose </span><span class="line" data-startTime="1164">of a document viewer, then we need to allow </span><span class="line" data-startTime="1164">it. Security is always, most of the times, </span><span class="line" data-startTime="1168">about tradeoffs. </span> <span class="line" data-startTime="1168">Another interesting thing is that I'm using </span><span class="line" data-startTime="1176">a couple more resource sources that I haven't </span><span class="line" data-startTime="1176">shown before, which are image source, which </span><span class="line" data-startTime="1183">of course governs which images can be loaded </span><span class="line" data-startTime="1183">by the application. And I'm using blob URIs </span><span class="line" data-startTime="1189">for images. I going to come back to blob URIs. </span> <span class="line" data-startTime="1189">I wanted to show it today so it stays in your </span><span class="line" data-startTime="1193">mind. I'm going to come back to blob URIs. </span> <span class="line" data-startTime="1193">I'm also using frame source. Now content security </span><span class="line" data-startTime="1198">policy includes more types of sources. There's </span><span class="line" data-startTime="1198">a bunch of them. I'm not going to go over </span><span class="line" data-startTime="1203">them, but if you type content security policy </span><span class="line" data-startTime="1203">in Google it takes you directly to the list </span><span class="line" data-startTime="1208">of it. </span> <span class="line" data-startTime="1208">Now we come probably the crucial part of the </span><span class="line" data-startTime="1214">talk. Which is &mdash; CSP is awesome, and it really </span><span class="line" data-startTime="1214">prevents cross-site scripting, but we haven't </span><span class="line" data-startTime="1221">seen that much adoption by the development </span><span class="line" data-startTime="1221">community. </span> <span class="line" data-startTime="1225">So the only way we saw to make this really </span><span class="line" data-startTime="1225">happen was to force, to make a default CSP </span><span class="line" data-startTime="1234">policy apply by default when absent extensions </span><span class="line" data-startTime="1234">start using Manifest V2. Now, if people here </span><span class="line" data-startTime="1243">attended the talk on Wednesday about Manifest </span><span class="line" data-startTime="1243">V2, they probably have an idea of what the </span><span class="line" data-startTime="1247">schedule will look like for Manifest V2. I'm </span><span class="line" data-startTime="1247">going to go over the schedule again, but let's </span><span class="line" data-startTime="1253">see exactly what exactly is forced by Manifest </span><span class="line" data-startTime="1253">V2 in terms of CSP. </span></p>

<p><span class="line" data-startTime="1259">The first line, script source self, object </span><span class="line" data-startTime="1259">source self, it's going to be the default, </span><span class="line" data-startTime="1264">unchangeable, "unloosenable". CSP policy that's </span><span class="line" data-startTime="1264">going to be used in all (indiscernible) extensions </span><span class="line" data-startTime="1272">that use Manifest V2. The reason for this </span><span class="line" data-startTime="1272">is the same that I've been talking about. </span> <span class="line" data-startTime="1278">If &mdash; if your upper extension loads inline </span><span class="line" data-startTime="1278">script, the browser cannot really tell whether </span><span class="line" data-startTime="1284">the script that is executing comes from a </span><span class="line" data-startTime="1284">trusted source or not. The same thing happens </span><span class="line" data-startTime="1289">with plug-ins. If we cannot &mdash; if you are </span><span class="line" data-startTime="1289">loading a plug-in over HTTP, and you run on </span><span class="line" data-startTime="1296">public Wi-Fi, then the plug-in that you are </span><span class="line" data-startTime="1296">getting in your extension does not necessarily </span><span class="line" data-startTime="1301">look like the plug-in that you thought you </span><span class="line" data-startTime="1301">were getting. It might have been changed in </span><span class="line" data-startTime="1305">transit and you can have no way of telling. </span> <span class="line" data-startTime="1305">Both scripts and plug-ins run code in the </span><span class="line" data-startTime="1311">context of your extension. If we cannot be </span><span class="line" data-startTime="1311">sure that that code is trusted, we cannot </span><span class="line" data-startTime="1316">give that code the privileges that the extension </span><span class="line" data-startTime="1316">has. </span></p>

<p><span class="line" data-startTime="1318">So that's going to be the default. However, </span><span class="line" data-startTime="1318">in both cases, since we trust the resources </span><span class="line" data-startTime="1326">that we load over HTTPS, it's allowed to include </span><span class="line" data-startTime="1326">HTTPS sources both as script source and as </span><span class="line" data-startTime="1333">plug-in source. You can load plug-ins and </span><span class="line" data-startTime="1333">scripts over HTTPS because it's very much </span><span class="line" data-startTime="1338">guaranteed that the scripts you're going to </span><span class="line" data-startTime="1338">get is the script that you actually want to </span><span class="line" data-startTime="1341">get. </span> <span class="line" data-startTime="1341">One more thing that you can do with CSP, which </span><span class="line" data-startTime="1346">is interesting, is that when you write Chrome </span><span class="line" data-startTime="1346">apps and extensions, you use host permissions </span><span class="line" data-startTime="1353">in order to govern which Web sites you can </span><span class="line" data-startTime="1353">inject content script into, but those same </span><span class="line" data-startTime="1357">permissions govern which hosts you can do </span><span class="line" data-startTime="1357">XHR requests to. If you need to do XHR requests </span><span class="line" data-startTime="1365">to a smaller number of hosts than what you </span><span class="line" data-startTime="1365">need to inject the script into, you can further </span><span class="line" data-startTime="1370">restrict the hosts that you allow XHR requests </span><span class="line" data-startTime="1370">to happen against by using the connect source </span><span class="line" data-startTime="1377">directly. It might seem like not a very big </span><span class="line" data-startTime="1377">deal, but security is always about restricting </span><span class="line" data-startTime="1384">privilege, allowing things to have the least </span><span class="line" data-startTime="1384">amount of privilege possible so that if something </span><span class="line" data-startTime="1389">goes wrong, a compromise happens, the thing </span><span class="line" data-startTime="1389">that gets compromised will never be able to </span><span class="line" data-startTime="1396">do more than it was allowed to do in the beginning. </span> <span class="line" data-startTime="1396">That's basically what we're trying to do with </span><span class="line" data-startTime="1400">CSP. Now, this is basically how it's going </span><span class="line" data-startTime="1400">to happen with Manifest V2. Chrome 21, which </span><span class="line" data-startTime="1408">goes to stable in mid August, it's going to </span><span class="line" data-startTime="1408">block uploading new items to the Chrome Web </span><span class="line" data-startTime="1414">store that have Manifest V1. With Chrome 23 </span><span class="line" data-startTime="1414">that goes stable in early November, even existing </span><span class="line" data-startTime="1423">items that use Manifest Version 1 will not </span><span class="line" data-startTime="1423">be able to be updated to new version. And </span><span class="line" data-startTime="1430">Chrome will stop packaging apps and extensions </span><span class="line" data-startTime="1430">that have Manifest V1. </span></p>

<p><span class="line" data-startTime="1436">Now in the beginning of 2013, we will remove </span><span class="line" data-startTime="1436">Manifest Version 1 items from search results, </span><span class="line" data-startTime="1443">so that they are very, very hard to find. </span> <span class="line" data-startTime="1443">In the middle, beginning of Q2 of 2013, we </span><span class="line" data-startTime="1451">will completely remove all Manifest V1 items </span><span class="line" data-startTime="1451">from the Chrome Web store and eventually Chrome </span><span class="line" data-startTime="1457">will refuse to load them at all, whatsoever. </span> <span class="line" data-startTime="1457">Now, it's almost a year from now, right, until </span><span class="line" data-startTime="1465">it doesn't really work anymore and the changes </span><span class="line" data-startTime="1465">are not really that big. But the important </span><span class="line" data-startTime="1473">thing is that this is the only way that we </span><span class="line" data-startTime="1473">can guarantee that your users and the users </span><span class="line" data-startTime="1477">of Chrome browser and the Chrome extension </span><span class="line" data-startTime="1477">and the Chrome platform don't get compromised. </span> <span class="line" data-startTime="1482">It's not necessarily because the application </span><span class="line" data-startTime="1482">developer is writing a malicious app, but </span><span class="line" data-startTime="1489">it's for the attacker to have a way in, you </span><span class="line" data-startTime="1489">just have to make one mistake. For &mdash; for </span><span class="line" data-startTime="1495">the browser/app to win, you have to &mdash; you </span><span class="line" data-startTime="1495">have to tie every single loose end, so it's </span><span class="line" data-startTime="1501">an uphill battle. But we have some tools that </span><span class="line" data-startTime="1501">help us win the battle and we really need </span><span class="line" data-startTime="1507">you guys to start using these tools. </span> <span class="line" data-startTime="1507">Now, the other good thing about CSP is that </span><span class="line" data-startTime="1514">it's also available or in fact it came up </span><span class="line" data-startTime="1514">as a solution for the regular drive-by Web. </span></p>

<p><span class="line" data-startTime="1521">It's currently supported in Firefox and Chrome </span><span class="line" data-startTime="1521">using the X content security policy in the </span><span class="line" data-startTime="1525">case of Firefox and the X WebKit CSP in Chrome. </span> <span class="line" data-startTime="1525">Eventually, we hope this will be supported </span><span class="line" data-startTime="1533">in all browsers. </span> <span class="line" data-startTime="1533">Now, there's some more issues that can come </span><span class="line" data-startTime="1547">up with CSP. And I wanted to take a couple </span><span class="line" data-startTime="1547">of minutes to discuss them. </span> <span class="line" data-startTime="1552">An issue that we have seen a lot with CSP </span><span class="line" data-startTime="1552">is how we talked about how it completely balanced </span><span class="line" data-startTime="1559">the use of eval because there's no way of </span><span class="line" data-startTime="1559">telling where that string that's being turned </span><span class="line" data-startTime="1565">into code comes from. It's the same problem </span><span class="line" data-startTime="1565">as within inline script. The browser cannot </span><span class="line" data-startTime="1569">be sure whether that script is actually something </span><span class="line" data-startTime="1569">the application developer wrote and not something </span><span class="line" data-startTime="1574">that a malicious user wrote. </span> <span class="line" data-startTime="1574">The problem is that many Web frameworks use </span><span class="line" data-startTime="1581">eval to do templating, for example, and if </span><span class="line" data-startTime="1581">we ban eval, then these things are not going </span><span class="line" data-startTime="1586">to work. And in effect, there's a very cool </span><span class="line" data-startTime="1586">starter kit for ember.js that basically brings </span><span class="line" data-startTime="1593">up single-header (indiscernible) page using </span><span class="line" data-startTime="1593">the templating engine for ember.js which is </span><span class="line" data-startTime="1601">handlebars. </span></p>

<p><span class="line" data-startTime="1601">Now if we use operate, very, very recently </span><span class="line" data-startTime="1605">content security policy similar to the one </span><span class="line" data-startTime="1605">that we used before, we are allowing loading </span><span class="line" data-startTime="1610">scripts over HTTPS, we are allowing inline </span><span class="line" data-startTime="1610">styles. This is basically what the ember.js </span><span class="line" data-startTime="1621">&mdash; what the ember.js index &mdash; index HTML page </span><span class="line" data-startTime="1621">looks like. It's true we are allowing the </span><span class="line" data-startTime="1628">loading of that script, everything else is </span><span class="line" data-startTime="1628">loading from the extensions on package. But </span><span class="line" data-startTime="1633">if we try to load it, we get a very, very, </span><span class="line" data-startTime="1633">very nasty error which basically says something </span><span class="line" data-startTime="1638">like code generation from scripts is disallowed </span><span class="line" data-startTime="1638">in this context. It also points us to a source </span><span class="line" data-startTime="1645">file and a line, which basically says something </span><span class="line" data-startTime="1645">like function applies, something, something. </span> <span class="line" data-startTime="1653">This is never going to work with a CSP policy </span><span class="line" data-startTime="1653">that actually does work as intended. Now, </span><span class="line" data-startTime="1659">there are two ways around this. Way number </span><span class="line" data-startTime="1659">one is for this frameworks to move away from </span><span class="line" data-startTime="1666">eval and other code generation functions. </span></p>

<p><span class="line" data-startTime="1666">Now, if you are actually writing the new package </span><span class="line" data-startTime="1674">apps and using Manifest Version 2 as we introduced </span><span class="line" data-startTime="1674">during I/O, there's another way of doing this, </span><span class="line" data-startTime="1680">which is using new attribute for manifest, </span><span class="line" data-startTime="1680">which is called sandbox. Which I'm not going </span><span class="line" data-startTime="1688">to go into specifically in the version that's </span><span class="line" data-startTime="1688">used in the manifest. I'm going to cover it </span><span class="line" data-startTime="1694">more generally, so that it can be used also </span><span class="line" data-startTime="1694">in the drive-by Web. </span> <span class="line" data-startTime="1702">Before moving on to the next, to HTML5 sandbox </span><span class="line" data-startTime="1702">iFrames, a very big CSP don't, unsafe in-line </span><span class="line" data-startTime="1709">and unsafe eval or script source, completely </span><span class="line" data-startTime="1709">defeat the purpose of CSP. Please don't do </span><span class="line" data-startTime="1714">it. If you need to do this, you probably are </span><span class="line" data-startTime="1714">doing something not wrong, but you are doing </span><span class="line" data-startTime="1721">something insecurely. So please think again. </span> <span class="line" data-startTime="1721">If you need to include this in your CSP policy, </span><span class="line" data-startTime="1727">then please, please, think about why you need </span><span class="line" data-startTime="1727">to do it. </span></p>

<p><span class="line" data-startTime="1731">Now, the good thing about CSP is that it provides </span><span class="line" data-startTime="1731">a very effectively live place for resources, </span><span class="line" data-startTime="1736">but it's not very granular. It's either you </span><span class="line" data-startTime="1736">are allowed to load this or you're not. What </span><span class="line" data-startTime="1742">we would like to have is a way of maybe running </span><span class="line" data-startTime="1742">script in our application, but not giving </span><span class="line" data-startTime="1749">that script access to the extensions or the </span><span class="line" data-startTime="1749">applications origin. It seems like there's </span><span class="line" data-startTime="1754">nothing in between. It's either not running </span><span class="line" data-startTime="1754">at all or running and giving complete access </span><span class="line" data-startTime="1758">to user's data and everything. That's where </span><span class="line" data-startTime="1758">HTML5 sandbox iFrames come from. What we would </span><span class="line" data-startTime="1765">like to do is to load that script, execute </span><span class="line" data-startTime="1765">it, but execute it in a different origin than </span><span class="line" data-startTime="1770">the actual application or extension origins. </span> <span class="line" data-startTime="1770">In fact, let's go even further. We want to </span><span class="line" data-startTime="1774">run it in an origin that's different from </span><span class="line" data-startTime="1774">any other origin out there. We call those </span><span class="line" data-startTime="1779">unique origins. They are by definition different </span><span class="line" data-startTime="1779">from any other origin there is. </span> <span class="line" data-startTime="1785">This is where the HTML5 iFrame sandbox attribute </span><span class="line" data-startTime="1785">comes in. It allows loading resources, content </span><span class="line" data-startTime="1792">or script safely inside an iFrame that will </span><span class="line" data-startTime="1792">get less privilege than a regular iFrame. </span></p>

<p><span class="line" data-startTime="1800">And we can completely control which of these </span><span class="line" data-startTime="1800">privileges we give back and which ones we </span><span class="line" data-startTime="1804">keep away from the iFrame. </span> <span class="line" data-startTime="1804">Now, it's as simple as using the sandbox attribute </span><span class="line" data-startTime="1811">on a regular iFrame. If we do that, the code </span><span class="line" data-startTime="1811">that we load inside the iFrame will be restricted </span><span class="line" data-startTime="1818">in this way. It will live in a unique origin, </span><span class="line" data-startTime="1818">so we won't be able to access directly the </span><span class="line" data-startTime="1824">application of the extensions, DOM structure </span><span class="line" data-startTime="1824">or script or anything. It actually &mdash; if we </span><span class="line" data-startTime="1831">don't do anything else, it won't even be allowed </span><span class="line" data-startTime="1831">to run scripts at all. Or submit forms. Or </span><span class="line" data-startTime="1837">navigate the top page. Or load plug-ins. Or </span><span class="line" data-startTime="1837">create pop-ups. Now, almost all of those things </span><span class="line" data-startTime="1844">can be re-enabled individually by giving arguments </span><span class="line" data-startTime="1844">to the sandbox attribute. Except the loading </span><span class="line" data-startTime="1850">of plug-ins, which so far cannot be re-enabled. </span> <span class="line" data-startTime="1850">Now, I said that we might want to use sandbox </span><span class="line" data-startTime="1858">iFrames to run script in a different origin. </span> <span class="line" data-startTime="1858">So going back to the Chrome OS document viewer, </span><span class="line" data-startTime="1870">what the document viewer developers did was </span><span class="line" data-startTime="1870">run most of the JavaScript that displayed </span><span class="line" data-startTime="1877">the final document inside a sandbox iFrame. </span></p>

<p><span class="line" data-startTime="1877">And why did they do this? Well, even though </span><span class="line" data-startTime="1884">we might be pretty confident about the JavaScript </span><span class="line" data-startTime="1884">that we wrote, if there's no need for that </span><span class="line" data-startTime="1890">JavaScript to directly access all of the private </span><span class="line" data-startTime="1890">information that an application such as a </span><span class="line" data-startTime="1895">document viewer might have, why give it that </span><span class="line" data-startTime="1895">privilege? If it doesn't need it? If anything </span><span class="line" data-startTime="1900">goes wrong with the JavaScript that I wrote, </span><span class="line" data-startTime="1900">which if I'm parsing a document, as heavy </span><span class="line" data-startTime="1905">as like a spreadsheet or something like that, </span><span class="line" data-startTime="1905">a lot of things can probably go wrong. </span> <span class="line" data-startTime="1910">So since that code doesn't need to access </span><span class="line" data-startTime="1910">every single file that I'm using in my document </span><span class="line" data-startTime="1916">viewer, let's just not give it access to that. </span> <span class="line" data-startTime="1916">Let's just give it the one file that it needs </span><span class="line" data-startTime="1920">to display, so if anything goes wrong, it </span><span class="line" data-startTime="1920">cannot go and steal every single file that </span><span class="line" data-startTime="1925">I own and ship it away to somewhere. </span></p>

<p><span class="line" data-startTime="1925">So that's what the document viewer developers </span><span class="line" data-startTime="1932">did. They kept most of the document viewer </span><span class="line" data-startTime="1932">inside of a sandbox iFrame, which was only </span><span class="line" data-startTime="1937">allowed to run script, and load pop-ups, but </span><span class="line" data-startTime="1937">nothing else, no forms, no plug-ins, nothing. </span> <span class="line" data-startTime="1945">In this way, if anything goes wrong with that </span><span class="line" data-startTime="1945">code, the JavaScript will not be able to access </span><span class="line" data-startTime="1951">the extension or the apps origin where probably </span><span class="line" data-startTime="1951">the rest of the document, the user's documents </span><span class="line" data-startTime="1955">live. And this is a very good thing. </span> <span class="line" data-startTime="1955">Now, inside the sandboxed iFrame, there's </span><span class="line" data-startTime="1962">really not that much that changes. This code </span><span class="line" data-startTime="1962">is basically loading a lot of JavaScript to </span><span class="line" data-startTime="1968">do its job, to parse the document, and display </span><span class="line" data-startTime="1968">the document. But it looks like every other </span><span class="line" data-startTime="1972">single web app that might be out there, except </span><span class="line" data-startTime="1972">for one teeny tiny detail, which comes from </span><span class="line" data-startTime="1979">the fact that that JavaScript code lives inside </span><span class="line" data-startTime="1979">a unique origin. There's no way for the JavaScript </span><span class="line" data-startTime="1986">code outside of the Sandbox and the JavaScript </span><span class="line" data-startTime="1986">code inside the sandbox to talk directly. </span> <span class="line" data-startTime="1990">They need to use some sort of inter-origin </span><span class="line" data-startTime="1990">API. And the most recent inter-origin API </span><span class="line" data-startTime="1997">that they can use, of course, is postMessage. </span> <span class="line" data-startTime="1997">It's explicitly designed to &mdash; </span><span class="line" data-startTime="1997">in a very JavaScript-y way, with asynchronous </span><span class="line" data-startTime="2015">message handling. </span></p>

<p><span class="line" data-startTime="2015">Now, this is what &mdash; this is what &mdash; what </span><span class="line" data-startTime="2020">message handling function might look for postMessage </span><span class="line" data-startTime="2020">in the drive-by Web. The thing is that it </span><span class="line" data-startTime="2027">is for security reasons, it is good to check </span><span class="line" data-startTime="2027">if the message that I got over postMessage </span><span class="line" data-startTime="2034">is being sent to me and that's what the event </span><span class="line" data-startTime="2034">origin tells me. When you post a message using </span><span class="line" data-startTime="2040">postMessage, you say I'm intending this origin </span><span class="line" data-startTime="2040">to be the recipient. When you get the message </span><span class="line" data-startTime="2047">you say, hey, was I the recipient? Is event.origin </span><span class="line" data-startTime="2047">the source that I expected? Since they live </span><span class="line" data-startTime="2057">in unique origins, their origin is known, </span><span class="line" data-startTime="2057">so we cannot really use that to make sure </span><span class="line" data-startTime="2063">that both sides of the postMessage interaction </span><span class="line" data-startTime="2063">are who they are. But still is the only way </span><span class="line" data-startTime="2070">we have to talk to a sandboxed iFrame, so </span><span class="line" data-startTime="2070">we are going to have to use it anyways. </span> <span class="line" data-startTime="2078">Inside the iFrame, we just need to get our </span><span class="line" data-startTime="2078">parent window and postMessage to that. Outside </span><span class="line" data-startTime="2083">the iFrame, we just need to actually find </span><span class="line" data-startTime="2083">the iFrame, get its content window and postMessage </span><span class="line" data-startTime="2088">to that. </span> <span class="line" data-startTime="2088">Now, again, the objective of sandboxed iFrames </span><span class="line" data-startTime="2097">is to be able to use script that we might </span><span class="line" data-startTime="2097">not be comfortable with accessing our origin </span><span class="line" data-startTime="2102">but we might need to use it to set up a particular </span><span class="line" data-startTime="2102">aspect of our application. In the case of </span><span class="line" data-startTime="2107">the document viewer, the script was displaying </span><span class="line" data-startTime="2107">the final document to a user, but it had no </span><span class="line" data-startTime="2112">need to access every single other document. </span></p>

<p><span class="line" data-startTime="2112">By running it in a unique origin, we guaranteed </span><span class="line" data-startTime="2120">that even if anything that &mdash; anything that </span><span class="line" data-startTime="2120">went wrong, even if something that we didn't </span><span class="line" data-startTime="2125">think could go wrong actually did go wrong, </span><span class="line" data-startTime="2125">there was no way for that code, even if it </span><span class="line" data-startTime="2131">was compromised, to access any other document. </span> <span class="line" data-startTime="2131">Which is a very good thing. You don't want </span><span class="line" data-startTime="2135">one malformed document that you want it to </span><span class="line" data-startTime="2135">see to steal every other single document that </span><span class="line" data-startTime="2142">you have. </span> <span class="line" data-startTime="2142">A very &mdash; other very important thing, more </span><span class="line" data-startTime="2148">don'ts. Security is filled with don'ts. If </span><span class="line" data-startTime="2148">we can both restrict the limitation of not </span><span class="line" data-startTime="2157">running script and the limitation of running </span><span class="line" data-startTime="2157">in a unique origin, we can do it, we can do </span><span class="line" data-startTime="2163">them both at the same time. However, if we </span><span class="line" data-startTime="2163">do them both at the same time, since the iFrame </span><span class="line" data-startTime="2170">will be living in the same origin as the enclosing </span><span class="line" data-startTime="2170">page and JavaScript will be allowed to run </span><span class="line" data-startTime="2177">inside the iFrame, there's nothing preventing </span><span class="line" data-startTime="2177">that JavaScript running inside the iFrame. </span></p>

<p><span class="line" data-startTime="2182">To get a reference to the actual iFrame, since </span><span class="line" data-startTime="2182">it's living in the same origin, and just take </span><span class="line" data-startTime="2186">the Sandbox out of it, out. So either never </span><span class="line" data-startTime="2186">use those two together, because again as with </span><span class="line" data-startTime="2194">unsafe inline and unsafe eval, you are completing </span><span class="line" data-startTime="2194">defeating the purpose of the sandbox in the </span><span class="line" data-startTime="2199">first place or make sure that the script that </span><span class="line" data-startTime="2199">you are including doesn't have code that can </span><span class="line" data-startTime="2208">do this. You might not &mdash; it's &mdash; you might </span><span class="line" data-startTime="2208">not be sure that your script will not fail </span><span class="line" data-startTime="2214">with a malformed office document, but you </span><span class="line" data-startTime="2214">can be sure that it's not actually searching </span><span class="line" data-startTime="2219">for iFrames and removing sandbox attributes. </span> <span class="line" data-startTime="2219">So sandbox iFrame don't. Please don't do this </span><span class="line" data-startTime="2224">because it defeats the purpose and as many </span><span class="line" data-startTime="2224">people say, a false sense of security is even </span><span class="line" data-startTime="2228">worse than being insecure. So please don't </span><span class="line" data-startTime="2228">do this. </span> <span class="line" data-startTime="2231">Now, I mentioned at the beginning of the talk </span><span class="line" data-startTime="2231">that I wanted to cover some common issues </span><span class="line" data-startTime="2236">and pitfalls that came up when people tried </span><span class="line" data-startTime="2236">to do this in actual applications and I'm </span><span class="line" data-startTime="2241">going to go over those real quick. </span></p>

<p><span class="line" data-startTime="2241">We talked about most the CSP restrictions, </span><span class="line" data-startTime="2246">the really only really &mdash; the only actual </span><span class="line" data-startTime="2246">pain point that we found was the use of eval </span><span class="line" data-startTime="2256">for templating (indiscernible) &mdash; everything </span><span class="line" data-startTime="2256">else, even if it takes some work, is just </span><span class="line" data-startTime="2260">a matter of constructing script and constructing </span><span class="line" data-startTime="2260">event handling from HTML files. It shouldn't </span><span class="line" data-startTime="2266">be impossible. We talked about how &mdash; about </span><span class="line" data-startTime="2266">how once we get stuff into a different origin </span><span class="line" data-startTime="2274">so that it doesn't have access to the user's </span><span class="line" data-startTime="2274">data, we need to talk to it as if it were </span><span class="line" data-startTime="2279">a different origin because it actually is, </span><span class="line" data-startTime="2279">so we need to use inter-origin communication </span><span class="line" data-startTime="2283">mechanisms such as postMessage. </span> <span class="line" data-startTime="2283">Now, I want to go over some weird interactions </span><span class="line" data-startTime="2290">that can happen when you use both CSP and </span><span class="line" data-startTime="2290">sandboxed iFrames at the same time, which </span><span class="line" data-startTime="2294">might not be evident when you start using </span><span class="line" data-startTime="2294">them, but it's good to know about them so </span><span class="line" data-startTime="2300">that you can know what to do when they actually </span><span class="line" data-startTime="2300">show up, if you decide to use that, which </span><span class="line" data-startTime="2303">you should. </span> <span class="line" data-startTime="2303">This is what the final manifest for the Chrome </span><span class="line" data-startTime="2310">OS document viewer roughly looks like. They </span><span class="line" data-startTime="2310">managed to implement both sandbox iFrames </span><span class="line" data-startTime="2315">and CSP in document viewer app, which makes </span><span class="line" data-startTime="2315">it really secure. I'm very happy opening a </span><span class="line" data-startTime="2320">file in &mdash; sorry &mdash; in the document viewer </span><span class="line" data-startTime="2320">because it means that the actual document </span><span class="line" data-startTime="2326">that I'm viewing has almost no access to anything </span><span class="line" data-startTime="2326">else on my system and that's something that's </span><span class="line" data-startTime="2331">very cool from a security standpoint, because </span><span class="line" data-startTime="2331">if anything goes wrong, there's nothing else </span><span class="line" data-startTime="2336">that can be accessed. Nothing can be stolen. </span></p>

<p><span class="line" data-startTime="2336">Nothing can be affected, which is cool. What </span><span class="line" data-startTime="2343">happens, the key thing to realize is that </span><span class="line" data-startTime="2343">once we get the sandbox iFrame inside a unique </span><span class="line" data-startTime="2349">origin, when that iFrame tries to load resources </span><span class="line" data-startTime="2349">from the browser's perspective, it will look </span><span class="line" data-startTime="2355">as if those requests came from outside the </span><span class="line" data-startTime="2355">extension. Because the iFrame is not going </span><span class="line" data-startTime="2363">to be living in the extensions origin. Now, </span><span class="line" data-startTime="2363">with manifest V1, you were allowed to load </span><span class="line" data-startTime="2369">everything you wanted from any origin. In </span><span class="line" data-startTime="2369">manifest V2, if an origin different from the </span><span class="line" data-startTime="2376">extensions or the apps origin tries to load </span><span class="line" data-startTime="2376">a resource from the app, the browser will </span><span class="line" data-startTime="2380">forbid that, and that's where Web access resources </span><span class="line" data-startTime="2380">come from. If we want to load from the session </span><span class="line" data-startTime="2388">package, we need to list it in Web accessible </span><span class="line" data-startTime="2388">resources. And also, this also applies not </span><span class="line" data-startTime="2397">only to the main Web accessible resources </span><span class="line" data-startTime="2397">line, it also applies to CSP. The things that </span><span class="line" data-startTime="2404">we're loading inside the sandbox iFrame, those </span><span class="line" data-startTime="2404">requests will not look as if they came from </span><span class="line" data-startTime="2412">the extension or the app. They will look as </span><span class="line" data-startTime="2412">if they came from a different origin. So CSP </span><span class="line" data-startTime="2418">will not allow those requests to go forward </span><span class="line" data-startTime="2418">by matching the "self" token in the CSP line. </span></p>

<p><span class="line" data-startTime="2427">It will actually need to match that to a different </span><span class="line" data-startTime="2427">line that will have Chrome extension URI as </span><span class="line" data-startTime="2434">&mdash; the Chrome extension URI as its URI. Now, </span><span class="line" data-startTime="2434">if you are running the new package apps that </span><span class="line" data-startTime="2444">come with the apps V2, that we introduced </span><span class="line" data-startTime="2444">for I/O, there's a slightly simpler way to </span><span class="line" data-startTime="2450">do this, which I'm not going to have time </span><span class="line" data-startTime="2450">to explain that talk. But there was a talk </span><span class="line" data-startTime="2455">on Wednesday that explained it in more depth, </span><span class="line" data-startTime="2455">and if anybody wants to learn about that, </span><span class="line" data-startTime="2461">please feel free to find me after the talk. </span> <span class="line" data-startTime="2461">But the core point to remember is that once </span><span class="line" data-startTime="2469">we manage to get stuff into the sandbox iFrame, </span><span class="line" data-startTime="2469">it's running inside and encouraging, then </span><span class="line" data-startTime="2474">it will have &mdash; it will live in origin for </span><span class="line" data-startTime="2474">everything, even for resource loading, and </span><span class="line" data-startTime="2479">that might need to have us change some of </span><span class="line" data-startTime="2479">the CSP policies that we are using. And again, </span><span class="line" data-startTime="2488">we're seeing that I'm using &mdash; or the document </span><span class="line" data-startTime="2488">viewer developers were URIs for images and </span><span class="line" data-startTime="2494">the reason that that happens is that not only </span><span class="line" data-startTime="2494">we kept script in a different origin from </span><span class="line" data-startTime="2499">our main application origin, we also put it </span><span class="line" data-startTime="2499">in a unique origin, which is slightly different </span><span class="line" data-startTime="2505">than just a different origin. Unique origins </span><span class="line" data-startTime="2505">cannot access any persistent local storage. </span></p>

<p><span class="line" data-startTime="2511">No HTML5 APIs, no persistent local storage. </span> <span class="line" data-startTime="2511">Now, imagine if you're obligation developer </span><span class="line" data-startTime="2518">and you had a great idea for a Chromized document </span><span class="line" data-startTime="2518">viewer, and you want to display documents </span><span class="line" data-startTime="2525">that might have images inside them. These </span><span class="line" data-startTime="2525">images are probably encoded inside the documents </span><span class="line" data-startTime="2530">in some way which we don't really care about, </span><span class="line" data-startTime="2530">but if you're not doing your processing, or </span><span class="line" data-startTime="2538">some of your processing inside the sandbox </span><span class="line" data-startTime="2538">iFrame, you need a way to get that information </span><span class="line" data-startTime="2544">inside the iFrame. You might be extracting </span><span class="line" data-startTime="2544">the images outside the iFrame, or even better, </span><span class="line" data-startTime="2550">in a different iFrame. And you need a way </span><span class="line" data-startTime="2550">to provide that &mdash; to get that information </span><span class="line" data-startTime="2558">inside the iFrame. Now, the only way you have </span><span class="line" data-startTime="2558">to actually communicate with the code inside </span><span class="line" data-startTime="2564">the iFrame is by using post message. So you </span><span class="line" data-startTime="2564">might say, well, I'll have to take the binary </span><span class="line" data-startTime="2569">data from the image, turn it into Base64, </span><span class="line" data-startTime="2569">ship it over using post message, decode it </span><span class="line" data-startTime="2575">back to binary inside the iFrame. That works. </span></p>

<p><span class="line" data-startTime="2575">Not very performant. You have two Base64 to </span><span class="line" data-startTime="2582">binary conversions that you don't really need, </span><span class="line" data-startTime="2582">and that's where typed arrays come in. JavaScript </span><span class="line" data-startTime="2591">actually can deal perfectly well with binary </span><span class="line" data-startTime="2591">data. You just create an array buffer, the </span><span class="line" data-startTime="2598">size you need in this case, 8 bytes, and then </span><span class="line" data-startTime="2598">you can cover that array buffer with different </span><span class="line" data-startTime="2605">what we call views which allow you to manipulate </span><span class="line" data-startTime="2605">that array buffer using different data types. </span> <span class="line" data-startTime="2611">In this case we can manipulate it either as </span><span class="line" data-startTime="2611">an array of signed bytes or as an array of </span><span class="line" data-startTime="2618">signed 32 bit, but the best way about &mdash; the </span><span class="line" data-startTime="2618">best thing array buffers is that they can </span><span class="line" data-startTime="2626">very easily be turned into objects that can </span><span class="line" data-startTime="2626">be loaded in the browser. If the code outside </span><span class="line" data-startTime="2635">the iFrame or inside a different iFrame sends </span><span class="line" data-startTime="2635">us an array buffer over post message, we can </span><span class="line" data-startTime="2641">easily turn it into a blob, and then we can </span><span class="line" data-startTime="2641">create a URL &mdash; a URL from that blob that </span><span class="line" data-startTime="2647">will look something like that. We don't really </span><span class="line" data-startTime="2647">care what it looks like. We really care about </span><span class="line" data-startTime="2652">the fact that it can be used as a source for </span><span class="line" data-startTime="2652">all sorts of tasks. This is how the document </span><span class="line" data-startTime="2657">viewer developers manage to do the parsing </span><span class="line" data-startTime="2657">of the documents in one sandbox, and displaying </span><span class="line" data-startTime="2666">in the document in a different sandbox, passing </span><span class="line" data-startTime="2666">binary data back and forth using a very efficient </span><span class="line" data-startTime="2672">mechanism that doesn't need any encoding whatsoever. </span></p>

<p><span class="line" data-startTime="2672">Not only that, once you get the blob URI inside </span><span class="line" data-startTime="2679">the sandbox, you can use it all the times </span><span class="line" data-startTime="2679">you want. It's a way of getting a URI pointing </span><span class="line" data-startTime="2686">directly to a chunk of bytes in the browser's </span><span class="line" data-startTime="2686">memory. This made possible to write a very </span><span class="line" data-startTime="2693">secure document viewer app and still keep </span><span class="line" data-startTime="2693">all the functionality that one would expect </span><span class="line" data-startTime="2699">from a document viewer. </span> <span class="line" data-startTime="2699">Now, I mostly talked about JavaScript today. </span> <span class="line" data-startTime="2708">Good news is that the Chrome platform also </span><span class="line" data-startTime="2708">includes a way of getting all these same security </span><span class="line" data-startTime="2713">guarantees for native code. There were a lot </span><span class="line" data-startTime="2713">of talks about (NaCl) Native Client, in I/O, </span><span class="line" data-startTime="2722">your &mdash; you will probably find them, the videos </span><span class="line" data-startTime="2722">online after I/O ends. (NaCl) allows you to </span><span class="line" data-startTime="2730">get all the same guaranties that we can give </span><span class="line" data-startTime="2730">for JavaScript code running inside a sandbox </span><span class="line" data-startTime="2735">iFrame for native code, native C or C++ code. </span> <span class="line" data-startTime="2735">And the best thing is that the communication </span><span class="line" data-startTime="2740">with this sandbox code uses the same interface </span><span class="line" data-startTime="2740">that you can use to talk to JavaScript which </span><span class="line" data-startTime="2746">is a post message based API. So you can get </span><span class="line" data-startTime="2746">the same guaranties that you can get with </span><span class="line" data-startTime="2752">sandbox JavaScript, no access to the application's </span><span class="line" data-startTime="2752">origin, using the same API. Your JavaScript </span><span class="line" data-startTime="2758">code can both talk to JavaScript or to native </span><span class="line" data-startTime="2758">code with the same security guaranties. Now, </span><span class="line" data-startTime="2766">take aways, and we'll move into questions. </span></p>

<p><span class="line" data-startTime="2766">Please, please, please, use CSP. Please. Let </span><span class="line" data-startTime="2775">Chrome, the browser, be the safety net. Just </span><span class="line" data-startTime="2775">make some very small changes, move scripts </span><span class="line" data-startTime="2783">out of HTML, removing line handling &mdash; inline </span><span class="line" data-startTime="2783">handling and stop worrying. As long as you </span><span class="line" data-startTime="2789">do stuff this way, the browser will take care </span><span class="line" data-startTime="2789">of not allowing malicious script to go through. </span> <span class="line" data-startTime="2797">This removes &mdash; this blocks most cases of </span><span class="line" data-startTime="2797">cross-site scripting. It does. Because a browser </span><span class="line" data-startTime="2803">can make sure that this doesn't happen in </span><span class="line" data-startTime="2803">only one place. You have to make sure it doesn't </span><span class="line" data-startTime="2808">happen in every single way &mdash; place you use </span><span class="line" data-startTime="2808">inner HTML or e-mail or server or everything. </span> <span class="line" data-startTime="2812">Let us let the browser help the app make sure </span><span class="line" data-startTime="2812">that this doesn't happen. And if you need </span><span class="line" data-startTime="2820">to run script that you're not comfortable </span><span class="line" data-startTime="2820">with, you don't really want it to be able </span><span class="line" data-startTime="2825">to access the application or the extension's </span><span class="line" data-startTime="2825">origin, put it in a sandbox iFrame. That's </span><span class="line" data-startTime="2831">what they are for. It will run very happily, </span><span class="line" data-startTime="2831">talk over post message, but if anything goes </span><span class="line" data-startTime="2836">wrong, it won't have any other privilege. </span></p>

<p><span class="line" data-startTime="2836">It won't be able to access anything in the </span><span class="line" data-startTime="2842">extension of the app's origin. That's a good </span><span class="line" data-startTime="2842">thing. </span> <span class="line" data-startTime="2846">Thank you for joining the session. </span> <span class="line" data-startTime="2846">[ Applause ] </span><span class="line" data-startTime="2851">Jorge Lucangeli Obes: That's my e-mail. </span> <span class="line" data-startTime="2851">My public Google+ account. The slides are </span><span class="line" data-startTime="2859">going to be posted. I saw some people taking </span><span class="line" data-startTime="2859">pictures of the slides. Don't worry. And, </span><span class="line" data-startTime="2865">yeah, we're open for questions. There's mics, </span><span class="line" data-startTime="2865">yeah. There's mics. </span></p>

<p class="speaker"><span class="line" data-starttime="2871"><span class="speakerName">Audience member</span>: Hey, so good talk. My question is a bit </span><span class="line" data-startTime="2871">of a tangent, though. Have you guys seen very </span><span class="line" data-startTime="2877">many actually malicious Chrome Apps or extensions? </span><span class="line" data-startTime="2877">Jorge Lucangeli Obes: We take out approximately </span><span class="line" data-startTime="2883">a dozen malicious extensions either per day </span><span class="line" data-startTime="2883">or per week from the Chrome store, yes. </span></p>

<p class="speaker"><span class="line" data-starttime="2890"><span class="speakerName">Audience member</span>: Okay. What kind of attack patterns do </span><span class="line" data-startTime="2890">they use in general, if can you tell us? </span><span class="line" data-startTime="2895">Jorge Lucangeli Obes: No. It's probably </span><span class="line" data-startTime="2895">better to contact press, yes. </span></p>

<p class="speaker"><span class="line" data-starttime="2900"><span class="speakerName">Audience member</span>: Okay. Okay. Fair enough. Thanks. </span><span class="line" data-startTime="2900">Jorge Lucangeli Obes: More questions? </span><span class="line" data-startTime="2905">No more questions? Don't be shy. </span></p>

<p class="speaker"><span class="line" data-starttime="2905"><span class="speakerName">Audience member</span>: So what's wrong with attributes that have </span><span class="line" data-startTime="2918">JavaScript code in them, if they're just in </span><span class="line" data-startTime="2918">the static source of the page, as opposed </span><span class="line" data-startTime="2925">to being injected via inner HTML or the DOM </span><span class="line" data-startTime="2925">API? </span><span class="line" data-startTime="2930">Jorge Lucangeli Obes: For the browser? </span><span class="line" data-startTime="2930">From the browser's perspective? </span><span class="line" data-startTime="2935">There's no difference. So the browser &mdash; the </span><span class="line" data-startTime="2935">browser doesn't know that the &mdash; the on mouse-over </span><span class="line" data-startTime="2944">script that I added in the first demo is actually </span><span class="line" data-startTime="2944">malicious. I want the browser to be able to </span><span class="line" data-startTime="2950">&mdash; I would like the browser to be able to </span><span class="line" data-startTime="2950">block anything that got injected by inner </span><span class="line" data-startTime="2956">HTML as opposed to stuff that got injected </span><span class="line" data-startTime="2956">&mdash; that got put there statically in the page. </span> <span class="line" data-startTime="2964">But there's &mdash; in reality, there's no way </span><span class="line" data-startTime="2964">of telling the difference. Once the DOM tree </span><span class="line" data-startTime="2968">gets built, it's the same thing. Right? </span><span class="line" data-startTime="2968">The thing to include using inner HTML becomes </span><span class="line" data-startTime="2975">part of the DOM tree just as everything else </span><span class="line" data-startTime="2975">you included statically in the page. So the </span><span class="line" data-startTime="2980">browser cannot really tell the difference </span><span class="line" data-startTime="2980">between those two scripts. We can &mdash; if &mdash; we </span><span class="line" data-startTime="2987">can discuss it after. </span></p>

<p></p>

<p class="speaker"><span class="line" data-starttime="2987"><span class="speakerName">Audience member</span>: Okay. Good idea. </span></p>

<p class="speaker"><span class="line" data-starttime="2992"><span class="speakerName">Audience member</span>: This question is more related to your </span><span class="line" data-startTime="2992">talk. So you talk about using the X content </span><span class="line" data-startTime="2997">security policy header in the talk. Recently </span><span class="line" data-startTime="2997">the IATF deprecated the X prefix for headers. </span><span class="line" data-startTime="3004">Do you know if Google is like trying to move </span><span class="line" data-startTime="3004">toward standardizing what that header is? </span><span class="line" data-startTime="3009">Jorge Lucangeli Obes: Eventually &mdash; no. </span><span class="line" data-startTime="3009">Eventually we want to standardize. I'm not </span><span class="line" data-startTime="3015">exactly sure what the timeline is for that, </span><span class="line" data-startTime="3015">but there's definitely people you can ask </span><span class="line" data-startTime="3022">that if you want to. I can tell who you can </span><span class="line" data-startTime="3022">ask. </span></p>

<p class="speaker"><span class="line" data-starttime="3025"><span class="speakerName">Audience member</span>: Okay. Sure. Thanks. </span><span class="line" data-startTime="3025">Jorge Lucangeli Obes: Right there. </span></p>

<p class="speaker"><span class="line" data-starttime="3029"><span class="speakerName">Audience member</span>: I'm curious if you know the status of </span><span class="line" data-startTime="3029">CSP support in browsers other than Chrome. </span><span class="line" data-startTime="3035">Jorge Lucangeli Obes: I don't. </span></p>

<p class="speaker"><span class="line" data-starttime="3035"><span class="speakerName">Audience member</span>: Kind of a continuation from that: What's </span><span class="line" data-startTime="3041">the status of this in the Android WebView? </span><span class="line" data-startTime="3041">Jorge Lucangeli Obes: That's a very good </span><span class="line" data-startTime="3045">question that should be asked to Android developers. </span><span class="line" data-startTime="3045">Yeah. </span></p>

<p class="speaker"><span class="line" data-starttime="3051"><span class="speakerName">Audience member</span>: Hey, sorry, look, I think a big raisin </span><span class="line" data-startTime="3051">for not allowing inline JavaScript is because </span><span class="line" data-startTime="3062">you're basically assuming that it's all malicious </span><span class="line" data-startTime="3062">and you've got this policy to say if it's </span><span class="line" data-startTime="3069">not &mdash; if any JavaScripts come from anywhere </span><span class="line" data-startTime="3069">else apart from where we said, malicious, </span><span class="line" data-startTime="3074">right, even if it isn't. Is there much effort </span><span class="line" data-startTime="3074">going into actually determining whether JavaScript </span><span class="line" data-startTime="3080">is malicious or not? </span><span class="line" data-startTime="3080">Jorge Lucangeli Obes: You probably run very, </span><span class="line" data-startTime="3084">very quickly into, like, halting problem stuff, </span><span class="line" data-startTime="3084">right? </span><span class="line" data-startTime="3088">That's basically the case. You cannot have </span><span class="line" data-startTime="3088">a way of telling what source code does that </span><span class="line" data-startTime="3093">is 100% accurate so &mdash; </span></p>

<p class="speaker"><span class="line" data-starttime="3093"><span class="speakerName">Audience member</span>: Yeah. </span><span class="line" data-startTime="3095">Jorge Lucangeli Obes: The only way to make </span><span class="line" data-startTime="3095">sure that &mdash; it goes back to the same thing: </span><span class="line" data-startTime="3101">For an attacker to win, you just need one </span><span class="line" data-startTime="3101">bug, and in order for the rest of the people </span><span class="line" data-startTime="3107">to win, you need to tie every single loose </span><span class="line" data-startTime="3107">end, and going down a path that basically </span><span class="line" data-startTime="3113">has a lot of false positives and false negatives, </span><span class="line" data-startTime="3113">and very hard rules, it's just opening the </span><span class="line" data-startTime="3118">door for not one bug, but a million bugs, </span><span class="line" data-startTime="3118">so we want to cut the problem from the root, </span><span class="line" data-startTime="3124">and since it's perfectly okay, there's no </span><span class="line" data-startTime="3124">major differences except for evil, let's just </span><span class="line" data-startTime="3132">do what's safe for the user. It's &mdash; it's </span><span class="line" data-startTime="3132">exactly the same. It's just &mdash; instead of </span><span class="line" data-startTime="3137">having in HTML, do it in JavaScript, instead </span><span class="line" data-startTime="3137">of having it in code, do it in our .js files, </span><span class="line" data-startTime="3143">and we can guaranty &mdash; we can guaranty, we </span><span class="line" data-startTime="3143">can say this is not going to is happen, ever, </span><span class="line" data-startTime="3147">ever, ever. No exceptions. </span></p>

<p class="speaker"><span class="line" data-starttime="3147"><span class="speakerName">Audience member</span>: Well, unless your JavaScript on your server </span><span class="line" data-startTime="3152">gets compromised. You can still be pulling </span><span class="line" data-startTime="3152">it in from trusted sources but it's been compromised </span><span class="line" data-startTime="3158">anyway. </span><span class="line" data-startTime="3158">Jorge Lucangeli Obes: Well, exactly, but, </span><span class="line" data-startTime="3160">I mean, since &mdash; it should &mdash; would have to </span><span class="line" data-startTime="3160">be compromised either in the Web site that </span><span class="line" data-startTime="3165">is serving over HTTPS or in the actual expansion </span><span class="line" data-startTime="3165">package, which is a couple of orders of magnitude </span><span class="line" data-startTime="3171">higher than just sitting at a Starbucks WiFi </span><span class="line" data-startTime="3171">and running something. </span></p>

<p class="speaker"><span class="line" data-starttime="3175"><span class="speakerName">Audience member</span>: Which sort of gives rise to actually checking </span><span class="line" data-startTime="3175">whether the JavaScript itself is malicious. </span><span class="line" data-startTime="3179">Jorge Lucangeli Obes: Yes. </span></p>

<p class="speaker"><span class="line" data-starttime="3179"><span class="speakerName">Audience member</span>: So you kind of need to do it eventually. </span><span class="line" data-startTime="3183">Jorge Lucangeli Obes: But again, tradeoff, </span><span class="line" data-startTime="3183">right? </span></p>

<p class="speaker"><span class="line" data-starttime="3185"><span class="speakerName">Audience member</span>: Yeah. </span><span class="line" data-startTime="3185">Jorge Lucangeli Obes: We can make sure that </span><span class="line" data-startTime="3188">by &mdash; there were some stats &mdash; there was a </span><span class="line" data-startTime="3188">very interesting paper by a group &mdash; a research </span><span class="line" data-startTime="3194">group at Berkeley that got published in the </span><span class="line" data-startTime="3194">beginning of 2012, by restricting inline JavaScript, </span><span class="line" data-startTime="3202">and restricting HTTPS or HTTP script loading, </span><span class="line" data-startTime="3202">you could completely eliminate 95% of all </span><span class="line" data-startTime="3212">the vulnerabilities in the top 100 extensions </span><span class="line" data-startTime="3212">in the Chrome Web store. Now, the tradeoff </span><span class="line" data-startTime="3219">for that is incredibly good. It's just a couple </span><span class="line" data-startTime="3219">of simple changes that are still best practices </span><span class="line" data-startTime="3228">for Web app development get rid of 95% of </span><span class="line" data-startTime="3228">the vulnerabilities. </span></p>

<p class="speaker"><span class="line" data-starttime="3231"><span class="speakerName">Audience member</span>: Yeah. </span><span class="line" data-startTime="3231">Jorge Lucangeli Obes: It's like we need </span><span class="line" data-startTime="3233">to do this. Guys, we need to do this. Guys </span><span class="line" data-startTime="3233">and girls, of course. </span></p>

<p class="speaker"><span class="line" data-starttime="3241"><span class="speakerName">Audience member</span>: Can we get &mdash; sorry. </span><span class="line" data-startTime="3241">Jorge Lucangeli Obes: That's okay. </span></p>

<p class="speaker"><span class="line" data-starttime="3244"><span class="speakerName">Audience member</span>: Can we get CSP to work in IE using Chrome </span><span class="line" data-startTime="3244">Frame, maybe? </span><span class="line" data-startTime="3247">Jorge Lucangeli Obes: That's a very good </span><span class="line" data-startTime="3247">question to which I don't know the answer </span><span class="line" data-startTime="3251">with, but I'm going find the answer because </span><span class="line" data-startTime="3251">it is a very good question. </span></p>

<p class="speaker"><span class="line" data-starttime="3254"><span class="speakerName">Audience member</span>: I'm following you so post it. </span><span class="line" data-startTime="3254">Jorge Lucangeli Obes: Okay. I'll post it. </span><span class="line" data-startTime="3260">Good. </span></p>

<p class="speaker"><span class="line" data-starttime="3260"><span class="speakerName">Audience member</span>: Great, thanks. </span></p>

<p class="speaker"><span class="line" data-starttime="3261"><span class="speakerName">Audience member</span>: So you mentioned that because of blocks </span><span class="line" data-startTime="3261">eval, you know, blocks templating use cases, </span><span class="line" data-startTime="3268">I think I did catch &mdash; so what's the alternative </span><span class="line" data-startTime="3268">do you do on something like client side templating? </span><span class="line" data-startTime="3271">Jorge Lucangeli Obes: So the alternative </span><span class="line" data-startTime="3271">&mdash; two alternatives: Number one, try to make </span><span class="line" data-startTime="3275">templating people more like from evil. Alternative </span><span class="line" data-startTime="3275">number two, if you are writing and one of </span><span class="line" data-startTime="3284">the new package apps for the Chrome platform, </span><span class="line" data-startTime="3284">this doesn't work in the drive-by Web, just </span><span class="line" data-startTime="3289">for the Chrome platform, you are able to say </span><span class="line" data-startTime="3289">in the manifest using the sandbox attribute </span><span class="line" data-startTime="3294">&mdash; in the manifest, not in the iFrame, in </span><span class="line" data-startTime="3294">the manifest, you are able to say this document, </span><span class="line" data-startTime="3301">when it's loaded inside an iFrame or in a </span><span class="line" data-startTime="3301">window, it should be put in something very </span><span class="line" data-startTime="3307">similar to a sandbox iFrame; however, in this </span><span class="line" data-startTime="3307">new sandbox document, you cannot remove the </span><span class="line" data-startTime="3318">same origin restriction. You cannot say, hey, </span><span class="line" data-startTime="3318">this has to live in the same origin. You cannot </span><span class="line" data-startTime="3323">do that. Since we don't allow that in the </span><span class="line" data-startTime="3323">Chrome platform version of sandbox iFrames, </span><span class="line" data-startTime="3329">we can't allow evil. What we don't want to </span><span class="line" data-startTime="3329">do is to say you can run evil and you can </span><span class="line" data-startTime="3335">also remove the same origin restriction. So </span><span class="line" data-startTime="3335">if you do it through the manifest, you can </span><span class="line" data-startTime="3340">apply a different kind of security policy </span><span class="line" data-startTime="3340">to that document you loaded inside the sandbox </span><span class="line" data-startTime="3346">&mdash; sandbox which can never ever live in the </span><span class="line" data-startTime="3346">same origin as your application. If you want </span><span class="line" data-startTime="3353">to go over the code, we can check it out outside. </span></p>

<p><span class="line" data-startTime="3353">But if you search for sandbox in the new version </span><span class="line" data-startTime="3360">2 documentation, it's right there. </span></p>

<p class="speaker"><span class="line" data-starttime="3360"><span class="speakerName">Audience member</span>: Okay. Thank you. </span><span class="line" data-startTime="3364">Jorge Lucangeli Obes: I think we are good </span><span class="line" data-startTime="3364">to go. Thank you. </span><span class="line" data-startTime="3370">[ Applause ] </span></p>