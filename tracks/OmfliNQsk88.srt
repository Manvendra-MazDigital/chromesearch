1
00:00:00,000 --> 00:00:00,376

2
00:00:00,376 --> 00:00:24,410
[SIDE CONVERSATION]

3
00:00:24,410 --> 00:02:58,416
[MUSIC PLAYING]

4
00:02:58,416 --> 00:03:06,899

5
00:03:06,899 --> 00:03:07,710
CARY CLARK: Hi.

6
00:03:07,710 --> 00:03:11,280
My name is Cary Clark, and I'm
a member of the Skia team.

7
00:03:11,280 --> 00:03:14,400
Skia provides the graphics
for Android, the Android

8
00:03:14,400 --> 00:03:17,720
framework, and for Chrome.

9
00:03:17,720 --> 00:03:21,880
Skia draws the rectangles, the
bitmaps, the text, and paths.

10
00:03:21,880 --> 00:03:24,290
That's what I'm going
to talk about today,

11
00:03:24,290 --> 00:03:28,520
paths and path ops.

12
00:03:28,520 --> 00:03:34,220
I started working at Apple a
long time ago, and at that

13
00:03:34,220 --> 00:03:39,510
time, the Apple II really
started my love of graphics.

14
00:03:39,510 --> 00:03:43,430
The Apple II had a high
resolution bitmap with a 280

15
00:03:43,430 --> 00:03:45,520
by 192 screen &mdash;

16
00:03:45,520 --> 00:03:47,210
it had a pair of
them, actually.

17
00:03:47,210 --> 00:03:50,440
And with that, the world
was my oyster.

18
00:03:50,440 --> 00:03:51,820
I could draw anything I wanted,

19
00:03:51,820 --> 00:03:54,260
and it was just amazing.

20
00:03:54,260 --> 00:03:56,370
Unfortunately, the Apple II
didn't really have any

21
00:03:56,370 --> 00:04:00,820
built-in graphics routines
at that time.

22
00:04:00,820 --> 00:04:04,290
Sometime later, when I was
introduced to the Lisa and the

23
00:04:04,290 --> 00:04:08,190
Macintosh computers, I learned
about QuickDraw, and QuickDraw

24
00:04:08,190 --> 00:04:12,290
is the software on a Macintosh,
on the original

25
00:04:12,290 --> 00:04:15,820
Macintosh, that drew
to the screen.

26
00:04:15,820 --> 00:04:19,970
QuickDraw had arcs, and that was
my first introduction into

27
00:04:19,970 --> 00:04:24,030
a computer that had a curved
primitive, a circular arc.

28
00:04:24,030 --> 00:04:26,530

29
00:04:26,530 --> 00:04:29,750
A little while later, the
Macintosh had the LaserWriter,

30
00:04:29,750 --> 00:04:32,670
which was a PostScript
printer.

31
00:04:32,670 --> 00:04:35,100
PostScript had a whole new class
of curves called cubic

32
00:04:35,100 --> 00:04:39,200
beziers, which were pretty
exotic, but they looked great,

33
00:04:39,200 --> 00:04:41,900
especially when they
were scaled up.

34
00:04:41,900 --> 00:04:46,070
And it was pretty mind-blowing
how well PostScript could take

35
00:04:46,070 --> 00:04:49,270
a document and rotate it
or skew it or scale it.

36
00:04:49,270 --> 00:04:53,070

37
00:04:53,070 --> 00:04:57,065
In 1988, TrueType, and a little
before that, QuickDraw

38
00:04:57,065 --> 00:04:58,470
GX came out.

39
00:04:58,470 --> 00:05:01,750
I was fortunate enough to
work on QuickDraw GX.

40
00:05:01,750 --> 00:05:06,980
And at that time, I decided to
add quadratics to QuickDraw

41
00:05:06,980 --> 00:05:10,000
instead of cubics or arcs.

42
00:05:10,000 --> 00:05:13,080
The quadratic is a little bit
simpler than a cube &mdash; it has

43
00:05:13,080 --> 00:05:16,580
one less control point, but
it has a lot of the same

44
00:05:16,580 --> 00:05:21,010
properties, and I was happy
that TrueType also chose

45
00:05:21,010 --> 00:05:24,400
quadratics and allowed me to
have some validation that my

46
00:05:24,400 --> 00:05:25,650
choice was a good one.

47
00:05:25,650 --> 00:05:28,390

48
00:05:28,390 --> 00:05:30,100
Skia has all of these types.

49
00:05:30,100 --> 00:05:33,290
It has arcs, it has cubics,
quadratics, and now it has

50
00:05:33,290 --> 00:05:37,390
conics, which are sections
of a cone, which include

51
00:05:37,390 --> 00:05:39,200
quadratics.

52
00:05:39,200 --> 00:05:42,890
And a path op is a way to take
all of these curves and

53
00:05:42,890 --> 00:05:44,510
operate on them with
set operations.

54
00:05:44,510 --> 00:05:48,000

55
00:05:48,000 --> 00:05:51,440
When QuickDraw was introduced
back in the '80s, it had a way

56
00:05:51,440 --> 00:05:53,800
of describing an area of the
screen that was called a

57
00:05:53,800 --> 00:05:57,260
region, and it was just a
collection of rectangles, but

58
00:05:57,260 --> 00:06:00,040
it was the basis for the
Macintosh windows and the

59
00:06:00,040 --> 00:06:02,200
windowing system.

60
00:06:02,200 --> 00:06:06,440
A little while later with
PostScript and QuickDraw GX

61
00:06:06,440 --> 00:06:11,040
and so forth, paths were
introduced, and paths, like

62
00:06:11,040 --> 00:06:13,220
regions, describe an
area of the screen.

63
00:06:13,220 --> 00:06:18,580
But that area can include
circles and triangles, and

64
00:06:18,580 --> 00:06:21,000
it's a control point
based area.

65
00:06:21,000 --> 00:06:23,850
So instead of a set of
rectangles, it's something

66
00:06:23,850 --> 00:06:26,935
that can have arbitrary curves
and arbitrary lines.

67
00:06:26,935 --> 00:06:29,840

68
00:06:29,840 --> 00:06:34,270
QuickDraw used its
rectangle-based path, its

69
00:06:34,270 --> 00:06:37,680
region, to build a
windowing system.

70
00:06:37,680 --> 00:06:41,320
And the windowing system allowed
QuickDraw to draw to

71
00:06:41,320 --> 00:06:43,810
just the part of the window
that was visible.

72
00:06:43,810 --> 00:06:48,920
The way it did this is it had
operations called region ops

73
00:06:48,920 --> 00:06:51,710
that could do things like
intersect a pair of regions or

74
00:06:51,710 --> 00:06:54,350
take the difference of
one from the other.

75
00:06:54,350 --> 00:06:57,940
This was a very powerful concept
that Bill Atkinson,

76
00:06:57,940 --> 00:07:01,850
the author of QuickDraw,
invented.

77
00:07:01,850 --> 00:07:04,690
I liked it so much that I wanted
to do the same thing

78
00:07:04,690 --> 00:07:06,000
for QuickDraw GX.

79
00:07:06,000 --> 00:07:09,390
But instead of just making it
work for rectangles, I wanted

80
00:07:09,390 --> 00:07:12,850
it to work for any arbitrary
geometry and be able to rotate

81
00:07:12,850 --> 00:07:16,040
or skew a path and
operate on it.

82
00:07:16,040 --> 00:07:20,080

83
00:07:20,080 --> 00:07:23,490
With ordinary paths &mdash; say,
a pair of ovals &mdash;

84
00:07:23,490 --> 00:07:26,420
it's very difficult to translate
those ovals from one

85
00:07:26,420 --> 00:07:28,230
graphic system to another.

86
00:07:28,230 --> 00:07:30,840
For instance, Skia can describe
a path with a pair of

87
00:07:30,840 --> 00:07:34,350
ovals, but to do a hardware
acceleration and translate

88
00:07:34,350 --> 00:07:39,080
those ovals to something like
OpenGL, it's difficult,

89
00:07:39,080 --> 00:07:42,160
because OpenGL doesn't have a
primitive that will describe

90
00:07:42,160 --> 00:07:44,550
those curves.

91
00:07:44,550 --> 00:07:49,480
Worse, if each oval individually
is sent to

92
00:07:49,480 --> 00:07:54,180
OpenGL, the pair of curves may
not blend together well.

93
00:07:54,180 --> 00:07:57,310
If either one has transparency,
then you'll see

94
00:07:57,310 --> 00:08:00,060
the transparent addition of the
two rather than just the

95
00:08:00,060 --> 00:08:02,620
area that the two describe.

96
00:08:02,620 --> 00:08:08,290
That's why OpenGL systems often
create stencil buffers

97
00:08:08,290 --> 00:08:11,655
that have the bitmap that
describes, in this case, a

98
00:08:11,655 --> 00:08:15,480
pair of ovals and uploads that
rather than uploading the

99
00:08:15,480 --> 00:08:17,070
geometry of those
pair of ovals.

100
00:08:17,070 --> 00:08:20,920

101
00:08:20,920 --> 00:08:25,850
The Blink portion of Chrome that
reads into the HTML web

102
00:08:25,850 --> 00:08:29,580
page can create some very
complicated geometries.

103
00:08:29,580 --> 00:08:35,240
CSS allows defining different
gradients for different parts

104
00:08:35,240 --> 00:08:37,360
of a rounded rectangle,
for instance.

105
00:08:37,360 --> 00:08:39,200
So the clip might look
something like this

106
00:08:39,200 --> 00:08:40,659
illustration.

107
00:08:40,659 --> 00:08:44,770
That clip is only the portion
of the gray &mdash;

108
00:08:44,770 --> 00:08:47,110
is the only portion that's
actually drawn.

109
00:08:47,110 --> 00:08:51,960
But the clip contains all the
other shapes as well.

110
00:08:51,960 --> 00:08:55,180
It's difficult to do an
acceleration of just the

111
00:08:55,180 --> 00:08:58,290
portion that's being drawn when
all the other geometries

112
00:08:58,290 --> 00:08:59,590
are present in the clip stack.

113
00:08:59,590 --> 00:09:03,610

114
00:09:03,610 --> 00:09:09,360
Blink also allows drawing the
difference of a shape.

115
00:09:09,360 --> 00:09:16,410
So when going from Skia to PDF,
for instance, we have to

116
00:09:16,410 --> 00:09:21,280
draw the PDF data into an
off-screen bitmap and render

117
00:09:21,280 --> 00:09:24,580
that instead of being able to
calculate the geometry that

118
00:09:24,580 --> 00:09:27,420
would result from subtracting
a rectangle

119
00:09:27,420 --> 00:09:28,670
from another rectangle.

120
00:09:28,670 --> 00:09:31,290

121
00:09:31,290 --> 00:09:34,950
Shape ops tries to address
this need.

122
00:09:34,950 --> 00:09:38,750
Here, this simplify operation
takes a pair of blue

123
00:09:38,750 --> 00:09:43,850
rectangles and will compute
the area that would result

124
00:09:43,850 --> 00:09:46,150
from drawing both of them.

125
00:09:46,150 --> 00:09:47,970
This is the simplest path op.

126
00:09:47,970 --> 00:09:51,018

127
00:09:51,018 --> 00:09:56,270
Path ops also have binary
operations to compare paths.

128
00:09:56,270 --> 00:09:58,920
So in this case, we're computing
the intersection of

129
00:09:58,920 --> 00:10:01,610
a pair of rectangles from
two separate rectangles.

130
00:10:01,610 --> 00:10:05,181

131
00:10:05,181 --> 00:10:09,200
The union operator looks a lot
like the simplify operator.

132
00:10:09,200 --> 00:10:13,080
It uses two paths, each with a
single contour, instead of one

133
00:10:13,080 --> 00:10:14,760
path with two contours.

134
00:10:14,760 --> 00:10:20,090
A contour is a closed portion
of a path, so it's a

135
00:10:20,090 --> 00:10:21,450
continuous closed loop.

136
00:10:21,450 --> 00:10:24,020

137
00:10:24,020 --> 00:10:25,850
There's a pair of difference
operators.

138
00:10:25,850 --> 00:10:28,900
This difference operator
subtracts the dark green

139
00:10:28,900 --> 00:10:30,170
rectangle from the blue one.

140
00:10:30,170 --> 00:10:33,800
There's a reverse difference
that would subtract the blue

141
00:10:33,800 --> 00:10:35,070
rectangle from the
dark green one.

142
00:10:35,070 --> 00:10:37,750

143
00:10:37,750 --> 00:10:40,300
For completeness, there's also
exclusive or, although this

144
00:10:40,300 --> 00:10:41,550
one isn't used very much.

145
00:10:41,550 --> 00:10:44,990

146
00:10:44,990 --> 00:10:47,600
And finally, there's complement,
which describes

147
00:10:47,600 --> 00:10:51,550
all of the area that's
outside of a path.

148
00:10:51,550 --> 00:10:53,890
As it turns out, there's
no special function for

149
00:10:53,890 --> 00:10:59,610
complement because Skia's paths
have a way of describing

150
00:10:59,610 --> 00:11:02,190
whether it's the fill
or the inverse fill.

151
00:11:02,190 --> 00:11:05,635
So the complement is just
toggling those two attributes.

152
00:11:05,635 --> 00:11:09,490

153
00:11:09,490 --> 00:11:12,430
There's no reason to implement
all of these path ops as

154
00:11:12,430 --> 00:11:14,600
separate functions since
they're really

155
00:11:14,600 --> 00:11:16,590
all the same thing.

156
00:11:16,590 --> 00:11:21,860
In this illustration, we have
the paths A and B and their

157
00:11:21,860 --> 00:11:25,830
complements running down the
column on the left and

158
00:11:25,830 --> 00:11:28,900
different path operations
running in the

159
00:11:28,900 --> 00:11:30,800
row across the top.

160
00:11:30,800 --> 00:11:34,780
So you can see that the
intersection of A and B is the

161
00:11:34,780 --> 00:11:41,610
same as the difference of A
complement B, or the exclusive

162
00:11:41,610 --> 00:11:46,590
or of A and B is the same as the
union of A minus B and B

163
00:11:46,590 --> 00:11:52,770
minus A is also the difference
between the

164
00:11:52,770 --> 00:11:54,020
intersection and the union.

165
00:11:54,020 --> 00:11:57,900

166
00:11:57,900 --> 00:11:59,820
So what's all this good for?

167
00:11:59,820 --> 00:12:02,540
Back when fonts were originally
ported to

168
00:12:02,540 --> 00:12:06,600
computers, a lot of times the
complex characters were

169
00:12:06,600 --> 00:12:09,600
created by drawing individual
characters on top of each

170
00:12:09,600 --> 00:12:14,040
other, like a slash on top of
the letter O. If you drew the

171
00:12:14,040 --> 00:12:16,110
outline of those characters,
you'd get an undesirable

172
00:12:16,110 --> 00:12:19,780
result as shown here because you
would see both outlines at

173
00:12:19,780 --> 00:12:24,280
the same time where you'd really
like to see only the

174
00:12:24,280 --> 00:12:28,650
portion described by the area
of the two characters.

175
00:12:28,650 --> 00:12:32,420
So the question is how do we
get from there to here?

176
00:12:32,420 --> 00:12:36,280
When I first wrote this in the
'80s, my approach was very

177
00:12:36,280 --> 00:12:38,670
similar to the way I drew
these characters.

178
00:12:38,670 --> 00:12:40,120
I would start by finding
the maxima and

179
00:12:40,120 --> 00:12:43,510
minima of the curves.

180
00:12:43,510 --> 00:12:46,620
Once they were split, I would
then find all the vertical

181
00:12:46,620 --> 00:12:50,100
occurrences where either a new
curve started, a new curve

182
00:12:50,100 --> 00:12:53,210
stopped, or a pair of
intersections occurred.

183
00:12:53,210 --> 00:12:56,930

184
00:12:56,930 --> 00:12:59,750
Given all those vertical events,
I would sort them and

185
00:12:59,750 --> 00:13:02,990
then walk across them
horizontally and find every

186
00:13:02,990 --> 00:13:05,830
place where one of the
curves intersected

187
00:13:05,830 --> 00:13:07,490
that horizontal line.

188
00:13:07,490 --> 00:13:09,200
Then I would have to
sort those as well.

189
00:13:09,200 --> 00:13:12,300

190
00:13:12,300 --> 00:13:16,220
Finally, if a pair of curves or
a line and a curve had the

191
00:13:16,220 --> 00:13:22,060
same y value for some given x
value, I had to sort those to

192
00:13:22,060 --> 00:13:24,090
know which one would
contribute to

193
00:13:24,090 --> 00:13:25,340
the final path first.

194
00:13:25,340 --> 00:13:28,300

195
00:13:28,300 --> 00:13:31,680
All of the sorting is required
because of something called

196
00:13:31,680 --> 00:13:33,060
the winding number rule.

197
00:13:33,060 --> 00:13:36,370
And the winding number rule says
that the direction of the

198
00:13:36,370 --> 00:13:41,670
path describes whether it
contributes or subtracts from

199
00:13:41,670 --> 00:13:43,190
the output.

200
00:13:43,190 --> 00:13:47,670
So in this case, the down arrows
contribute a plus 1 to

201
00:13:47,670 --> 00:13:50,030
the answer and the up
arrows contribute a

202
00:13:50,030 --> 00:13:53,250
minus 1 to the answer.

203
00:13:53,250 --> 00:13:55,910
If I sum those numbers as I
move across from left to

204
00:13:55,910 --> 00:13:59,900
right, every time that a 0
changes to a 1 or a 1 changes

205
00:13:59,900 --> 00:14:03,240
to a 0, that's a line
that I keep.

206
00:14:03,240 --> 00:14:06,160
If it changes from one positive
number to another,

207
00:14:06,160 --> 00:14:08,550
those are lines I discard.

208
00:14:08,550 --> 00:14:11,000
That will give me the desired
output that I want.

209
00:14:11,000 --> 00:14:14,470

210
00:14:14,470 --> 00:14:17,470
This time around, it occurred
to me that all that sorting

211
00:14:17,470 --> 00:14:20,190
was a lot of work and took a
lot of time, and there was

212
00:14:20,190 --> 00:14:21,830
probably a simpler approach.

213
00:14:21,830 --> 00:14:24,290
In fact, there are really only
eight intersection points

214
00:14:24,290 --> 00:14:27,220
between these pairs of curves
and lines that I

215
00:14:27,220 --> 00:14:29,020
actually care about.

216
00:14:29,020 --> 00:14:31,600
All the other sorting
information is superfluous to

217
00:14:31,600 --> 00:14:32,850
the real answer.

218
00:14:32,850 --> 00:14:34,950

219
00:14:34,950 --> 00:14:38,220
If I look at any one of those
intersections, instead of

220
00:14:38,220 --> 00:14:41,030
thinking about how the y-number
is affected as I

221
00:14:41,030 --> 00:14:44,530
traverse across the entire shape
from left to right, I

222
00:14:44,530 --> 00:14:47,420
can think about what the winding
number contribution is

223
00:14:47,420 --> 00:14:52,050
at that intersection point as
I move around in a circle.

224
00:14:52,050 --> 00:14:57,620
If I know what the intersection
is as each curve

225
00:14:57,620 --> 00:15:02,116
contributes to the answer, once
again, when 0 moves to 1

226
00:15:02,116 --> 00:15:05,350
or 1 moves to 0, those
are lines I keep.

227
00:15:05,350 --> 00:15:07,730
But when it goes from one
positive number to the next,

228
00:15:07,730 --> 00:15:08,980
those are lines I discard.

229
00:15:08,980 --> 00:15:12,790

230
00:15:12,790 --> 00:15:16,600
The great benefit of this is
once I have one answer, that

231
00:15:16,600 --> 00:15:19,740
answer propagates around the
rest of the curve so I don't

232
00:15:19,740 --> 00:15:24,400
need to keep computing the
inside or outsideness of the

233
00:15:24,400 --> 00:15:27,640
shape, and I can keep all of
the information all the way

234
00:15:27,640 --> 00:15:29,535
around to the point I run into
another intersection.

235
00:15:29,535 --> 00:15:33,530

236
00:15:33,530 --> 00:15:36,240
But before I can get there, I
have to be able to find the

237
00:15:36,240 --> 00:15:38,720
intersections.

238
00:15:38,720 --> 00:15:41,110
So let's take a look at one
of the curve types.

239
00:15:41,110 --> 00:15:44,350
This is a quadratic bezier
defined by a couple of control

240
00:15:44,350 --> 00:15:49,820
points on the ends and one
control point in the middle.

241
00:15:49,820 --> 00:15:54,670
The quadratic bezier is parallel
to the end points.

242
00:15:54,670 --> 00:15:57,580
The tangents of the quadratic
bezier from the first to the

243
00:15:57,580 --> 00:16:00,225
second point define how
the curve groups.

244
00:16:00,225 --> 00:16:03,200

245
00:16:03,200 --> 00:16:06,550
A pair of quadratic beziers
are portions of a pair of

246
00:16:06,550 --> 00:16:08,630
parabolas, so they can
intersect in as

247
00:16:08,630 --> 00:16:11,960
many as four points.

248
00:16:11,960 --> 00:16:14,180
So that's a clue as to what the
answer's going to be to

249
00:16:14,180 --> 00:16:16,560
find the intersection of
a pair of quadratics.

250
00:16:16,560 --> 00:16:19,360
I'll need to be able to find
at least four solutions.

251
00:16:19,360 --> 00:16:21,920
So if there is a solution, it's
going to have to be able

252
00:16:21,920 --> 00:16:23,170
to find four roots.

253
00:16:23,170 --> 00:16:26,500

254
00:16:26,500 --> 00:16:28,830
Back in the original
illustration, I mentioned that

255
00:16:28,830 --> 00:16:32,640
I have to divide the curves
into a pair &mdash;

256
00:16:32,640 --> 00:16:35,960
I had to divide the curves at a
maxima and a minima before I

257
00:16:35,960 --> 00:16:37,790
could proceed.

258
00:16:37,790 --> 00:16:40,570
This is because everything
was sorted in y.

259
00:16:40,570 --> 00:16:43,810
The first time I did this, I
thought that also meant that

260
00:16:43,810 --> 00:16:46,690
it simplified the solution
for the intersection

261
00:16:46,690 --> 00:16:48,320
of a pair of curves.

262
00:16:48,320 --> 00:16:51,440
I thought if there are four
intersections for a pair of

263
00:16:51,440 --> 00:16:54,560
parabolas, surely there are
only two intersections if

264
00:16:54,560 --> 00:16:58,990
they're subdivided so they
only increase in y.

265
00:16:58,990 --> 00:17:00,430
I was wrong.

266
00:17:00,430 --> 00:17:03,280
There are three intersections
for monotonically increasing

267
00:17:03,280 --> 00:17:06,540
curves, and this was quite
embarrassing when I figured it

268
00:17:06,540 --> 00:17:09,420
out for the first time
back in the '80s.

269
00:17:09,420 --> 00:17:11,980
So this time around, I decided
to be much more careful about

270
00:17:11,980 --> 00:17:15,260
the mathematics and the geometry
so I wouldn't fall

271
00:17:15,260 --> 00:17:16,770
into the same sort
of mistake again.

272
00:17:16,770 --> 00:17:20,619

273
00:17:20,619 --> 00:17:25,220
So let's take a look at
intersecting a pair of curves.

274
00:17:25,220 --> 00:17:28,650
For these curves, I want to find
the intersection and I

275
00:17:28,650 --> 00:17:33,200
want to do so by creating the
mathematics that will solve

276
00:17:33,200 --> 00:17:35,600
the answer directly.

277
00:17:35,600 --> 00:17:37,640
Another approach would be to
subdivide the curves, but

278
00:17:37,640 --> 00:17:38,980
we'll talk about that
in just a moment.

279
00:17:38,980 --> 00:17:42,750

280
00:17:42,750 --> 00:17:46,470
If I look at what the solution
is without looking at how I'm

281
00:17:46,470 --> 00:17:49,030
going to get there, I can
imagine that there's a value

282
00:17:49,030 --> 00:17:55,010
called t which varies
from 0 to 1 as I

283
00:17:55,010 --> 00:17:56,260
traverse across the curve.

284
00:17:56,260 --> 00:17:59,830

285
00:17:59,830 --> 00:18:03,610
When t is equal to 0,
it's going to be at

286
00:18:03,610 --> 00:18:05,470
the C0 and C0 prime.

287
00:18:05,470 --> 00:18:08,085
When t is at 1, it's
going to be at C2.

288
00:18:08,085 --> 00:18:10,940
And anywhere in between, it's
going to describe a point

289
00:18:10,940 --> 00:18:13,340
along the curve.

290
00:18:13,340 --> 00:18:18,850
So for these sample pieces of
data, the t is a 1.25 for one

291
00:18:18,850 --> 00:18:21,390
curve and 0.623 for the other.

292
00:18:21,390 --> 00:18:23,750
And when I plug the t into some
equation, I'll get the

293
00:18:23,750 --> 00:18:25,625
same intersection point
for both curves.

294
00:18:25,625 --> 00:18:28,440

295
00:18:28,440 --> 00:18:32,620
In Skia, by the way, the y
point's down instead of up, so

296
00:18:32,620 --> 00:18:34,520
things may look a little upside
down from the math

297
00:18:34,520 --> 00:18:35,770
you're used to.

298
00:18:35,770 --> 00:18:38,550

299
00:18:38,550 --> 00:18:43,570
So let's get back to solving
curves by subdividing.

300
00:18:43,570 --> 00:18:46,330
This solution is the one that I
used originally in the '80s,

301
00:18:46,330 --> 00:18:48,800
and it's very popular today as
well, and there's been a lot

302
00:18:48,800 --> 00:18:52,760
of work to optimize this such as
the work by T. W. Sederberg

303
00:18:52,760 --> 00:19:00,730
at BYU using convex hulls
to optimize subdivision.

304
00:19:00,730 --> 00:19:04,300
I found this solution ultimately
unworkable because

305
00:19:04,300 --> 00:19:08,530
it falls down when two curves
are very close to the same.

306
00:19:08,530 --> 00:19:12,540
In this case, every time the
curves are subdivided, the

307
00:19:12,540 --> 00:19:15,220
pair of curves are still
very close to the same.

308
00:19:15,220 --> 00:19:18,190
And even though they don't
touch each other, it's

309
00:19:18,190 --> 00:19:21,520
impossible to tell without
further subdivision.

310
00:19:21,520 --> 00:19:26,590
So I found in this case that it
was a very long tail before

311
00:19:26,590 --> 00:19:29,650
I would know whether or not
the solution was found.

312
00:19:29,650 --> 00:19:31,500
So this is a solution I
tried and abandoned.

313
00:19:31,500 --> 00:19:34,260

314
00:19:34,260 --> 00:19:37,110
So going back to the math
approach, this is the

315
00:19:37,110 --> 00:19:41,320
Bernstein equation for a
quadratic bezier, and it

316
00:19:41,320 --> 00:19:44,710
simply describes the x and y
values for some value of t

317
00:19:44,710 --> 00:19:46,960
from 0 to 1.

318
00:19:46,960 --> 00:19:49,900
As I said before, if t is
0, the answer is C0.

319
00:19:49,900 --> 00:19:52,635
If t is 1, the answer is C2.

320
00:19:52,635 --> 00:19:55,030
And if the t is any
other value, it's

321
00:19:55,030 --> 00:19:58,320
somewhere along the curve.

322
00:19:58,320 --> 00:20:02,480
The simplified form of the
equation collects the values

323
00:20:02,480 --> 00:20:07,430
together so that now I have a
simple quadratic which is very

324
00:20:07,430 --> 00:20:08,680
easy to solve.

325
00:20:08,680 --> 00:20:11,150

326
00:20:11,150 --> 00:20:13,220
The implicit form of the
equation is a little more

327
00:20:13,220 --> 00:20:17,950
complicated, but it describes an
entire parabola instead of

328
00:20:17,950 --> 00:20:22,660
the quadratic section which is
a piece of that parabola.

329
00:20:22,660 --> 00:20:25,240
Even though the math looks
daunting, it turns out there's

330
00:20:25,240 --> 00:20:28,750
enough common terms that it only
takes about 28 multiplies

331
00:20:28,750 --> 00:20:31,460
and 11 adds to get from
the simple form to

332
00:20:31,460 --> 00:20:32,710
the implicit form.

333
00:20:32,710 --> 00:20:35,550

334
00:20:35,550 --> 00:20:40,010
Once I have both the implicit
and parametric forms of the

335
00:20:40,010 --> 00:20:43,900
equation, I can plug
one into the other.

336
00:20:43,900 --> 00:20:48,080
So I can take the second
equation, which describes how

337
00:20:48,080 --> 00:20:52,900
x and y are in terms of t, and
I can plug that answer into

338
00:20:52,900 --> 00:20:57,160
the third equation to get rid
of the t altogether and have

339
00:20:57,160 --> 00:21:02,250
something I can solve for t.

340
00:21:02,250 --> 00:21:06,230
Once I have the quartic
equation, now I can find the

341
00:21:06,230 --> 00:21:08,820
solution that will give me
the intersection of one

342
00:21:08,820 --> 00:21:10,040
curve with the other.

343
00:21:10,040 --> 00:21:14,390
But this just gets me the t
values for the first curve.

344
00:21:14,390 --> 00:21:18,950
I have to do the reverse and
plug the second equation into

345
00:21:18,950 --> 00:21:23,340
the first in order to get the
complement, in order to get

346
00:21:23,340 --> 00:21:26,580
the t values for the
prime equation.

347
00:21:26,580 --> 00:21:29,860
Once I have the t values for
both equations, I can plug

348
00:21:29,860 --> 00:21:34,330
them in and ensure that they
return the same x and y values

349
00:21:34,330 --> 00:21:35,580
for each of the quadratics.

350
00:21:35,580 --> 00:21:38,470

351
00:21:38,470 --> 00:21:40,950
Since I have a quadratic
solution that's robust and

352
00:21:40,950 --> 00:21:43,970
works well, you might think I
would also be able to use that

353
00:21:43,970 --> 00:21:45,990
same solution for cubics.

354
00:21:45,990 --> 00:21:48,170
After all, cubics are just
quadratics with one more

355
00:21:48,170 --> 00:21:50,635
control point, so they can't be
that much more complicated.

356
00:21:50,635 --> 00:21:53,790

357
00:21:53,790 --> 00:21:56,140
Here's the Bernstein polynomial
for a cubic

358
00:21:56,140 --> 00:21:59,680
equation, which looks a lot
like the quadratic one.

359
00:21:59,680 --> 00:22:01,880
It just has one more
term, and this has

360
00:22:01,880 --> 00:22:03,130
cubes instead of squares.

361
00:22:03,130 --> 00:22:06,460

362
00:22:06,460 --> 00:22:10,070
If I overlay a pair of cubics
on top of each other, I'll

363
00:22:10,070 --> 00:22:14,230
find that they can have as many
as nine intersections,

364
00:22:14,230 --> 00:22:17,960
and this ought to set off alarm
bells because it's going

365
00:22:17,960 --> 00:22:21,010
to be very hard to find nine
roots for an equation.

366
00:22:21,010 --> 00:22:23,900

367
00:22:23,900 --> 00:22:26,940
If I plug the equation into
Mathematica, I get a rather

368
00:22:26,940 --> 00:22:29,020
daunting-looking result.

369
00:22:29,020 --> 00:22:31,620
And notice that this still has
everything in terms of x and

370
00:22:31,620 --> 00:22:34,950
y, so this is not the
complete solution.

371
00:22:34,950 --> 00:22:35,780
This is half of it &mdash;

372
00:22:35,780 --> 00:22:38,910
I still have to plug all of the
x and y values from the

373
00:22:38,910 --> 00:22:41,700
alternate equation into
this equation.

374
00:22:41,700 --> 00:22:44,370
So things are looking sad
for solving cubics with

375
00:22:44,370 --> 00:22:45,620
mathematics.

376
00:22:45,620 --> 00:22:47,620

377
00:22:47,620 --> 00:22:50,930
Sure enough, if I work all the
way through, I'll end up with

378
00:22:50,930 --> 00:22:53,240
a ninth ordered equation
for which there

379
00:22:53,240 --> 00:22:55,250
is no general solution.

380
00:22:55,250 --> 00:22:57,630
And even though there's a lot
of advancements in root

381
00:22:57,630 --> 00:23:01,020
finding and computers are much
faster than they were 25 years

382
00:23:01,020 --> 00:23:04,830
ago, people haven't got a whole
lot smarter, so this

383
00:23:04,830 --> 00:23:08,030
sort of equation is impossible
to solve

384
00:23:08,030 --> 00:23:10,130
directly in a robust manner.

385
00:23:10,130 --> 00:23:13,330

386
00:23:13,330 --> 00:23:16,100
So let's take a look
at the cubic again.

387
00:23:16,100 --> 00:23:20,010
This cubic intersects itself, so
not only do I need to find

388
00:23:20,010 --> 00:23:22,720
how the cubic intersects another
cubic, but I need to

389
00:23:22,720 --> 00:23:24,860
know its own intersection.

390
00:23:24,860 --> 00:23:27,180
This gives me a clue as to
how I might solve the

391
00:23:27,180 --> 00:23:28,430
intersection.

392
00:23:28,430 --> 00:23:30,090

393
00:23:30,090 --> 00:23:33,160
Rather than try to solve the
cubic directly, I can

394
00:23:33,160 --> 00:23:36,440
approximate it with a series of
quadratics and then use my

395
00:23:36,440 --> 00:23:40,170
quadratic intersection to find
the actual solution.

396
00:23:40,170 --> 00:23:43,650
Once I get the intersection
values in t with quadratics, I

397
00:23:43,650 --> 00:23:46,930
can take those same t values
and apply them back to the

398
00:23:46,930 --> 00:23:49,810
cubic and then check to
see if they return the

399
00:23:49,810 --> 00:23:52,490
same x and y value.

400
00:23:52,490 --> 00:23:54,360
This turns out to be a pretty
robust solution

401
00:23:54,360 --> 00:23:55,610
that works very well.

402
00:23:55,610 --> 00:23:59,930

403
00:23:59,930 --> 00:24:02,930
So here's a pair of cubics
that intersect each other

404
00:24:02,930 --> 00:24:04,990
connected to a line.

405
00:24:04,990 --> 00:24:07,540
For lines in cubics and lines
and the lines and the lines in

406
00:24:07,540 --> 00:24:10,020
quadratics, I can solve
those directly.

407
00:24:10,020 --> 00:24:12,570
I don't have to do
any special math.

408
00:24:12,570 --> 00:24:16,750
So this line does not intersect
cubic one &mdash; it just

409
00:24:16,750 --> 00:24:17,940
misses touching it &mdash;

410
00:24:17,940 --> 00:24:19,660
but the pair of cubics
intersect each other.

411
00:24:19,660 --> 00:24:22,370

412
00:24:22,370 --> 00:24:26,310
When I approximate one cubic
with a quadratic, the

413
00:24:26,310 --> 00:24:30,600
quadratic approximation is very
close, which is fine.

414
00:24:30,600 --> 00:24:33,040
It's just exactly what
I want it to be.

415
00:24:33,040 --> 00:24:35,640
The cubic continues off to the
right, and as the cubic

416
00:24:35,640 --> 00:24:38,430
continues, the quadratic
approximation drifts a little

417
00:24:38,430 --> 00:24:42,330
bit further away,
but not too far.

418
00:24:42,330 --> 00:24:45,950
But for the first cubic, its
endpoints are far off the

419
00:24:45,950 --> 00:24:49,780
screen, and so the quadratic
approximation at this point is

420
00:24:49,780 --> 00:24:51,490
the furthest it ever gets
from the cubic.

421
00:24:51,490 --> 00:24:55,380

422
00:24:55,380 --> 00:24:59,240
So even though the line does not
intersect the cubic, it's

423
00:24:59,240 --> 00:25:02,000
also the case that the pair of
quadratics do not intersect

424
00:25:02,000 --> 00:25:04,240
each other.

425
00:25:04,240 --> 00:25:06,610
So using a straightforward
solution, I miss this

426
00:25:06,610 --> 00:25:08,940
intersection altogether,
and my path ops

427
00:25:08,940 --> 00:25:10,190
produce the wrong result.

428
00:25:10,190 --> 00:25:12,980

429
00:25:12,980 --> 00:25:16,580
To find the intersection of the
cubics, I have to rely on

430
00:25:16,580 --> 00:25:18,050
the convex hull.

431
00:25:18,050 --> 00:25:20,540
The convex hull is what happens
when you connect all

432
00:25:20,540 --> 00:25:22,160
the control points of
the cubic together.

433
00:25:22,160 --> 00:25:25,830
It describes a polygon around
which the cubic is guaranteed

434
00:25:25,830 --> 00:25:27,600
to be contained by.

435
00:25:27,600 --> 00:25:30,550
If I look at the very end of
the convex hull, these tiny

436
00:25:30,550 --> 00:25:34,430
little line segments, then I can
find the intersections of

437
00:25:34,430 --> 00:25:38,430
those lines with the opposing
cubic and use that to find the

438
00:25:38,430 --> 00:25:40,710
intersections of the
pair of cubics.

439
00:25:40,710 --> 00:25:43,100
Since I only have to do this
at the very ends of the

440
00:25:43,100 --> 00:25:47,330
cubics, it's a trivial
computation, and it allows the

441
00:25:47,330 --> 00:25:49,480
entire calculation
to be robust.

442
00:25:49,480 --> 00:25:52,240

443
00:25:52,240 --> 00:25:54,420
Now that I have the
intersections of cubics,

444
00:25:54,420 --> 00:25:57,910
quadratics, and lines, then I
can get back to performing my

445
00:25:57,910 --> 00:26:00,150
path operations.

446
00:26:00,150 --> 00:26:05,140
As before, I'd like to find
all of the places where an

447
00:26:05,140 --> 00:26:07,480
intersection travels, and I
would like compute all the

448
00:26:07,480 --> 00:26:09,670
crossings in a circle.

449
00:26:09,670 --> 00:26:13,250
And as I move counterclockwise
around all of those crossings,

450
00:26:13,250 --> 00:26:16,470
I'd like to accumulate the
winding number to know which

451
00:26:16,470 --> 00:26:21,130
edges to keep and which
edges to discard.

452
00:26:21,130 --> 00:26:24,070
In this example, a triangle and
a pair of circles touch at

453
00:26:24,070 --> 00:26:28,525
the same point, and there are
two lines and two quadratics

454
00:26:28,525 --> 00:26:32,460
that all descend from that
point, and I need to sort them

455
00:26:32,460 --> 00:26:36,070
as I move around
counterclockwise.

456
00:26:36,070 --> 00:26:39,015
When I sort the pair of lines,
the answer is straightforward.

457
00:26:39,015 --> 00:26:41,980
The direction of the line allows
me to know which line

458
00:26:41,980 --> 00:26:47,030
is to the left of the other
using a simple cross product.

459
00:26:47,030 --> 00:26:51,900
For the line in the quadratic, I
can't use that trick because

460
00:26:51,900 --> 00:26:53,680
the initial tangent of
the quadratic is

461
00:26:53,680 --> 00:26:55,280
the same as the line.

462
00:26:55,280 --> 00:26:57,580
But I can use the fact that the
quadratic curls away from

463
00:26:57,580 --> 00:27:00,140
the line to know whether it
curls to the right or the left

464
00:27:00,140 --> 00:27:02,700
of the line.

465
00:27:02,700 --> 00:27:06,180
For a pair of quadratics, the
answer is not so simple.

466
00:27:06,180 --> 00:27:09,540
This particular pair of
quadratics have exactly the

467
00:27:09,540 --> 00:27:10,870
same implicit equation &mdash;

468
00:27:10,870 --> 00:27:14,300
that is, they're part of the
same parabola, and for that

469
00:27:14,300 --> 00:27:18,280
matter, they're the exact same
part of that same parabola, so

470
00:27:18,280 --> 00:27:24,510
they have the same
curved shape.

471
00:27:24,510 --> 00:27:27,680
And if I take the derivative of
each curve, I won't get any

472
00:27:27,680 --> 00:27:30,470
more information because the
derivative will be identical

473
00:27:30,470 --> 00:27:32,270
for these two.

474
00:27:32,270 --> 00:27:36,120
So even though it's clear by
looking at them that Q2 is to

475
00:27:36,120 --> 00:27:39,120
the left of Q1, it's hard
to figure that out

476
00:27:39,120 --> 00:27:40,370
mathematically.

477
00:27:40,370 --> 00:27:42,880

478
00:27:42,880 --> 00:27:47,100
My solution for now is to take
the shorter of the two

479
00:27:47,100 --> 00:27:52,820
tangents and bisect that with
the shorter of the start end

480
00:27:52,820 --> 00:27:56,860
points and sort those
intersections.

481
00:27:56,860 --> 00:28:00,980
Empirically, this produces the
right result, although there

482
00:28:00,980 --> 00:28:02,230
may be a better one.

483
00:28:02,230 --> 00:28:05,960

484
00:28:05,960 --> 00:28:10,340
All of this sorting falls
apart when the

485
00:28:10,340 --> 00:28:12,730
numerics become small.

486
00:28:12,730 --> 00:28:16,342
So here I have a line that
travels between two points off

487
00:28:16,342 --> 00:28:21,260
screen, and here are the
approximations of that line as

488
00:28:21,260 --> 00:28:22,510
represented by little circles.

489
00:28:22,510 --> 00:28:24,970

490
00:28:24,970 --> 00:28:28,970
This grid represents the
floating point resolution

491
00:28:28,970 --> 00:28:32,630
that's available to me, so if
my numbers are in doubles,

492
00:28:32,630 --> 00:28:38,200
then each grid line represents
the smallest possible value

493
00:28:38,200 --> 00:28:40,240
that that double
can represent.

494
00:28:40,240 --> 00:28:44,010
In other words, there's no way
to represent any value smaller

495
00:28:44,010 --> 00:28:45,260
than the grid lines.

496
00:28:45,260 --> 00:28:47,250

497
00:28:47,250 --> 00:28:50,610
When I intersect a pair of
lines, I'm going to find at

498
00:28:50,610 --> 00:28:55,020
best the number that is the
truncation of the actual

499
00:28:55,020 --> 00:28:56,330
intersection.

500
00:28:56,330 --> 00:29:00,160
In other words, because double
precision is finite,

501
00:29:00,160 --> 00:29:01,700
everything's going
to round down.

502
00:29:01,700 --> 00:29:05,030

503
00:29:05,030 --> 00:29:09,050
Here's the second line that
intersects the original line.

504
00:29:09,050 --> 00:29:12,060
And once again, the intersection
as the best

505
00:29:12,060 --> 00:29:15,910
possible approximation rounds
down, and it's represented by

506
00:29:15,910 --> 00:29:17,160
the red circle.

507
00:29:17,160 --> 00:29:19,360

508
00:29:19,360 --> 00:29:23,350
When I consider which of these
lines I would encounter first

509
00:29:23,350 --> 00:29:27,120
when traveling from left to
right, I see visually that the

510
00:29:27,120 --> 00:29:30,980
blue line is to the left
of the red line.

511
00:29:30,980 --> 00:29:34,260
But when I walk across and look
at the answers that I

512
00:29:34,260 --> 00:29:36,830
received from the intersection,
I hit the red

513
00:29:36,830 --> 00:29:39,250
dot before I hit the blue dot.

514
00:29:39,250 --> 00:29:41,750
So basically, the
math lied to me.

515
00:29:41,750 --> 00:29:43,000
It gave me the wrong
intersection.

516
00:29:43,000 --> 00:29:45,870

517
00:29:45,870 --> 00:29:49,560
As it turns out, this would not
be important because this

518
00:29:49,560 --> 00:29:52,490
little triangular sliver, even
though it would be incorrectly

519
00:29:52,490 --> 00:29:55,300
computed, is so small
it wouldn't draw.

520
00:29:55,300 --> 00:29:56,550
It would simply disappear.

521
00:29:56,550 --> 00:29:58,980

522
00:29:58,980 --> 00:30:02,040
But if I'm doing the same work
with a curve instead a pair of

523
00:30:02,040 --> 00:30:06,110
lines, then all of a sudden the
area described between the

524
00:30:06,110 --> 00:30:09,540
blue line and the red curve can
become very large, and my

525
00:30:09,540 --> 00:30:11,980
error likewise becomes
very large.

526
00:30:11,980 --> 00:30:13,890
And now my answer is
wrong for a large

527
00:30:13,890 --> 00:30:15,334
portion of the path op.

528
00:30:15,334 --> 00:30:18,970

529
00:30:18,970 --> 00:30:22,240
This means that for a lot of
computation, I need just to

530
00:30:22,240 --> 00:30:26,220
decide that the answer
is just unknowable.

531
00:30:26,220 --> 00:30:29,200
It may be unsortable, it may
be tiny, or it may be

532
00:30:29,200 --> 00:30:33,030
unorderable, but I can't
necessarily compute what the

533
00:30:33,030 --> 00:30:36,210
answer is for an intersection.

534
00:30:36,210 --> 00:30:40,000
To solve this in the general
case, I simply find another

535
00:30:40,000 --> 00:30:43,480
intersection that I do know and
propagate that answer back

536
00:30:43,480 --> 00:30:45,070
to the intersection
that I don't know.

537
00:30:45,070 --> 00:30:49,300

538
00:30:49,300 --> 00:30:53,530
If a pair of shapes exactly
overlap each other as in the

539
00:30:53,530 --> 00:30:58,150
case of this pair of rectangles,
the path op is

540
00:30:58,150 --> 00:30:59,730
pretty straightforward
to compute.

541
00:30:59,730 --> 00:31:03,760
In this case, the dark green
rectangle is below the blue

542
00:31:03,760 --> 00:31:06,960
one, and so I just want to
return the top of the blue one

543
00:31:06,960 --> 00:31:09,470
as the answer.

544
00:31:09,470 --> 00:31:14,600
A lot of the online references
that I researched suggest that

545
00:31:14,600 --> 00:31:18,280
when points are difficult to
compute, that you could jiggle

546
00:31:18,280 --> 00:31:22,210
the points in order to compute
the actual answer, but this is

547
00:31:22,210 --> 00:31:25,820
a case where jiggling
is destructive.

548
00:31:25,820 --> 00:31:29,120
If I move the lower rectangle's
shapes around a

549
00:31:29,120 --> 00:31:34,140
little bit to avoid having
coincident points, then my

550
00:31:34,140 --> 00:31:37,480
answer will have extra little
spikes on them.

551
00:31:37,480 --> 00:31:40,580
All these spikes are so small
they may not draw.

552
00:31:40,580 --> 00:31:43,770
They prevent me from having a
convex result, which might be

553
00:31:43,770 --> 00:31:48,060
a special operation or a special
optimization when the

554
00:31:48,060 --> 00:31:49,720
shape is accelerated.

555
00:31:49,720 --> 00:31:53,010
Also, it prevents me from
knowing the actual balance of

556
00:31:53,010 --> 00:31:56,590
the resulting shape, and it
makes the testing hard,

557
00:31:56,590 --> 00:32:00,230
because I can't guarantee that
a tap on the shape won't

558
00:32:00,230 --> 00:32:03,520
accidentally be inside one of
those little triangles.

559
00:32:03,520 --> 00:32:06,530
So this is one reason why
jiggling, I think, is not a

560
00:32:06,530 --> 00:32:09,260
robust solution to path ops.

561
00:32:09,260 --> 00:32:12,630

562
00:32:12,630 --> 00:32:16,630
While I can't do jiggling, I
also can't do precise math

563
00:32:16,630 --> 00:32:20,770
because there's enough error
term in all these calculations

564
00:32:20,770 --> 00:32:24,950
that I always have to worry
about what the error is.

565
00:32:24,950 --> 00:32:27,935
So I spent a lot of time
thinking about the unit of

566
00:32:27,935 --> 00:32:31,180
least precision, which
is the error term.

567
00:32:31,180 --> 00:32:34,990
When I compare numbers between
0 and 1, I can describe

568
00:32:34,990 --> 00:32:38,920
exactly what that error is, and
the error I chose is the

569
00:32:38,920 --> 00:32:41,320
smallest amount that a floating
point value can

570
00:32:41,320 --> 00:32:45,600
represent, a 32-bit float
can represent.

571
00:32:45,600 --> 00:32:49,610
This computation can be done all
in float space or in the

572
00:32:49,610 --> 00:32:49,820
[INAUDIBLE]

573
00:32:49,820 --> 00:32:53,030
registers or the [INAUDIBLE]
registers on an ARM chip, and

574
00:32:53,030 --> 00:32:57,030
it's a fairly fast computation
to make.

575
00:32:57,030 --> 00:33:01,670
When the values are arbitrary,
as an ordinary x and y point

576
00:33:01,670 --> 00:33:05,380
part of a Cartesian coordinate,
then the only

577
00:33:05,380 --> 00:33:11,570
reasonable way to determine the
equality is to look at the

578
00:33:11,570 --> 00:33:14,890
integer bit representation of
the floating point numbers.

579
00:33:14,890 --> 00:33:18,100
This is expensive because it
requires taking the original

580
00:33:18,100 --> 00:33:21,380
float values and moving them out
of the float registers and

581
00:33:21,380 --> 00:33:25,110
into the integer ALU before the
comparison can be done,

582
00:33:25,110 --> 00:33:27,640
and that will always stall
the float pipeline.

583
00:33:27,640 --> 00:33:32,120
So whenever possible, I work in
t space between 0 and 1 and

584
00:33:32,120 --> 00:33:35,750
avoid comparing x's and y's
as much as I possibly can.

585
00:33:35,750 --> 00:33:38,500

586
00:33:38,500 --> 00:33:43,060
I have a whole lot of epsilon
values that I currently use,

587
00:33:43,060 --> 00:33:45,770
depending on the complexity
of the math.

588
00:33:45,770 --> 00:33:48,500
I hope over time to simplify
and reduce the number of

589
00:33:48,500 --> 00:33:51,690
epsilons required to perform
this calculation.

590
00:33:51,690 --> 00:33:54,560
And a lot of these are seat of
the pants numbers, but they're

591
00:33:54,560 --> 00:33:55,810
the best I know how to do.

592
00:33:55,810 --> 00:33:58,940

593
00:33:58,940 --> 00:34:02,360
There's a lot of unanswered
questions in path ops.

594
00:34:02,360 --> 00:34:05,460
For instance, here's a shape
that has more than one

595
00:34:05,460 --> 00:34:06,840
possible solution.

596
00:34:06,840 --> 00:34:10,630
When I simplify it, it I might
end up with an L-shaped

597
00:34:10,630 --> 00:34:12,699
corner, or I might end
up with a small

598
00:34:12,699 --> 00:34:14,610
rectangle in the middle.

599
00:34:14,610 --> 00:34:17,460
Both of these are equally valid
answers, and there's no

600
00:34:17,460 --> 00:34:20,620
reason to prefer one over the
other, but one might be more

601
00:34:20,620 --> 00:34:23,580
desirable for graphics
acceleration, for instance.

602
00:34:23,580 --> 00:34:27,409
And currently, I don't have a
way for the algorithm or the

603
00:34:27,409 --> 00:34:28,889
user to choose one
over the other.

604
00:34:28,889 --> 00:34:31,659

605
00:34:31,659 --> 00:34:35,710
Similarly, I don't have a way of
choosing winding direction.

606
00:34:35,710 --> 00:34:37,949
So here are two shapes with
different winding.

607
00:34:37,949 --> 00:34:43,469
The top one winds to the right
on the outer contour, and the

608
00:34:43,469 --> 00:34:45,620
bottom one winds to the left.

609
00:34:45,620 --> 00:34:49,929
While these draw equivalently
and are otherwise identical,

610
00:34:49,929 --> 00:34:51,800
they might have different
results &mdash; for instance, if you

611
00:34:51,800 --> 00:34:54,739
dash the shapes, because the
dashing is going to start at a

612
00:34:54,739 --> 00:34:56,679
different point, and it's
going to travel

613
00:34:56,679 --> 00:34:58,880
in a different direction.

614
00:34:58,880 --> 00:35:03,320
This is another area where I
don't have a way to choose one

615
00:35:03,320 --> 00:35:07,225
over the other nor know what
the user's real intent was.

616
00:35:07,225 --> 00:35:10,150

617
00:35:10,150 --> 00:35:14,390
Finally, right now I
only compute areas.

618
00:35:14,390 --> 00:35:18,290
So for instance, given this
rotated rectangle and a

619
00:35:18,290 --> 00:35:23,720
rectangular clip, I return a
parallelogram, which is the

620
00:35:23,720 --> 00:35:26,510
area of the intersection.

621
00:35:26,510 --> 00:35:28,970
But there may be some reason
to return a pair of lines

622
00:35:28,970 --> 00:35:32,620
instead because those lines
would be the part of the frame

623
00:35:32,620 --> 00:35:35,650
that's visible inside
the clip.

624
00:35:35,650 --> 00:35:38,140
This is another case where I
don't know what the user's

625
00:35:38,140 --> 00:35:42,330
intent was, and I also don't
know if the lower answer is an

626
00:35:42,330 --> 00:35:43,580
answer that's valuable.

627
00:35:43,580 --> 00:35:46,350

628
00:35:46,350 --> 00:35:50,540
To this point, I'm only coding
the answers that actually have

629
00:35:50,540 --> 00:35:52,550
a practical use.

630
00:35:52,550 --> 00:35:55,320
Once there's a need for this
sort of computation, it's an

631
00:35:55,320 --> 00:35:58,970
easy thing to add, but I'll wait
until it shows up as an

632
00:35:58,970 --> 00:36:00,880
optimization for Skia
before I add it.

633
00:36:00,880 --> 00:36:04,420

634
00:36:04,420 --> 00:36:06,010
Here's the current
source code.

635
00:36:06,010 --> 00:36:09,310
Everything is public, open
source, and checked in, and

636
00:36:09,310 --> 00:36:13,830
you can go get any of the path
ops code, the interfaces, or

637
00:36:13,830 --> 00:36:16,110
the sources here.

638
00:36:16,110 --> 00:36:19,520
And I'm going to spend a few
minutes talking about how I

639
00:36:19,520 --> 00:36:23,090
debugged and wrote path ops
and show you a small demo.

640
00:36:23,090 --> 00:36:25,610

641
00:36:25,610 --> 00:36:26,965
And I'm going to do
my updates later.

642
00:36:26,965 --> 00:36:30,630

643
00:36:30,630 --> 00:36:34,960
When I generate path ops, I do
a lot of printfs, and the

644
00:36:34,960 --> 00:36:37,460
printfs look a lot like this.

645
00:36:37,460 --> 00:36:39,600
And while these numbers are
helpful, sometimes they're

646
00:36:39,600 --> 00:36:46,320
very hard to visualize, so I
wrote a way to visualize them.

647
00:36:46,320 --> 00:36:48,175
Oops &mdash; how do I get
there from here?

648
00:36:48,175 --> 00:36:51,100

649
00:36:51,100 --> 00:36:52,350
There we go.

650
00:36:52,350 --> 00:36:55,400

651
00:36:55,400 --> 00:37:00,570
This is a web page that contains
a canvas, and the

652
00:37:00,570 --> 00:37:04,400
canvas contains the printf
output that I showed earlier,

653
00:37:04,400 --> 00:37:07,250
which is at the bottom
of the screen.

654
00:37:07,250 --> 00:37:10,030
The top part of the screen shows
visualizing that output

655
00:37:10,030 --> 00:37:12,550
and visualizing pieces
of that output.

656
00:37:12,550 --> 00:37:16,420
So for instance, all of these
little circles show the

657
00:37:16,420 --> 00:37:19,970
winding values that are computed
for this shape.

658
00:37:19,970 --> 00:37:22,770
And if I look at a pair of these
shapes, a pair of these

659
00:37:22,770 --> 00:37:26,950
tests, I can see at least one
place where I computed a

660
00:37:26,950 --> 00:37:30,480
different answer on the
two different shapes.

661
00:37:30,480 --> 00:37:32,680
That's where the bug was that
I had to trace down here.

662
00:37:32,680 --> 00:37:35,850

663
00:37:35,850 --> 00:37:40,530
This particular canvas allows me
to see a lot of information

664
00:37:40,530 --> 00:37:42,720
about the path ops
that I compute.

665
00:37:42,720 --> 00:37:48,490
For instance, I can see all of
the edges as they're first

666
00:37:48,490 --> 00:37:52,980
computed, and then I can step
through each set of edges and

667
00:37:52,980 --> 00:37:55,450
watch how they're processed.

668
00:37:55,450 --> 00:38:01,300
Or I can see the edges as
they're output so that I know

669
00:38:01,300 --> 00:38:04,290
at what point in the code
each edge is generated.

670
00:38:04,290 --> 00:38:10,180

671
00:38:10,180 --> 00:38:13,780
So here's the output that this
particular test generated, and

672
00:38:13,780 --> 00:38:16,690
here's the output that the test
that failed generated.

673
00:38:16,690 --> 00:38:20,010
So I can compare the two and
have a pretty good idea where

674
00:38:20,010 --> 00:38:21,260
things went wrong.

675
00:38:21,260 --> 00:38:24,450

676
00:38:24,450 --> 00:38:29,270
Here's another example that
shows a pair of cubics, and it

677
00:38:29,270 --> 00:38:32,010
also shows the quadratics that
were generated to approximate

678
00:38:32,010 --> 00:38:33,260
those cubics.

679
00:38:33,260 --> 00:38:35,100

680
00:38:35,100 --> 00:38:37,390
So this is actually showing
both the cubics and the

681
00:38:37,390 --> 00:38:41,080
quadratics at the same time,
but I can look at just the

682
00:38:41,080 --> 00:38:44,590
quadratics, or I can look at
just the cubics and make sure

683
00:38:44,590 --> 00:38:46,400
that my answers are accurate.

684
00:38:46,400 --> 00:38:49,070
And as you can see here, there's
very little visible

685
00:38:49,070 --> 00:38:51,690
difference between the quadratic
approximation and

686
00:38:51,690 --> 00:38:52,940
the actual cubic curve.

687
00:38:52,940 --> 00:38:58,060

688
00:38:58,060 --> 00:39:02,455
This one is going to show
the actual data that a

689
00:39:02,455 --> 00:39:04,670
web page passes me.

690
00:39:04,670 --> 00:39:09,790
So this comes off of
eldorado.com, and it contains

691
00:39:09,790 --> 00:39:14,140
a parallelogram containing a
rounded rect that is also a

692
00:39:14,140 --> 00:39:16,760
parallelogram, and this
is actual CSS data

693
00:39:16,760 --> 00:39:19,770
that describes a clip.

694
00:39:19,770 --> 00:39:23,640
This particular data is
deceptive because even though

695
00:39:23,640 --> 00:39:26,630
those lines look like they touch
each other, they don't.

696
00:39:26,630 --> 00:39:29,780
They're actually very close but
not the same, and makes

697
00:39:29,780 --> 00:39:32,890
the math hard to figure out.

698
00:39:32,890 --> 00:39:36,520
And here are some other examples
of actual web pages

699
00:39:36,520 --> 00:39:40,060
and the clips that they produce
that drive me crazy.

700
00:39:40,060 --> 00:39:44,560

701
00:39:44,560 --> 00:39:49,250
For any of these, I can show the
data that's generated, and

702
00:39:49,250 --> 00:39:51,620
then I can also show
the printfs that

703
00:39:51,620 --> 00:39:53,730
generated that data.

704
00:39:53,730 --> 00:39:57,470
And by advancing through the
data visually and advancing

705
00:39:57,470 --> 00:40:00,745
through the text, I can then go
back to my C code and set

706
00:40:00,745 --> 00:40:04,640
break points and figure out
where things went wrong.

707
00:40:04,640 --> 00:40:06,160
This has been a very helpful
tool for me.

708
00:40:06,160 --> 00:40:11,570

709
00:40:11,570 --> 00:40:14,200
So now I'd like to show
you a quick demo

710
00:40:14,200 --> 00:40:16,080
of path ops in action.

711
00:40:16,080 --> 00:40:20,110

712
00:40:20,110 --> 00:40:23,170
So here we are running some of
the unit tests that I've

713
00:40:23,170 --> 00:40:25,580
written for path ops.

714
00:40:25,580 --> 00:40:28,200
At this point I have around 73
million tests, and we're

715
00:40:28,200 --> 00:40:31,060
seeing a few of them here.

716
00:40:31,060 --> 00:40:33,990
Each of these tests is drawing
the path ops and

717
00:40:33,990 --> 00:40:35,810
computing the result.

718
00:40:35,810 --> 00:40:40,320
It's also using Skia to create
a region with the original

719
00:40:40,320 --> 00:40:42,320
shapes and the result.

720
00:40:42,320 --> 00:40:46,600
Then I compare the bits drawn
by my path ops and the bits

721
00:40:46,600 --> 00:40:50,320
drawn by the region and make
sure there's not any

722
00:40:50,320 --> 00:40:54,100
conservable amount of error
between the two.

723
00:40:54,100 --> 00:40:56,930
This is part of the Skia Unit
Test Suite, and this is run

724
00:40:56,930 --> 00:41:00,750
every time Skia is built on
all platforms, including

725
00:41:00,750 --> 00:41:04,970
Android, Chrome OS, Mac,
Windows, and Linux in 32-bit

726
00:41:04,970 --> 00:41:07,060
and 64-bit.

727
00:41:07,060 --> 00:41:09,960
So I've made sure that this
code is robust and works

728
00:41:09,960 --> 00:41:11,210
across a lot of different
platforms.

729
00:41:11,210 --> 00:41:14,490

730
00:41:14,490 --> 00:41:16,470
So that's it for the
presentation.

731
00:41:16,470 --> 00:41:17,960
I hope you enjoyed it.

732
00:41:17,960 --> 00:41:19,430
Please write me if you
have any questions.

733
00:41:19,430 --> 00:41:20,680
Thank you.

734
00:41:20,680 --> 00:41:31,278

735
00:41:31,278 --> 00:42:31,083
[MUSIC PLAYING]

