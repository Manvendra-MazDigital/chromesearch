1
00:00:00,000 --> 00:00:00,830
ILYA GRIGORIK: [INAUDIBLE].

2
00:00:00,830 --> 00:00:02,120
STEPHEN KONIG: Are we ready?

3
00:00:02,120 --> 00:00:03,470
OK, good morning, everybody.

4
00:00:03,470 --> 00:00:04,470
AUDIENCE: Morning.

5
00:00:04,470 --> 00:00:06,120
STEPHEN KONIG: Thank
you for joining us.

6
00:00:06,120 --> 00:00:09,130
We're here to talk to you guys
today about WebP, which is an

7
00:00:09,130 --> 00:00:12,760
image format we developed which
will allow us to deploy

8
00:00:12,760 --> 00:00:15,160
beautiful, faster, and smaller
images on the web.

9
00:00:15,160 --> 00:00:16,040
My name is Stephen Konig.

10
00:00:16,040 --> 00:00:17,950
I'm a product manager
here at Google

11
00:00:17,950 --> 00:00:19,640
working on the WebP team.

12
00:00:19,640 --> 00:00:20,990
ILYA GRIGORIK: And my name
is Ilya Grigorik.

13
00:00:20,990 --> 00:00:24,210
I'm a developer advocate on the
Make the Web Fast team at

14
00:00:24,210 --> 00:00:26,680
Google, where we work on WebP.

15
00:00:26,680 --> 00:00:29,730
So first of all, I guess to kick
it off-- why are we here?

16
00:00:29,730 --> 00:00:32,299
Why do we care about images,
image formats?

17
00:00:32,299 --> 00:00:35,150
And the answer is simply that
most of the bytes that we

18
00:00:35,150 --> 00:00:36,740
transfer in our applications,
in our web

19
00:00:36,740 --> 00:00:38,120
pages, are in fact images.

20
00:00:38,120 --> 00:00:41,260
If you look at the stats for a
desktop site, over 60% of the

21
00:00:41,260 --> 00:00:43,280
bytes that we transfer
are in images.

22
00:00:43,280 --> 00:00:45,270
So this is in addition
to HTML, CSS,

23
00:00:45,270 --> 00:00:46,270
and everything else.

24
00:00:46,270 --> 00:00:47,810
And on mobile, it's
even larger.

25
00:00:47,810 --> 00:00:48,710
So it's 70%.

26
00:00:48,710 --> 00:00:53,390
So optimizing images is
oftentimes the number one

27
00:00:53,390 --> 00:00:55,230
performance optimization
that you can do.

28
00:00:55,230 --> 00:00:57,780
And in fact, if you look at
stats, there's a great project

29
00:00:57,780 --> 00:00:59,420
called HTTP Archive.

30
00:00:59,420 --> 00:01:03,130
What HTTP Archive does is it
crawls over 300,000 sites on

31
00:01:03,130 --> 00:01:06,440
the web, top sites on the web,
and basically tracks how the

32
00:01:06,440 --> 00:01:07,460
pages are constructed.

33
00:01:07,460 --> 00:01:11,070
So it doesn't care about the
content of the pages, simply

34
00:01:11,070 --> 00:01:11,870
how they're constructed.

35
00:01:11,870 --> 00:01:13,640
So how much CSS are
we downloading?

36
00:01:13,640 --> 00:01:15,570
How many images are
we downloading?

37
00:01:15,570 --> 00:01:16,100
And the rest.

38
00:01:16,100 --> 00:01:19,650
And what you can see here is
that first of all, the trend

39
00:01:19,650 --> 00:01:20,860
is pretty clear.

40
00:01:20,860 --> 00:01:23,530
We are building more ambitious
and more complex applications.

41
00:01:23,530 --> 00:01:24,510
The size is growing.

42
00:01:24,510 --> 00:01:27,460
So in fact, on desktop, an
average site today is over 1

43
00:01:27,460 --> 00:01:30,170
megabyte in size, almost
200 kilobytes.

44
00:01:30,170 --> 00:01:31,970
And on mobile, it's a
little bit smaller.

45
00:01:31,970 --> 00:01:32,550
So that's good.

46
00:01:32,550 --> 00:01:35,046
It means that we're optimizing
for mobile experience and for

47
00:01:35,046 --> 00:01:35,740
mobile networks.

48
00:01:35,740 --> 00:01:37,540
But nonetheless,
700 kilobytes.

49
00:01:37,540 --> 00:01:38,860
But then you look at images.

50
00:01:38,860 --> 00:01:41,980
And you'll notice that most of
the requests are for images,

51
00:01:41,980 --> 00:01:44,260
both on desktop and on mobile.

52
00:01:44,260 --> 00:01:47,020
And the majority of the
bytes are in images.

53
00:01:47,020 --> 00:01:48,260
So this is why WebP matters.

54
00:01:48,260 --> 00:01:52,140
And of course, you heard Linus
at the keynote talking about

55
00:01:52,140 --> 00:01:55,680
WebP and how it can save
bytes for users.

56
00:01:55,680 --> 00:01:58,440
And saving bytes is also
important because bytes are

57
00:01:58,440 --> 00:02:00,320
literally expensive for
a lot of people.

58
00:02:00,320 --> 00:02:03,290
You can be charged up
to $1 per megabyte.

59
00:02:03,290 --> 00:02:05,797
If you've ever roamed with your
mobile data plan, you

60
00:02:05,797 --> 00:02:08,259
know how expensive
that can get.

61
00:02:08,259 --> 00:02:09,820
And it also affects
performance.

62
00:02:09,820 --> 00:02:11,280
So that's trend number one.

63
00:02:11,280 --> 00:02:14,010
We're building more ambitious
applications, transferring

64
00:02:14,010 --> 00:02:14,930
more bytes.

65
00:02:14,930 --> 00:02:17,590
Then, of course, you guys have
all been enjoying the

66
00:02:17,590 --> 00:02:21,490
beautiful Pixel screens,
right, HiDPI images.

67
00:02:21,490 --> 00:02:25,140
This is another trend that is
making this problem in some

68
00:02:25,140 --> 00:02:28,180
sense a lot worse for us, or
much harder, I should say.

69
00:02:28,180 --> 00:02:32,910
So the Chromebook Pixel
has 240 DPI.

70
00:02:32,910 --> 00:02:35,530
And what that means is we're
basically packing more

71
00:02:35,530 --> 00:02:37,710
physical pixels into
the screen.

72
00:02:37,710 --> 00:02:40,160
So to get these high-resolution
images, we

73
00:02:40,160 --> 00:02:42,040
also need to deliver more
pixels to get a

74
00:02:42,040 --> 00:02:43,190
high-resolution image.

75
00:02:43,190 --> 00:02:44,380
There's no magic here.

76
00:02:44,380 --> 00:02:46,380
You can't ship a low-resolution
image to a

77
00:02:46,380 --> 00:02:50,510
Chromebook Pixel and expect it
to display nice sharp edges

78
00:02:50,510 --> 00:02:51,200
across everything.

79
00:02:51,200 --> 00:02:52,920
We literally need to
ship more pixels.

80
00:02:52,920 --> 00:02:55,370
So if we're not careful, we're
just going to inflate all of

81
00:02:55,370 --> 00:02:57,410
the images by 4x because
we're shipping

82
00:02:57,410 --> 00:02:59,040
four times more pixels.

83
00:02:59,040 --> 00:03:01,250
Now hopefully, that's not
what we're going to do.

84
00:03:01,250 --> 00:03:04,610
And that's why WebP is here.

85
00:03:04,610 --> 00:03:08,060
So first and foremost, WebP
is about improving data

86
00:03:08,060 --> 00:03:09,000
compression.

87
00:03:09,000 --> 00:03:12,590
We want to make sure that we
build a faster web and a more

88
00:03:12,590 --> 00:03:13,800
beautiful web.

89
00:03:13,800 --> 00:03:14,610
But also--

90
00:03:14,610 --> 00:03:17,160
and we'll talk about this in
detail-- we want to make it

91
00:03:17,160 --> 00:03:19,700
simpler to deploy the beautiful
web, which is to

92
00:03:19,700 --> 00:03:22,590
say, today, we have a variety
of formats which we need to

93
00:03:22,590 --> 00:03:23,390
balance between.

94
00:03:23,390 --> 00:03:25,120
It's like, oh, you want
to do an animation.

95
00:03:25,120 --> 00:03:26,800
You need to use a GIF file.

96
00:03:26,800 --> 00:03:28,180
You want to have a
transparency--

97
00:03:28,180 --> 00:03:29,430
well, you've got to use a PNG.

98
00:03:29,430 --> 00:03:30,950
But then you can't animate it.

99
00:03:30,950 --> 00:03:33,470
And then if you want to have
lossy versus lossless

100
00:03:33,470 --> 00:03:36,790
compression, you kind of have
this annoying tree of options.

101
00:03:36,790 --> 00:03:40,280
And with WebP, we can actually
do all that and give you

102
00:03:40,280 --> 00:03:41,030
better compression.

103
00:03:41,030 --> 00:03:44,350
So it's kind of one format that
can achieve all of these

104
00:03:44,350 --> 00:03:45,866
great features.

105
00:03:45,866 --> 00:03:47,200
STEPHEN KONIG: So let's talk a
little bit about the history

106
00:03:47,200 --> 00:03:49,340
of WebP and where
it came from.

107
00:03:49,340 --> 00:03:53,240
You may have heard of our WebM
video and audio formats that

108
00:03:53,240 --> 00:03:55,050
we launched a couple
years ago.

109
00:03:55,050 --> 00:03:58,970
The video portion of WebM uses
VP8 as the video codec.

110
00:03:58,970 --> 00:04:01,530
And as part of the development
of VP8, someone actually

111
00:04:01,530 --> 00:04:05,670
noticed that hey, if I take a
key frame from a video stream,

112
00:04:05,670 --> 00:04:06,930
it offers really great
compression.

113
00:04:06,930 --> 00:04:08,700
And this would actually
be a really good basis

114
00:04:08,700 --> 00:04:09,920
for an image format.

115
00:04:09,920 --> 00:04:12,360
And so essentially, that's
how WebP got started.

116
00:04:12,360 --> 00:04:14,760
It was a sort of aha moment
from one of the

117
00:04:14,760 --> 00:04:16,320
engineers on our team.

118
00:04:16,320 --> 00:04:19,410
And so we adopted that
methodology as the basis for

119
00:04:19,410 --> 00:04:20,459
the WebP image format.

120
00:04:20,459 --> 00:04:23,390
So essentially, a WebP image
is nothing more than a key

121
00:04:23,390 --> 00:04:26,100
frame from a VP8 video stream.

122
00:04:26,100 --> 00:04:28,300
But it offers much better
compression than alternate

123
00:04:28,300 --> 00:04:30,260
technologies, as we'll see.

124
00:04:30,260 --> 00:04:32,510
Both WebP and WebM
are open-source,

125
00:04:32,510 --> 00:04:33,490
royalty-free formats.

126
00:04:33,490 --> 00:04:35,270
So you're free to deploy
them, use them.

127
00:04:35,270 --> 00:04:38,280
There's no fees you have to pay,
no licenses you have to

128
00:04:38,280 --> 00:04:39,450
sign up for.

129
00:04:39,450 --> 00:04:41,395
It's all ready to go
out of the box.

130
00:04:41,395 --> 00:04:44,020

131
00:04:44,020 --> 00:04:46,390
So a little bit more in terms of
the timeline of how we got

132
00:04:46,390 --> 00:04:47,460
to where we are today.

133
00:04:47,460 --> 00:04:50,840
We did the initial release back
in 2010, which initially

134
00:04:50,840 --> 00:04:52,770
just supported lossy
compression, so basically an

135
00:04:52,770 --> 00:04:54,560
alternative for JPEG.

136
00:04:54,560 --> 00:04:57,620
In 2012, we followed that up
with support for both lossless

137
00:04:57,620 --> 00:05:00,870
and transparency, or alpha
channel support.

138
00:05:00,870 --> 00:05:02,600
So at that point, we became
an alternative

139
00:05:02,600 --> 00:05:03,790
potentially for PNG.

140
00:05:03,790 --> 00:05:06,480
And interestingly, one of the
things that we did here is we

141
00:05:06,480 --> 00:05:08,710
separated out transparency
from lossless.

142
00:05:08,710 --> 00:05:10,700
Because today, if you want to
have transparency, you have no

143
00:05:10,700 --> 00:05:12,290
choice really but use PNG.

144
00:05:12,290 --> 00:05:13,890
But that forces you to
also use lossless.

145
00:05:13,890 --> 00:05:15,990
And in some cases, you might
want transparency with lossy,

146
00:05:15,990 --> 00:05:18,050
which is something you
can't actually do.

147
00:05:18,050 --> 00:05:20,780
But you can with WebP, and
we'll talk about that.

148
00:05:20,780 --> 00:05:24,630
And then earlier this year, back
in April, we launched our

149
00:05:24,630 --> 00:05:26,780
most recent release, which
added support for color

150
00:05:26,780 --> 00:05:28,960
profile, animation,
and metadata.

151
00:05:28,960 --> 00:05:31,260
So really at this point, we have
a full set of features

152
00:05:31,260 --> 00:05:33,860
that allow us to be an
alternative replacement for

153
00:05:33,860 --> 00:05:38,290
both GIFs, PNGs, as
well as JPEGs.

154
00:05:38,290 --> 00:05:39,060
But we're not done yet.

155
00:05:39,060 --> 00:05:40,100
There's more work we're doing.

156
00:05:40,100 --> 00:05:43,040
And we're continuing to work
on improving the format.

157
00:05:43,040 --> 00:05:44,780
Top of the list are performance
optimizations.

158
00:05:44,780 --> 00:05:47,020
We'll talk about performance
in a little bit.

159
00:05:47,020 --> 00:05:49,590
And I think we offer a really
good performance for the

160
00:05:49,590 --> 00:05:50,880
features we provide today.

161
00:05:50,880 --> 00:05:52,370
But there's always room for
improvement, and we're going

162
00:05:52,370 --> 00:05:54,270
to continue to focus on that.

163
00:05:54,270 --> 00:05:57,070
And similarly, better support
for mobile on ARM devices--

164
00:05:57,070 --> 00:05:58,700
that's really sort of
code optimizations.

165
00:05:58,700 --> 00:06:01,360
We support a wide variety of
mobile devices in terms of

166
00:06:01,360 --> 00:06:03,060
Android and iOS today.

167
00:06:03,060 --> 00:06:05,430
But there's more work we can do
to make that even faster.

168
00:06:05,430 --> 00:06:07,580
And then looking ahead, some
of the other things we're

169
00:06:07,580 --> 00:06:09,720
thinking about are how can we
support higher color depth

170
00:06:09,720 --> 00:06:12,230
images, so more than eight
bits of color.

171
00:06:12,230 --> 00:06:14,720
How could we do things like add
layer support to support

172
00:06:14,720 --> 00:06:16,150
3D types of images?

173
00:06:16,150 --> 00:06:18,560
And even doing things like
progressive rendering.

174
00:06:18,560 --> 00:06:19,640
And I'm sure there'll
be other things.

175
00:06:19,640 --> 00:06:22,680
As the format becomes more
widely adopted and used, we

176
00:06:22,680 --> 00:06:23,990
expect there's going
to be feedback.

177
00:06:23,990 --> 00:06:25,840
And we'll take that into
consideration as well.

178
00:06:25,840 --> 00:06:27,620
ILYA GRIGORIK: So you heard
it here first--

179
00:06:27,620 --> 00:06:30,910
HiDPI, 3D progressive
rendering with WebP.

180
00:06:30,910 --> 00:06:32,110
STEPHEN KONIG: Exactly.

181
00:06:32,110 --> 00:06:33,990
Probably by Friday,
I'm guessing.

182
00:06:33,990 --> 00:06:37,260

183
00:06:37,260 --> 00:06:40,280
So let's talk a little bit about
performance and how WebP

184
00:06:40,280 --> 00:06:42,690
actually does in the wild.

185
00:06:42,690 --> 00:06:44,590
So the first thing I wanted to
talk about is sort of let's do

186
00:06:44,590 --> 00:06:47,710
a little bit of a comparison
of WebP versus JPEG.

187
00:06:47,710 --> 00:06:49,940
And as Ilya mentioned, one of
the challenges we have on the

188
00:06:49,940 --> 00:06:54,280
web today is just the
predominance of images as a

189
00:06:54,280 --> 00:06:56,870
driver for how many bytes we're
sending down the wire

190
00:06:56,870 --> 00:06:59,140
and thus how fast our
pages render.

191
00:06:59,140 --> 00:07:01,670
So in the old world, in the
past, the only way you could

192
00:07:01,670 --> 00:07:04,160
really solve this problem was
to reduce your image quality

193
00:07:04,160 --> 00:07:05,850
if you're dealing with
JPEG images.

194
00:07:05,850 --> 00:07:07,820
So you have two examples
of JPEGs up there.

195
00:07:07,820 --> 00:07:09,580
The one on the top
is quality 80.

196
00:07:09,580 --> 00:07:11,790
The one on the bottom
is quality 10.

197
00:07:11,790 --> 00:07:14,970
And you might hopefully be able
to see that with quality

198
00:07:14,970 --> 00:07:16,660
10, you're getting very

199
00:07:16,660 --> 00:07:18,160
noticeable compression artifacts.

200
00:07:18,160 --> 00:07:20,490
The image looks very
visibly degraded.

201
00:07:20,490 --> 00:07:23,110
But the advantage is you're
going from a 1.3 megabyte

202
00:07:23,110 --> 00:07:25,260
image to a 200 K image.

203
00:07:25,260 --> 00:07:27,180
So if you were in a world where
you were like, I have to

204
00:07:27,180 --> 00:07:29,490
reduce the size of my images
because it's taking up too

205
00:07:29,490 --> 00:07:31,585
many bytes on my page, this
was literally only

206
00:07:31,585 --> 00:07:32,295
the option you had.

207
00:07:32,295 --> 00:07:34,260
But you had to trade off
visual quality in

208
00:07:34,260 --> 00:07:35,310
order to get it.

209
00:07:35,310 --> 00:07:37,350
And we think that's the
wrong tradeoff.

210
00:07:37,350 --> 00:07:40,070
WebP offers much better
compression than JPEG across

211
00:07:40,070 --> 00:07:40,910
all quality levels.

212
00:07:40,910 --> 00:07:42,920
So you're able to get the same
sort of benefit without

213
00:07:42,920 --> 00:07:45,060
reducing your image quality.

214
00:07:45,060 --> 00:07:48,220
And an illustration of that is
this chart, which shows you--

215
00:07:48,220 --> 00:07:51,630
for a number of images which
we did a sample on--

216
00:07:51,630 --> 00:07:55,680
for visual quality 20 all the
way up to 90, the file size

217
00:07:55,680 --> 00:07:56,990
for JPEG versus WebP.

218
00:07:56,990 --> 00:07:58,830
WebP is the one in
green below.

219
00:07:58,830 --> 00:08:01,980
And what you see is that for
all image quality levels,

220
00:08:01,980 --> 00:08:03,800
quality settings, WebP
is significantly

221
00:08:03,800 --> 00:08:05,130
smaller than JPEG.

222
00:08:05,130 --> 00:08:09,480
The one thing I'll note is
you'll see on the JPEG slide,

223
00:08:09,480 --> 00:08:11,900
right around quality 75, you'll
notice that the file

224
00:08:11,900 --> 00:08:14,380
size sort of grows exponentially
with JPEG.

225
00:08:14,380 --> 00:08:18,015
So it does pretty good, mostly
linear from below 75.

226
00:08:18,015 --> 00:08:22,070
But after that, image sizes get
pretty big pretty quickly.

227
00:08:22,070 --> 00:08:24,640
With WebP, you have a much
more linear progression.

228
00:08:24,640 --> 00:08:27,810
And so ironically, as you look
at higher quality images,

229
00:08:27,810 --> 00:08:29,910
which are important for the
reasons we just mentioned,

230
00:08:29,910 --> 00:08:31,680
WebP's benefit actually grows.

231
00:08:31,680 --> 00:08:35,100
So while on average, WebP is
about 30% smaller then JPEG,

232
00:08:35,100 --> 00:08:36,750
when you look at higher
quality images, the

233
00:08:36,750 --> 00:08:37,740
effect is even more.

234
00:08:37,740 --> 00:08:41,380
And so that's something
to keep in mind.

235
00:08:41,380 --> 00:08:44,570
So let's talk a little bit
about WebP versus PNG.

236
00:08:44,570 --> 00:08:47,280
So there are cases, obviously,
where you can't tolerate

237
00:08:47,280 --> 00:08:48,410
compression artifacts at all.

238
00:08:48,410 --> 00:08:50,130
So you're in a sort
of lossless mode.

239
00:08:50,130 --> 00:08:52,030
Or as I talked about earlier,
maybe you need to have

240
00:08:52,030 --> 00:08:53,500
transparency.

241
00:08:53,500 --> 00:08:57,050
And again, WebP is another great
alternative here because

242
00:08:57,050 --> 00:09:01,470
on average, we get about a 30%
file size reduction over PNG.

243
00:09:01,470 --> 00:09:04,540
But again, as I mentioned, one
of the features WebP has is

244
00:09:04,540 --> 00:09:08,250
that it allows you to have
lossy images with

245
00:09:08,250 --> 00:09:10,230
transparency, which is something
you can't really do

246
00:09:10,230 --> 00:09:12,630
today with PNG.

247
00:09:12,630 --> 00:09:15,030
So in cases where you have an
image that you're able to

248
00:09:15,030 --> 00:09:17,350
tolerate a little bit of
compression and artifacts--

249
00:09:17,350 --> 00:09:19,800
maybe you want a, say, quality
90, quality 80 type of image.

250
00:09:19,800 --> 00:09:21,260
But you need transparency.

251
00:09:21,260 --> 00:09:24,590
You can encode that in WebP
versus PNG and save even more.

252
00:09:24,590 --> 00:09:26,550
So in this chart, what you're
looking at is a series about

253
00:09:26,550 --> 00:09:30,350
1,000 PNGs that we compressed
both with WebP lossless, which

254
00:09:30,350 --> 00:09:30,940
is the purple.

255
00:09:30,940 --> 00:09:33,090
So that's again no
loss whatsoever.

256
00:09:33,090 --> 00:09:35,350
And then we recompressed them
again with lossy, but

257
00:09:35,350 --> 00:09:36,895
preserving the transparency.

258
00:09:36,895 --> 00:09:38,970
And what you see is that for
the vast, vast majority of

259
00:09:38,970 --> 00:09:41,680
images, we're significantly
smaller than the PNGs.

260
00:09:41,680 --> 00:09:42,960
And there's a couple of extreme

261
00:09:42,960 --> 00:09:45,070
examples at both tails.

262
00:09:45,070 --> 00:09:48,050
But obviously, the average
and median is

263
00:09:48,050 --> 00:09:49,520
strongly in favor of WebP.

264
00:09:49,520 --> 00:09:51,290
ILYA GRIGORIK: So I think a
very common use case is to

265
00:09:51,290 --> 00:09:54,470
have a lot of small PNGs for
things like icons, which need

266
00:09:54,470 --> 00:09:55,220
an alpha channel.

267
00:09:55,220 --> 00:09:56,240
And they're also very small.

268
00:09:56,240 --> 00:10:00,450
And that's where you can get up
to 80% or higher savings in

269
00:10:00,450 --> 00:10:02,475
terms of bytes, which is huge.

270
00:10:02,475 --> 00:10:03,725
STEPHEN KONIG: Yup, exactly.

271
00:10:03,725 --> 00:10:07,560

272
00:10:07,560 --> 00:10:11,120
So the nice thing about WebP is
it allows you to be in this

273
00:10:11,120 --> 00:10:13,130
world in which you can really
stop caring about what image

274
00:10:13,130 --> 00:10:14,260
format you need to use.

275
00:10:14,260 --> 00:10:16,820
Today, you're in this mode of,
well, if I need animation, I

276
00:10:16,820 --> 00:10:17,650
have to use GIFs.

277
00:10:17,650 --> 00:10:19,930
And if I need lossless or
I need transparency,

278
00:10:19,930 --> 00:10:20,980
I have to use PNG.

279
00:10:20,980 --> 00:10:22,760
And if it's not one of
those things, I can

280
00:10:22,760 --> 00:10:24,590
probably use JPEG.

281
00:10:24,590 --> 00:10:27,280
But as a web developer, it
forces you to think through

282
00:10:27,280 --> 00:10:29,020
which image format
you have to use.

283
00:10:29,020 --> 00:10:30,810
With WebP, you don't have
to do that anymore.

284
00:10:30,810 --> 00:10:33,020
Literally, you can use every
image as WebP, because it

285
00:10:33,020 --> 00:10:34,230
supports all of those
features.

286
00:10:34,230 --> 00:10:36,410
And we think that's a great
benefit to web developers.

287
00:10:36,410 --> 00:10:39,340

288
00:10:39,340 --> 00:10:42,110
So let's talk a little bit about
performance from the

289
00:10:42,110 --> 00:10:43,300
encoding and decoding side.

290
00:10:43,300 --> 00:10:45,900
So this is all great.

291
00:10:45,900 --> 00:10:47,970
WebP's a lot smaller, offers
great features.

292
00:10:47,970 --> 00:10:48,880
Where's the catch?

293
00:10:48,880 --> 00:10:50,990
Well, lunch isn't free,
despite the fact

294
00:10:50,990 --> 00:10:51,830
that we keep trying.

295
00:10:51,830 --> 00:10:53,410
We're not quite there yet.

296
00:10:53,410 --> 00:10:56,490
So you should know that WebP
is more expensive to encode

297
00:10:56,490 --> 00:10:57,000
and decode.

298
00:10:57,000 --> 00:10:59,020
But there are some reasons
I think why--

299
00:10:59,020 --> 00:11:02,200
sort of take these numbers
in context.

300
00:11:02,200 --> 00:11:04,870
On the encoding side, it takes
about 5 to 10 times longer to

301
00:11:04,870 --> 00:11:08,070
encode a WebP image than a
JPEG, which sounds pretty

302
00:11:08,070 --> 00:11:09,010
significant.

303
00:11:09,010 --> 00:11:10,770
But when you realize that
encoding is typically done

304
00:11:10,770 --> 00:11:11,550
only once--

305
00:11:11,550 --> 00:11:13,910
in the vast majority of cases,
you're dealing with a static

306
00:11:13,910 --> 00:11:14,950
image corpus.

307
00:11:14,950 --> 00:11:16,810
And you're encoding those
images one time.

308
00:11:16,810 --> 00:11:19,010
And you're doing it not in
your serving pipeline.

309
00:11:19,010 --> 00:11:20,430
You're doing that offline.

310
00:11:20,430 --> 00:11:23,020
And so if it takes an extra
couple CPU cycles to encode

311
00:11:23,020 --> 00:11:25,670
your WebP images, that really
shouldn't be something that

312
00:11:25,670 --> 00:11:27,900
would be a barrier
to WebP adoption.

313
00:11:27,900 --> 00:11:30,070
On the decoding side,
we're more

314
00:11:30,070 --> 00:11:31,110
computationally intensive.

315
00:11:31,110 --> 00:11:33,290
So yes, it takes more time
to decode a WebP image.

316
00:11:33,290 --> 00:11:35,960
And on average, we're about
1.3 times slower than a

317
00:11:35,960 --> 00:11:37,780
comparable JPEG.

318
00:11:37,780 --> 00:11:39,650
What we've seen, though, is that
in the vast majority of

319
00:11:39,650 --> 00:11:44,280
cases, unless you have a very
specific use case, the amount

320
00:11:44,280 --> 00:11:47,220
of time you're saving just by
virtue of the fewer bytes

321
00:11:47,220 --> 00:11:49,530
you're sending more than
makes up for the

322
00:11:49,530 --> 00:11:51,140
increased decode time.

323
00:11:51,140 --> 00:11:54,800
So that's something
to bear in mind.

324
00:11:54,800 --> 00:11:58,470
With that said, high encoding
costs can be a limitation in

325
00:11:58,470 --> 00:11:59,400
some use cases.

326
00:11:59,400 --> 00:12:02,590
And I'll give you one example
from Google as we've been

327
00:12:02,590 --> 00:12:04,530
trying to deploy WebP.

328
00:12:04,530 --> 00:12:07,880
So if you think about Maps,
map tiles are actually

329
00:12:07,880 --> 00:12:11,140
dynamically generated PNGs
that are based on the

330
00:12:11,140 --> 00:12:13,030
underlying raster data.

331
00:12:13,030 --> 00:12:16,310
When we actually tried to deploy
WebP instead of PNGs,

332
00:12:16,310 --> 00:12:20,220
what we found is that the
increasing encoding time,

333
00:12:20,220 --> 00:12:23,140
because those images are
generated dynamically, sort of

334
00:12:23,140 --> 00:12:25,530
negated a lot of the benefit
from the smaller file size.

335
00:12:25,530 --> 00:12:28,430
But that's a pretty special
case because there are no

336
00:12:28,430 --> 00:12:29,260
static map tiles.

337
00:12:29,260 --> 00:12:31,830
They're all generated at runtime
based on your request.

338
00:12:31,830 --> 00:12:34,930
So in that case, in that
particular instance, encoding

339
00:12:34,930 --> 00:12:36,340
is actually in the
serving pipeline.

340
00:12:36,340 --> 00:12:38,060
And so if you have a situation
like that, you should be

341
00:12:38,060 --> 00:12:38,950
mindful of these stats.

342
00:12:38,950 --> 00:12:41,000
But again, as I said, that's
really the exception.

343
00:12:41,000 --> 00:12:44,640
The vast majority of
cases are static.

344
00:12:44,640 --> 00:12:47,340
And then we talked a little bit
about bandwidth savings.

345
00:12:47,340 --> 00:12:51,630
But in addition to just raw time
to send fewer bytes, you

346
00:12:51,630 --> 00:12:53,730
have to be aware that a lot of
users, especially on mobile,

347
00:12:53,730 --> 00:12:55,210
actually have to pay for
their bandwidth.

348
00:12:55,210 --> 00:12:57,730
Either they're on metered plans
or capped plans, or

349
00:12:57,730 --> 00:12:58,690
they're roaming.

350
00:12:58,690 --> 00:13:01,210
And in some cases, it's
literally $1 per megabyte.

351
00:13:01,210 --> 00:13:03,880
So not only are you saving users
time and making your

352
00:13:03,880 --> 00:13:05,610
site faster for them and
giving them a better

353
00:13:05,610 --> 00:13:07,960
experience, you can literally
save them money.

354
00:13:07,960 --> 00:13:09,840
And so that's an important
consideration to

355
00:13:09,840 --> 00:13:11,020
keep in mind, as well.

356
00:13:11,020 --> 00:13:13,280
ILYA GRIGORIK: So the other
thing I'll add is we have the

357
00:13:13,280 --> 00:13:15,560
chicken and the egg problem
here with performance.

358
00:13:15,560 --> 00:13:19,310
Of course, there is also a
growing support for hardware--

359
00:13:19,310 --> 00:13:23,630
or sorry, hardware support is
improving for WebP and WebM.

360
00:13:23,630 --> 00:13:26,780
So we have WebM, which is
driving this trend, as well.

361
00:13:26,780 --> 00:13:31,010
So performance will get better
as more hardware deploys

362
00:13:31,010 --> 00:13:32,260
native support for it.

363
00:13:32,260 --> 00:13:35,510

364
00:13:35,510 --> 00:13:38,060
So a good example of
this is actually--

365
00:13:38,060 --> 00:13:41,340
there's this tradeoff between
CPU and bandwidth.

366
00:13:41,340 --> 00:13:43,610
And one of the concerns, a valid
concern that a lot of

367
00:13:43,610 --> 00:13:45,060
people have is, great.

368
00:13:45,060 --> 00:13:47,300
So we're going to ship
these bytes faster.

369
00:13:47,300 --> 00:13:49,380
But if we take more time on
the client to decode the

370
00:13:49,380 --> 00:13:53,030
images, is that going to negate
all of the benefits?

371
00:13:53,030 --> 00:13:55,640
And the eBay team actually
just recently

372
00:13:55,640 --> 00:13:56,990
had this great study--

373
00:13:56,990 --> 00:13:58,965
I encourage you guys to
check out their blog.

374
00:13:58,965 --> 00:14:00,820
It's an eBay tech blog--

375
00:14:00,820 --> 00:14:02,820
where they compare a number of
different image formats.

376
00:14:02,820 --> 00:14:04,890
And they set up a test case
where they have an image

377
00:14:04,890 --> 00:14:06,940
gallery with 30 different
images.

378
00:14:06,940 --> 00:14:09,270
And they compared JPEG
versus WebP.

379
00:14:09,270 --> 00:14:11,090
And what you're seeing here
is a film strip which is

380
00:14:11,090 --> 00:14:13,880
basically 100-millisecond
increments, so 0.5

381
00:14:13,880 --> 00:14:15,590
seconds, 0.6, 0.7.

382
00:14:15,590 --> 00:14:17,530
And you're seeing the rendering
performance.

383
00:14:17,530 --> 00:14:19,240
So on the top, we have WebP.

384
00:14:19,240 --> 00:14:21,610
And even though it takes more
time to decode the WebP

385
00:14:21,610 --> 00:14:24,270
images, because we can ship
them faster, we can decode

386
00:14:24,270 --> 00:14:24,810
them faster.

387
00:14:24,810 --> 00:14:26,540
And we can display them
on the screen.

388
00:14:26,540 --> 00:14:27,840
So in this case, we're actually

389
00:14:27,840 --> 00:14:29,590
winning in both respects.

390
00:14:29,590 --> 00:14:32,100
We're getting better
visual performance.

391
00:14:32,100 --> 00:14:33,650
We're shipping fewer bytes.

392
00:14:33,650 --> 00:14:38,090
The user's paying less for
the bytes transferred.

393
00:14:38,090 --> 00:14:39,990
And we're paying less
for the bytes

394
00:14:39,990 --> 00:14:41,070
transferred from our server.

395
00:14:41,070 --> 00:14:42,990
So it's a win all around.

396
00:14:42,990 --> 00:14:46,140
And on this gallery, we were
able to compress it from 750

397
00:14:46,140 --> 00:14:48,490
kilobytes down to 474.

398
00:14:48,490 --> 00:14:51,060
So a really cool case study,
and I think it illustrates

399
00:14:51,060 --> 00:14:55,450
that a lot of our web apps can
benefit a lot from WebP.

400
00:14:55,450 --> 00:14:56,760
So we talked about
performance.

401
00:14:56,760 --> 00:14:59,680
Let's dive a little bit deeper
into tooling, into how do we

402
00:14:59,680 --> 00:15:03,340
actually create these files
and how do we serve them.

403
00:15:03,340 --> 00:15:06,740
So long story short, there
are plugins and

404
00:15:06,740 --> 00:15:07,980
converters that we provide.

405
00:15:07,980 --> 00:15:11,990
You can go to our site,
download the binary.

406
00:15:11,990 --> 00:15:14,700
And you have a cwebp and
a dwebp, which is an

407
00:15:14,700 --> 00:15:15,950
encoder and a decoder.

408
00:15:15,950 --> 00:15:17,400
And you can convert any image.

409
00:15:17,400 --> 00:15:19,880
We give you a lot of different
knobs-- if anything, there's

410
00:15:19,880 --> 00:15:20,990
too many knobs--

411
00:15:20,990 --> 00:15:23,410
to tweak the quality
and levels and

412
00:15:23,410 --> 00:15:24,540
all the other stuff.

413
00:15:24,540 --> 00:15:26,040
That's kind of the manual
way to do it.

414
00:15:26,040 --> 00:15:28,700
You can also get plugins
for all of the

415
00:15:28,700 --> 00:15:30,590
popular image editors.

416
00:15:30,590 --> 00:15:33,900
The Wikipedia page actually is
a great resource to start, if

417
00:15:33,900 --> 00:15:36,000
you want to get started
with WebP.

418
00:15:36,000 --> 00:15:39,630
They have a great matrix of all
the different tools out

419
00:15:39,630 --> 00:15:41,350
there and how to get
WebP support.

420
00:15:41,350 --> 00:15:44,310
And with time, as more people
adopt it, of course, this will

421
00:15:44,310 --> 00:15:45,310
also improve.

422
00:15:45,310 --> 00:15:47,610
And I'll also call out
a couple of tools

423
00:15:47,610 --> 00:15:49,390
like language bindings.

424
00:15:49,390 --> 00:15:52,730
So there are great libraries for
virtually every language

425
00:15:52,730 --> 00:15:53,620
runtime available.

426
00:15:53,620 --> 00:15:56,525
So you can do these
optimizations at build time or

427
00:15:56,525 --> 00:15:57,510
at runtime.

428
00:15:57,510 --> 00:15:59,750
And there's some other tools
which we'll demo

429
00:15:59,750 --> 00:16:01,350
a little bit later.

430
00:16:01,350 --> 00:16:04,260
In terms of the actual adoption
and support today, of

431
00:16:04,260 --> 00:16:06,160
course, Chrome supports WebP.

432
00:16:06,160 --> 00:16:08,310
Opera also supports WebP
and has been supporting

433
00:16:08,310 --> 00:16:09,710
WebP for a long time.

434
00:16:09,710 --> 00:16:13,250
We also ship native libraries,
or we make the native library

435
00:16:13,250 --> 00:16:14,470
available for iOS.

436
00:16:14,470 --> 00:16:16,910
And it's also supported
natively by Android.

437
00:16:16,910 --> 00:16:20,140
So you can deploy both on native
apps and on the web.

438
00:16:20,140 --> 00:16:24,980
There are ways to basically
polyfill support for WebP on

439
00:16:24,980 --> 00:16:25,700
other browsers.

440
00:16:25,700 --> 00:16:29,320
So you can actually have a
JavaScript decoder for WebP.

441
00:16:29,320 --> 00:16:31,280
I'm not saying that's
necessarily a great idea, but

442
00:16:31,280 --> 00:16:32,800
you could do it if
you wanted to.

443
00:16:32,800 --> 00:16:36,350
And we'll show you a couple of
examples of how to do perhaps

444
00:16:36,350 --> 00:16:37,990
a better deployment strategy.

445
00:16:37,990 --> 00:16:40,430
And of course, we're also
working with the Firefox team

446
00:16:40,430 --> 00:16:42,170
to get WebP supported.

447
00:16:42,170 --> 00:16:45,770
And fingers crossed, I hope
we will see it this year--

448
00:16:45,770 --> 00:16:48,730
sometime later this year.

449
00:16:48,730 --> 00:16:51,060
So let's start deploying
WebP on the web.

450
00:16:51,060 --> 00:16:53,040
Great-- we've motivated
the use case.

451
00:16:53,040 --> 00:16:54,530
We know that we should
be optimizing images.

452
00:16:54,530 --> 00:16:56,040
How do I even get started?

453
00:16:56,040 --> 00:16:58,920
And in a nutshell, there are a
couple different approaches.

454
00:16:58,920 --> 00:17:02,100
You can use server detection, or
server-side detection, and

455
00:17:02,100 --> 00:17:03,310
client detection.

456
00:17:03,310 --> 00:17:05,380
And we'll talk through
both paths.

457
00:17:05,380 --> 00:17:07,040
But one thing I'll point
out is they're

458
00:17:07,040 --> 00:17:08,910
not mutually exclusive.

459
00:17:08,910 --> 00:17:12,349
You can and probably should use
both, depending on your

460
00:17:12,349 --> 00:17:14,710
application.

461
00:17:14,710 --> 00:17:18,190
So the client-side detection
is an easy case.

462
00:17:18,190 --> 00:17:19,920
Basically, you just
want to test--

463
00:17:19,920 --> 00:17:21,630
the client loads some
JavaScript.

464
00:17:21,630 --> 00:17:25,089
And you want to find out if
the client supports WebP.

465
00:17:25,089 --> 00:17:27,329
Because then you can dynamically
inject the image

466
00:17:27,329 --> 00:17:29,460
tags and fetch the appropriate
asset.

467
00:17:29,460 --> 00:17:33,030
So you can have both a JPEG
and a WebP on your server.

468
00:17:33,030 --> 00:17:37,750
And for example, Modernizr
provides a one-line test

469
00:17:37,750 --> 00:17:39,970
function that you can run
to determine if a

470
00:17:39,970 --> 00:17:40,820
client supports it.

471
00:17:40,820 --> 00:17:43,200
If you actually unroll, and
you look at the underlying

472
00:17:43,200 --> 00:17:45,580
implementation, it's basically
three lines of

473
00:17:45,580 --> 00:17:46,540
JavaScript in there.

474
00:17:46,540 --> 00:17:47,740
They just inject an image tag.

475
00:17:47,740 --> 00:17:49,480
And they add an on load element
to make sure that the

476
00:17:49,480 --> 00:17:51,020
image is decoded properly.

477
00:17:51,020 --> 00:17:53,170
So you don't need Modernizr
to do this.

478
00:17:53,170 --> 00:17:55,340
You can just inline this
code directly.

479
00:17:55,340 --> 00:17:58,230
And I mentioned the JavaScript
decoder.

480
00:17:58,230 --> 00:17:59,870
You can use that as well.

481
00:17:59,870 --> 00:18:01,310
So in fact, if you only
want to serve

482
00:18:01,310 --> 00:18:03,360
WebPs, you can do that.

483
00:18:03,360 --> 00:18:07,290
It would just serve the
JavaScript decoder, and then

484
00:18:07,290 --> 00:18:10,200
your images would
load just fine.

485
00:18:10,200 --> 00:18:11,150
So that's client-side.

486
00:18:11,150 --> 00:18:13,970
Server-side is a little bit, I
think, more interesting and

487
00:18:13,970 --> 00:18:16,110
more scalable for a lot
of applications.

488
00:18:16,110 --> 00:18:20,570
So the way this works is when
the client makes a request for

489
00:18:20,570 --> 00:18:25,540
an image, it sends an Accept
header, which advertises which

490
00:18:25,540 --> 00:18:26,960
file types it supports.

491
00:18:26,960 --> 00:18:29,910
So this is very similar to, for
example, a compression.

492
00:18:29,910 --> 00:18:32,640
So gzip negotiation, where the
client advertises their

493
00:18:32,640 --> 00:18:35,430
support of gzip, and then the
server returns a response

494
00:18:35,430 --> 00:18:36,430
which is compressed.

495
00:18:36,430 --> 00:18:38,730
Similarly here, the
client advertises,

496
00:18:38,730 --> 00:18:40,150
hey, I support WebP.

497
00:18:40,150 --> 00:18:43,350
And then the server can select
the appropriate asset, in this

498
00:18:43,350 --> 00:18:44,730
case, a WebP file.

499
00:18:44,730 --> 00:18:50,520
So Opera provides the Accept
header, which advertises WebP.

500
00:18:50,520 --> 00:18:52,710
And we just recently landed
support in Chrome

501
00:18:52,710 --> 00:18:53,400
for that, as well.

502
00:18:53,400 --> 00:18:54,460
So it's currently in Canary.

503
00:18:54,460 --> 00:18:58,580
And it will be making it to
Stable soon, once we go

504
00:18:58,580 --> 00:18:59,890
through the release cycles.

505
00:18:59,890 --> 00:19:02,070
So with that, basically, your
server can just look at the

506
00:19:02,070 --> 00:19:04,200
Accept header and serve the
appropriate one, such that

507
00:19:04,200 --> 00:19:09,370
when, for example, an IE user
comes, they won't advertise

508
00:19:09,370 --> 00:19:11,140
WebP, for obvious reasons.

509
00:19:11,140 --> 00:19:13,060
And you can just serve
a PNG file.

510
00:19:13,060 --> 00:19:15,000
And this logic is handled
by the server.

511
00:19:15,000 --> 00:19:17,280
So you don't have to modify
your application.

512
00:19:17,280 --> 00:19:19,790
This is the best part.

513
00:19:19,790 --> 00:19:21,200
And I'll show you some
examples later

514
00:19:21,200 --> 00:19:23,210
in an actual demo.

515
00:19:23,210 --> 00:19:24,720
A slightly different
approach--

516
00:19:24,720 --> 00:19:27,000
and this is actually very
popular with a lot of web

517
00:19:27,000 --> 00:19:28,500
optimization products today--

518
00:19:28,500 --> 00:19:30,820
is to rely on user-agent
sniffing.

519
00:19:30,820 --> 00:19:33,490
So the reason this exists today
is because we didn't

520
00:19:33,490 --> 00:19:34,930
have the Accept header.

521
00:19:34,930 --> 00:19:36,020
So we're fixing this problem.

522
00:19:36,020 --> 00:19:38,170
We're making it much better
and easier to deploy.

523
00:19:38,170 --> 00:19:40,940
But you will find applications
or approaches that will use

524
00:19:40,940 --> 00:19:43,690
this strategy, where they will
check the user agent and say,

525
00:19:43,690 --> 00:19:46,100
hey, I know that Chrome
supports WebP.

526
00:19:46,100 --> 00:19:52,480
Hence I will serve the HTML
markup, which has WebP files

527
00:19:52,480 --> 00:19:55,340
embedded in it, or references
to WebP files.

528
00:19:55,340 --> 00:20:00,670
Whereas for Internet Explorer, I
will serve the JPEG version.

529
00:20:00,670 --> 00:20:04,130
So then there's a couple of
other quirks that you need to

530
00:20:04,130 --> 00:20:06,050
worry about-- for example,
caching.

531
00:20:06,050 --> 00:20:09,010
If now we're generating multiple
versions of the HTML,

532
00:20:09,010 --> 00:20:11,660
one with WebPs and one with
JPEGs, how do we make sure

533
00:20:11,660 --> 00:20:15,430
that the IE user agent doesn't
get the WebP assets?

534
00:20:15,430 --> 00:20:18,730
This is why we're marking this
document as private, which is

535
00:20:18,730 --> 00:20:21,270
to say, the client
can cache it, but

536
00:20:21,270 --> 00:20:22,970
intermediate servers can't.

537
00:20:22,970 --> 00:20:26,810
So some intermediate proxy
can't cache it.

538
00:20:26,810 --> 00:20:31,780
So those are the kind of
do-it-yourself approaches.

539
00:20:31,780 --> 00:20:34,185
The good news is we actually
provide tools that will do all

540
00:20:34,185 --> 00:20:35,470
of this work for you.

541
00:20:35,470 --> 00:20:39,000
So we have a PageSpeed product--
or family of

542
00:20:39,000 --> 00:20:40,870
products, I should say-- which
are both open source.

543
00:20:40,870 --> 00:20:43,320
We have modules available
for Apache and nginx.

544
00:20:43,320 --> 00:20:45,260
And we also have a Google
hosted version, which is

545
00:20:45,260 --> 00:20:46,350
PageSpeed Service.

546
00:20:46,350 --> 00:20:48,870
So let me show you guys
an example of

547
00:20:48,870 --> 00:20:50,460
this actually in action.

548
00:20:50,460 --> 00:20:52,020
So I have--

549
00:20:52,020 --> 00:20:54,590
I'll make this a little
bit smaller.

550
00:20:54,590 --> 00:20:56,350
On my blog, I have
a little gallery

551
00:20:56,350 --> 00:20:58,460
of my favorite photos--

552
00:20:58,460 --> 00:21:03,000
beautiful images, or at least
I think they are.

553
00:21:03,000 --> 00:21:04,940
And you can see here
that I have

554
00:21:04,940 --> 00:21:06,840
Tokyo, Oxford, and Aurora.

555
00:21:06,840 --> 00:21:08,860
And they're about 3 megs.

556
00:21:08,860 --> 00:21:10,350
Now, I'm serving them as PNGs.

557
00:21:10,350 --> 00:21:14,670
That's just how I happened to
have saved them on my server.

558
00:21:14,670 --> 00:21:16,750
3 megs is probably
a little high.

559
00:21:16,750 --> 00:21:18,080
So I think we can do better.

560
00:21:18,080 --> 00:21:19,650
So I'm also running
PageSpeed Service.

561
00:21:19,650 --> 00:21:22,620
And the way PageSpeed Service
works is I have my origin

562
00:21:22,620 --> 00:21:26,950
server, where all
my markup lives.

563
00:21:26,950 --> 00:21:30,870
But my WWW domain is actually
routed through Google servers,

564
00:21:30,870 --> 00:21:32,980
such that when you visit my
site, you actually hit a

565
00:21:32,980 --> 00:21:35,110
Google server, which then
fetches my content.

566
00:21:35,110 --> 00:21:38,180
It optimizes it and serves
the optimized assets.

567
00:21:38,180 --> 00:21:39,760
So let me show you
the dashboard

568
00:21:39,760 --> 00:21:41,700
for PageSpeed Service.

569
00:21:41,700 --> 00:21:44,670
We have the overview here.

570
00:21:44,670 --> 00:21:46,800
So this is my server,
Google servers.

571
00:21:46,800 --> 00:21:52,680
And then the visitor is hitting
the Google servers.

572
00:21:52,680 --> 00:21:54,280
And all of the magic
happens here.

573
00:21:54,280 --> 00:21:56,320
So we provide a number of
optimization for things like

574
00:21:56,320 --> 00:21:59,300
let us optimize your CSS, your
JavaScript, and all the rest.

575
00:21:59,300 --> 00:22:02,590
And optimizing images, for the
reasons that we mentioned

576
00:22:02,590 --> 00:22:04,270
previously, is a
big part of it.

577
00:22:04,270 --> 00:22:06,610
So in here, you can see that I
can enable a whole bunch of

578
00:22:06,610 --> 00:22:09,130
checkboxes for things like
resizing images on the server.

579
00:22:09,130 --> 00:22:10,870
So I'm just going to
click that on.

580
00:22:10,870 --> 00:22:14,130
And I'm going to also convert
PNGs to JPEGs.

581
00:22:14,130 --> 00:22:17,030
Or I'm going to allow it
to try to convert.

582
00:22:17,030 --> 00:22:18,200
It won't necessarily do it.

583
00:22:18,200 --> 00:22:21,770
It will try to make sure that
we get better compression.

584
00:22:21,770 --> 00:22:25,140
And let's apply that
to the site.

585
00:22:25,140 --> 00:22:26,260
And let's go back.

586
00:22:26,260 --> 00:22:28,060
And we will refresh this page.

587
00:22:28,060 --> 00:22:29,870
And we will actually refresh
it twice, because the way

588
00:22:29,870 --> 00:22:33,250
PageSpeed Service works is it
optimizes these images on

589
00:22:33,250 --> 00:22:35,730
demand and in the background
such that on the second

590
00:22:35,730 --> 00:22:38,270
request, you can see that the
file names have changed.

591
00:22:38,270 --> 00:22:40,440
And they are now coming
through as JPEGs.

592
00:22:40,440 --> 00:22:42,480
So what we have done is we have
optimized these images in

593
00:22:42,480 --> 00:22:42,760
the background.

594
00:22:42,760 --> 00:22:45,250
We've determined that
JPEGs are a better

595
00:22:45,250 --> 00:22:46,520
version of this file.

596
00:22:46,520 --> 00:22:48,500
So we went from multiple
megabytes

597
00:22:48,500 --> 00:22:50,210
to hundreds of kilobytes.

598
00:22:50,210 --> 00:22:52,600
So now the page is
468 kilobytes.

599
00:22:52,600 --> 00:22:53,850
So this is done automatically.

600
00:22:53,850 --> 00:22:56,420
I didn't modify my
app in any way.

601
00:22:56,420 --> 00:23:00,560
And similarly, I can go
into the API console.

602
00:23:00,560 --> 00:23:02,340
And I'm just going
to enable it all.

603
00:23:02,340 --> 00:23:05,570
So I'm going to recompress JPEGs
and allow it to compress

604
00:23:05,570 --> 00:23:09,130
it to WebP as well.

605
00:23:09,130 --> 00:23:11,230
So once again, Apply to Live.

606
00:23:11,230 --> 00:23:14,310
And we'll reload the page
a few more times.

607
00:23:14,310 --> 00:23:17,960
And it's going to now try both
JPEG and WebP and pick the

608
00:23:17,960 --> 00:23:19,930
best format for these images.

609
00:23:19,930 --> 00:23:22,170
And you can see that it actually
determined that WebP

610
00:23:22,170 --> 00:23:23,300
is the best format.

611
00:23:23,300 --> 00:23:25,900
It detected that I'm
running Chrome.

612
00:23:25,900 --> 00:23:28,240
And now it's serving these
images, which went from a

613
00:23:28,240 --> 00:23:30,580
megabyte plus to 80 kilobytes.

614
00:23:30,580 --> 00:23:34,230
So in total, the file size of
this page is 328 kilobytes.

615
00:23:34,230 --> 00:23:37,540
So we've just decreased the
size of this page by 10x

616
00:23:37,540 --> 00:23:40,440
without actually touching the
page itself, which, of course,

617
00:23:40,440 --> 00:23:40,990
is beautiful.

618
00:23:40,990 --> 00:23:44,540
And notice that this
was all images.

619
00:23:44,540 --> 00:23:47,130
So you can use PageSpeed
Service, which is

620
00:23:47,130 --> 00:23:48,690
what you saw here.

621
00:23:48,690 --> 00:23:52,160
Or you can use one of our
open-source modules like

622
00:23:52,160 --> 00:23:55,850
Apache or the nginx module
to do this for you.

623
00:23:55,850 --> 00:23:56,750
STEPHEN KONIG: So let's talk
a little bit about

624
00:23:56,750 --> 00:23:57,895
interoperability.

625
00:23:57,895 --> 00:23:59,760
I think it's fair to say we live
in a world in which WebP

626
00:23:59,760 --> 00:24:00,890
isn't ubiquitous yet.

627
00:24:00,890 --> 00:24:01,690
We hope we'll get there.

628
00:24:01,690 --> 00:24:03,310
We're confident we'll
get there.

629
00:24:03,310 --> 00:24:06,270
But just like previous formats
before us, like PNG, there's

630
00:24:06,270 --> 00:24:10,880
this sort of uncanny valley of
time where you have mixed

631
00:24:10,880 --> 00:24:12,520
support across the web.

632
00:24:12,520 --> 00:24:14,720
And you have to deal
with that today.

633
00:24:14,720 --> 00:24:16,120
In fact, some of you
may have seen--

634
00:24:16,120 --> 00:24:18,190
a couple weeks ago, Facebook
actually did a field trial

635
00:24:18,190 --> 00:24:21,800
where they actually started
serving user photos as WebP

636
00:24:21,800 --> 00:24:23,880
instead of as JPEGs.

637
00:24:23,880 --> 00:24:25,550
It generated a slight
bit of controversy.

638
00:24:25,550 --> 00:24:28,060
Actually, I think overall, from
what we know, they're

639
00:24:28,060 --> 00:24:30,250
very pleased with the
results they saw.

640
00:24:30,250 --> 00:24:32,220
But it did highlight some
interoperability challenges

641
00:24:32,220 --> 00:24:34,470
that you have to be aware of and
for which we think there

642
00:24:34,470 --> 00:24:35,700
are some good solutions.

643
00:24:35,700 --> 00:24:37,640
That said, this is a
short-term problem.

644
00:24:37,640 --> 00:24:40,360
And just like PNG eventually
got ubiquitous support, we

645
00:24:40,360 --> 00:24:41,910
feel confident WebP
will as well.

646
00:24:41,910 --> 00:24:43,010
And a lot of these issues
will go away.

647
00:24:43,010 --> 00:24:44,470
But in the short term,
these are some

648
00:24:44,470 --> 00:24:45,490
things to be aware of.

649
00:24:45,490 --> 00:24:46,930
So link sharing is one.

650
00:24:46,930 --> 00:24:49,040
So I look at my beautiful
site.

651
00:24:49,040 --> 00:24:50,230
I see this awesome
image in WebP.

652
00:24:50,230 --> 00:24:51,500
I'm running Chrome or Opera.

653
00:24:51,500 --> 00:24:52,400
It looks beautiful.

654
00:24:52,400 --> 00:24:54,610
I right-click, copy
link to image.

655
00:24:54,610 --> 00:24:56,020
I paste it in an email
to my wife.

656
00:24:56,020 --> 00:24:57,650
And I say, honey, this
is really cool.

657
00:24:57,650 --> 00:24:58,900
You should check it out.

658
00:24:58,900 --> 00:25:00,460
She happens to be
running Firefox.

659
00:25:00,460 --> 00:25:03,295
And she clicks the link,
and sad face.

660
00:25:03,295 --> 00:25:06,150
Because it can't decode
a WebP image.

661
00:25:06,150 --> 00:25:08,670
So a good way to solve this
problem is the Accept header

662
00:25:08,670 --> 00:25:10,770
negotiation that we talked
about earlier.

663
00:25:10,770 --> 00:25:12,830
Because in that case, what the
server will see when it gets

664
00:25:12,830 --> 00:25:16,340
the request, even if it has a
.webp attachment to it, it

665
00:25:16,340 --> 00:25:19,700
won't see the image/webp
in the Accept header.

666
00:25:19,700 --> 00:25:22,160
It will know it's not safe to
return WebP to that client.

667
00:25:22,160 --> 00:25:24,250
And in that case, you can
actually return a JPEG.

668
00:25:24,250 --> 00:25:26,510
It doesn't matter what
the extension is.

669
00:25:26,510 --> 00:25:29,700
You can serve the right image
format based on Accept header.

670
00:25:29,700 --> 00:25:31,450
Similarly, there's an
issue with Save As.

671
00:25:31,450 --> 00:25:33,310
Right click an image,
Save As to disk.

672
00:25:33,310 --> 00:25:35,920
And then I email it to somebody,
or I happen to just

673
00:25:35,920 --> 00:25:38,050
double-click it from
my File Explorer.

674
00:25:38,050 --> 00:25:40,760
And oops, I don't have an image
viewer that's capable of

675
00:25:40,760 --> 00:25:41,240
rendering that.

676
00:25:41,240 --> 00:25:43,970
Or the person I send it to
doesn't have one, either.

677
00:25:43,970 --> 00:25:46,440
So there's a couple of ways to
fix that, one of which we've

678
00:25:46,440 --> 00:25:47,250
already taken care of.

679
00:25:47,250 --> 00:25:49,530
So starting with M28, Chrome is
actually a file handler on

680
00:25:49,530 --> 00:25:50,610
all platforms for WebP.

681
00:25:50,610 --> 00:25:52,250
So if the user has Chrome,
they'll at least be able to

682
00:25:52,250 --> 00:25:54,020
open a WebP file.

683
00:25:54,020 --> 00:25:56,090
But another sort of approach
to this is to provide an

684
00:25:56,090 --> 00:25:59,620
explicit download option link
and have that always serve a

685
00:25:59,620 --> 00:26:02,870
common format such
as a JPEG or PNG.

686
00:26:02,870 --> 00:26:04,810
There's some user experience
benefits to that as well.

687
00:26:04,810 --> 00:26:06,950
Because the image that the user
sees on the screen might

688
00:26:06,950 --> 00:26:08,170
not be the one that
you want to have

689
00:26:08,170 --> 00:26:09,440
them ability to download.

690
00:26:09,440 --> 00:26:11,490
For example, they might want to
download a full-resolution

691
00:26:11,490 --> 00:26:13,920
version of the image versus
something that's scaled down.

692
00:26:13,920 --> 00:26:15,230
So there's some other
reasons why that

693
00:26:15,230 --> 00:26:16,480
approach might make sense.

694
00:26:16,480 --> 00:26:18,870

695
00:26:18,870 --> 00:26:21,650
Let's look at a few case studies
in the wild and see

696
00:26:21,650 --> 00:26:25,530
some of the benefits we've
gotten from WebP.

697
00:26:25,530 --> 00:26:28,640
So earlier this year, we posted
a blog post about some

698
00:26:28,640 --> 00:26:29,820
work we did on the
Chrome Web Store.

699
00:26:29,820 --> 00:26:31,390
So for those of you who aren't
familiar with it, Chrome Web

700
00:26:31,390 --> 00:26:32,500
Store is a great site.

701
00:26:32,500 --> 00:26:34,520
Lets you browse tons of add-ons,
extensions, and

702
00:26:34,520 --> 00:26:36,230
applications for Chrome.

703
00:26:36,230 --> 00:26:37,740
But it's a very image-heavy
site--

704
00:26:37,740 --> 00:26:41,180
tons of promotional tiles, big
tiles, little tiles, tiles

705
00:26:41,180 --> 00:26:41,970
rotating in and out.

706
00:26:41,970 --> 00:26:45,360
It's a gorgeous site, but it's
definitely very image-heavy.

707
00:26:45,360 --> 00:26:47,780
So we went through a process
of converting all of those

708
00:26:47,780 --> 00:26:49,520
images to WebP and
serving them to

709
00:26:49,520 --> 00:26:50,780
Chrome and Opera users.

710
00:26:50,780 --> 00:26:53,200
When we did that, we got an
average 30% reduction in image

711
00:26:53,200 --> 00:26:55,210
size across all the images
on the site.

712
00:26:55,210 --> 00:26:56,910
But more importantly,
we reduced page

713
00:26:56,910 --> 00:26:58,970
load time by a third.

714
00:26:58,970 --> 00:27:00,500
And that was pretty
significant.

715
00:27:00,500 --> 00:27:02,590
And it really, at the end of the
day, turned out to be not

716
00:27:02,590 --> 00:27:04,170
a tremendous amount of work.

717
00:27:04,170 --> 00:27:07,410
Really, we just request-- we
have a server that serves

718
00:27:07,410 --> 00:27:08,070
image assets.

719
00:27:08,070 --> 00:27:09,390
It's capable of doing
transcoding.

720
00:27:09,390 --> 00:27:11,710
And then we just tell it, hey,
if the user is Chrome or

721
00:27:11,710 --> 00:27:13,120
Opera, serve WebP.

722
00:27:13,120 --> 00:27:17,590
And magically, things start
getting faster very easy.

723
00:27:17,590 --> 00:27:19,275
And one example is
the calendar tile

724
00:27:19,275 --> 00:27:20,180
that you see here--

725
00:27:20,180 --> 00:27:22,210
two versions of the same tile.

726
00:27:22,210 --> 00:27:26,630
One is 32 and one is 8.3 K. So
tremendous difference with

727
00:27:26,630 --> 00:27:28,530
very little plumbing work
that was needed

728
00:27:28,530 --> 00:27:31,430
to get that to happen.

729
00:27:31,430 --> 00:27:34,110
And we're in the process of
deploying WebP across all

730
00:27:34,110 --> 00:27:35,460
Google sites that
serve images.

731
00:27:35,460 --> 00:27:36,780
So some of these are
supported today.

732
00:27:36,780 --> 00:27:39,100
Others you will see support
rolling out across

733
00:27:39,100 --> 00:27:39,710
the rest of the year.

734
00:27:39,710 --> 00:27:41,610
Some of them are in various
stages of experimental and

735
00:27:41,610 --> 00:27:42,740
field trial.

736
00:27:42,740 --> 00:27:46,650
But literally across the gamut
of sites across Google, we are

737
00:27:46,650 --> 00:27:48,070
in the process of doing
all this transition.

738
00:27:48,070 --> 00:27:49,890
And we'll be doing that
throughout the

739
00:27:49,890 --> 00:27:50,410
course of the year.

740
00:27:50,410 --> 00:27:53,570
We'll talk about one more
of them in a moment.

741
00:27:53,570 --> 00:27:55,550
ILYA GRIGORIK: So we're
definitely dogfooding a lot of

742
00:27:55,550 --> 00:27:58,410
the WebP deployment
strategies today.

743
00:27:58,410 --> 00:28:01,030
And one great example is
actually data compression.

744
00:28:01,030 --> 00:28:04,560
So once again, if you saw the
keynotes, Linus actually

745
00:28:04,560 --> 00:28:06,350
talked about this, where
we now have a

746
00:28:06,350 --> 00:28:07,900
new feature in Chrome.

747
00:28:07,900 --> 00:28:09,120
And if you haven't tried
it, we definitely

748
00:28:09,120 --> 00:28:09,880
encourage you to.

749
00:28:09,880 --> 00:28:12,980
If you go to the Apps Store and
download Chrome Beta, you

750
00:28:12,980 --> 00:28:14,980
can go into your settings.

751
00:28:14,980 --> 00:28:16,570
There's a new tab called
Bandwidth Management.

752
00:28:16,570 --> 00:28:18,990
It can basically enable Chrome
data compression.

753
00:28:18,990 --> 00:28:22,460
So the way that works is when
you make a request, we will

754
00:28:22,460 --> 00:28:24,910
actually route the request to
a Google server, which will

755
00:28:24,910 --> 00:28:28,230
then fetch the content and all
the associated images,

756
00:28:28,230 --> 00:28:30,720
compress it, minify it, optimize
it, and then deliver

757
00:28:30,720 --> 00:28:34,210
the optimized version to your
site or to your phone, rather.

758
00:28:34,210 --> 00:28:37,960
And we find that we get, on
average, 50% data reduction

759
00:28:37,960 --> 00:28:38,740
when we do that.

760
00:28:38,740 --> 00:28:40,820
So this is a huge benefit
to the user.

761
00:28:40,820 --> 00:28:42,390
And guess what?

762
00:28:42,390 --> 00:28:45,100
Images are once again the
number one optimization.

763
00:28:45,100 --> 00:28:47,410
So in fact, one of the big
optimizations that we do in

764
00:28:47,410 --> 00:28:53,720
Flywheel or data compression is
just re-encoding literally

765
00:28:53,720 --> 00:28:55,360
every single image to WebP.

766
00:28:55,360 --> 00:28:57,180
We just transcode everything
to WebP.

767
00:28:57,180 --> 00:29:03,230
And that helps reduce the
data usage quite a bit.

768
00:29:03,230 --> 00:29:04,510
This is a great site.

769
00:29:04,510 --> 00:29:06,190
I love to share this site.

770
00:29:06,190 --> 00:29:09,010
Let's actually look at
a demo to appreciate

771
00:29:09,010 --> 00:29:11,900
it in all its glory.

772
00:29:11,900 --> 00:29:14,830
So this is a beautiful animation
built by Oakley.

773
00:29:14,830 --> 00:29:16,550
So as I'm scrolling
down, we have this

774
00:29:16,550 --> 00:29:17,810
beautiful parallax effect.

775
00:29:17,810 --> 00:29:20,480
We have animations coming
in and out.

776
00:29:20,480 --> 00:29:24,150
This is using HTML5, lots
of images, nothing

777
00:29:24,150 --> 00:29:25,900
special under the hood.

778
00:29:25,900 --> 00:29:29,710
But the one trick to
this page is--

779
00:29:29,710 --> 00:29:31,910
let's just reload it here.

780
00:29:31,910 --> 00:29:35,450
This is where we definitely
need a good connection.

781
00:29:35,450 --> 00:29:38,820

782
00:29:38,820 --> 00:29:39,020
Let's see.

783
00:29:39,020 --> 00:29:40,250
100%--

784
00:29:40,250 --> 00:29:42,080
here we come.

785
00:29:42,080 --> 00:29:46,330
86 megabytes of images to
deliver this great experience.

786
00:29:46,330 --> 00:29:48,220
So the way the site is built--

787
00:29:48,220 --> 00:29:49,470
and it's a beautiful
experience.

788
00:29:49,470 --> 00:29:50,600
I love it--

789
00:29:50,600 --> 00:29:54,820
is it's delivering a lot of PNGs
with transparencies in

790
00:29:54,820 --> 00:29:55,510
the background.

791
00:29:55,510 --> 00:29:59,340
And so as you move, these are
basically layers that are

792
00:29:59,340 --> 00:30:03,270
being positioned right
within the browser.

793
00:30:03,270 --> 00:30:06,240
So 86 megs is quite heavy.

794
00:30:06,240 --> 00:30:09,100
So as just an experiment, we
said, look, WebP can probably

795
00:30:09,100 --> 00:30:10,620
do a bit better,
especially with

796
00:30:10,620 --> 00:30:12,380
transparency, as you guys heard.

797
00:30:12,380 --> 00:30:15,800
So we can take the 86 meg,
without any modifications to

798
00:30:15,800 --> 00:30:19,280
the site, and convert
it to 28 megs.

799
00:30:19,280 --> 00:30:21,070
So let's be clear.

800
00:30:21,070 --> 00:30:24,860
28 megs is still massive
for a web page.

801
00:30:24,860 --> 00:30:28,930
But it's 60 or 58 megabytes
less, which is

802
00:30:28,930 --> 00:30:32,620
pretty good, I think.

803
00:30:32,620 --> 00:30:37,250
And so some cool tools or some
tips for getting started.

804
00:30:37,250 --> 00:30:40,050
And if you just want to
experiment with WebP, there's

805
00:30:40,050 --> 00:30:40,860
a great service.

806
00:30:40,860 --> 00:30:43,350
It's a free service called
IMG2WebP.net.

807
00:30:43,350 --> 00:30:44,590
You can just go there.

808
00:30:44,590 --> 00:30:47,990
You can drag in an image, any
image off your local file

809
00:30:47,990 --> 00:30:49,700
system, and just play
with the settings.

810
00:30:49,700 --> 00:30:51,580
And you have a bunch
of sliders.

811
00:30:51,580 --> 00:30:53,200
And you can see the
output without

812
00:30:53,200 --> 00:30:54,750
installing any other tools.

813
00:30:54,750 --> 00:30:56,960
So this is not something that
you want to use to convert all

814
00:30:56,960 --> 00:30:58,330
of your images to
WebP, but it's a

815
00:30:58,330 --> 00:30:59,950
great way to get started.

816
00:30:59,950 --> 00:31:02,600
If you're on Windows, there's
a great new tool that was

817
00:31:02,600 --> 00:31:05,080
released just a couple of weeks
ago where you can punch

818
00:31:05,080 --> 00:31:08,310
in the name of the site or
just the URL of the site.

819
00:31:08,310 --> 00:31:09,990
It'll download your site.

820
00:31:09,990 --> 00:31:12,860
And it'll recompress all the
images with WebP and basically

821
00:31:12,860 --> 00:31:17,020
give you a report card saying,
if you converted to WebP with

822
00:31:17,020 --> 00:31:21,490
these settings, then you would
save this amount of bytes.

823
00:31:21,490 --> 00:31:23,520
And you can actually change and
tweak the settings, which

824
00:31:23,520 --> 00:31:24,210
is the cool part.

825
00:31:24,210 --> 00:31:26,790
So you can change your
compression quality levels and

826
00:31:26,790 --> 00:31:27,480
all the rest.

827
00:31:27,480 --> 00:31:28,660
STEPHEN KONIG: And it lets
you see your site

828
00:31:28,660 --> 00:31:30,220
with WebP as well.

829
00:31:30,220 --> 00:31:32,020
So you can actually do a little
side by side visual

830
00:31:32,020 --> 00:31:32,530
comparison.

831
00:31:32,530 --> 00:31:34,080
ILYA GRIGORIK: So
awesome tool.

832
00:31:34,080 --> 00:31:34,860
Definitely check it out.

833
00:31:34,860 --> 00:31:37,690
And then finally, if you're
ready to start converting your

834
00:31:37,690 --> 00:31:41,900
images, as Stephen mentioned,
you can do that at deploy time

835
00:31:41,900 --> 00:31:42,960
or at build time.

836
00:31:42,960 --> 00:31:46,360
There's a number of great
plugins for things like Grunt

837
00:31:46,360 --> 00:31:50,480
and other build tools which can
run at build time and just

838
00:31:50,480 --> 00:31:51,910
convert all of your images
and make them

839
00:31:51,910 --> 00:31:53,160
available on the server.

840
00:31:53,160 --> 00:31:56,730

841
00:31:56,730 --> 00:31:57,360
STEPHEN KONIG: So let's
talk a little bit

842
00:31:57,360 --> 00:31:59,122
about WebP on mobile.

843
00:31:59,122 --> 00:32:02,074
Full screen.

844
00:32:02,074 --> 00:32:04,230
Oh, I want to go
to full screen.

845
00:32:04,230 --> 00:32:07,230

846
00:32:07,230 --> 00:32:09,150
So we talked a lot about
deploying it on sort of the

847
00:32:09,150 --> 00:32:09,860
desktop web.

848
00:32:09,860 --> 00:32:12,010
The good news is there are great
ways to deploy this on

849
00:32:12,010 --> 00:32:14,080
the mobile web as well, on our
mobile devices for native

850
00:32:14,080 --> 00:32:14,850
applications.

851
00:32:14,850 --> 00:32:16,000
We'll talk a little
bit about that.

852
00:32:16,000 --> 00:32:17,220
One case study--

853
00:32:17,220 --> 00:32:20,040
so the Google+ app, today on
Android, and actually for

854
00:32:20,040 --> 00:32:23,840
about the last month or so, has
been serving WebP images.

855
00:32:23,840 --> 00:32:25,340
So you probably haven't
noticed.

856
00:32:25,340 --> 00:32:30,550
And that's actually the point,
that you're getting faster

857
00:32:30,550 --> 00:32:34,040
performance and faster loads
for the same quality image,

858
00:32:34,040 --> 00:32:35,120
and you didn't have
to do anything.

859
00:32:35,120 --> 00:32:36,370
And that's the whole idea.

860
00:32:36,370 --> 00:32:39,880
But starting about a month and a
half ago, we've been serving

861
00:32:39,880 --> 00:32:43,180
WebP images to users of
the G+ app on Android.

862
00:32:43,180 --> 00:32:45,500
On average, we've been actually
seeing about a 50%

863
00:32:45,500 --> 00:32:47,810
reduction in image
sizes with WebP.

864
00:32:47,810 --> 00:32:49,610
And the reason for that is WebP
actually does a pretty

865
00:32:49,610 --> 00:32:52,990
good job with user-generated
photos as opposed to other

866
00:32:52,990 --> 00:32:55,310
types of images, especially
with photos.

867
00:32:55,310 --> 00:32:58,030
So that's why we're able to
get even more than typical

868
00:32:58,030 --> 00:32:59,030
kinds of savings.

869
00:32:59,030 --> 00:33:01,100
We're literally, as a result
of that change, saving many

870
00:33:01,100 --> 00:33:02,970
terabytes of bandwidth
per day.

871
00:33:02,970 --> 00:33:05,640
And literally also because of
the cost factor-- we're saving

872
00:33:05,640 --> 00:33:06,730
our users money.

873
00:33:06,730 --> 00:33:09,250
So it's cheaper to use this app
now than it was before.

874
00:33:09,250 --> 00:33:12,580
And I think that's a
pretty cool win.

875
00:33:12,580 --> 00:33:14,300
So how would you deploy
this on Android?

876
00:33:14,300 --> 00:33:16,210
So the code you see here is
actually using the native

877
00:33:16,210 --> 00:33:19,270
library, which is supported on
all versions of Android.

878
00:33:19,270 --> 00:33:23,330
So WebP support is baked in at
the OS level, starting with

879
00:33:23,330 --> 00:33:24,680
ICS and above.

880
00:33:24,680 --> 00:33:27,150
But if you want to be able to
target versions of Android

881
00:33:27,150 --> 00:33:28,250
prior to that, you
can use a native

882
00:33:28,250 --> 00:33:29,300
library that we provide.

883
00:33:29,300 --> 00:33:30,030
So it's pretty simple.

884
00:33:30,030 --> 00:33:31,280
Basically, you get
a WebP image.

885
00:33:31,280 --> 00:33:32,140
You decode it as a bitmap.

886
00:33:32,140 --> 00:33:33,460
And then you render it.

887
00:33:33,460 --> 00:33:34,960
So I'll let you guys read
through all the code.

888
00:33:34,960 --> 00:33:37,180
But that's pretty much
the process-- pretty

889
00:33:37,180 --> 00:33:37,435
straightforward.

890
00:33:37,435 --> 00:33:38,930
ILYA GRIGORIK: I think the
point here is that it's

891
00:33:38,930 --> 00:33:40,760
actually no different from
any other image.

892
00:33:40,760 --> 00:33:42,470
STEPHEN KONIG: Exactly.

893
00:33:42,470 --> 00:33:44,190
And same sort of
story on iOS--

894
00:33:44,190 --> 00:33:46,140
we provide a library that you
can use if you're building

895
00:33:46,140 --> 00:33:47,150
native apps for iOS.

896
00:33:47,150 --> 00:33:48,690
Pretty much the same thing--
grab the image from the

897
00:33:48,690 --> 00:33:51,180
server, decode it, stick it into
a byte array, render it,

898
00:33:51,180 --> 00:33:52,140
and you're done.

899
00:33:52,140 --> 00:33:57,330
So it's pretty straightforward
to deploy and use.

900
00:33:57,330 --> 00:33:58,550
ILYA GRIGORIK: So as a recap--

901
00:33:58,550 --> 00:34:00,380
I think we've covered a
lot of ground here.

902
00:34:00,380 --> 00:34:03,050
For deploying WebP, you can
use it on native apps.

903
00:34:03,050 --> 00:34:04,980
That's very easy
to get started.

904
00:34:04,980 --> 00:34:06,220
We have iOS solutions.

905
00:34:06,220 --> 00:34:07,850
We have Android solutions.

906
00:34:07,850 --> 00:34:11,610
You can go far back with the
backport as well on Android.

907
00:34:11,610 --> 00:34:13,340
And on the web, we have server

908
00:34:13,340 --> 00:34:14,960
detection, client-side detection.

909
00:34:14,960 --> 00:34:17,020
We looked at a couple different
strategies.

910
00:34:17,020 --> 00:34:20,030
And personally, I think actually
the automation part

911
00:34:20,030 --> 00:34:22,670
of deploying WebP is the easiest
way to get started.

912
00:34:22,670 --> 00:34:24,250
So PageSpeed is one way.

913
00:34:24,250 --> 00:34:27,350
There are other providers that
will convert these images and

914
00:34:27,350 --> 00:34:29,060
serve them dynamically
for you.

915
00:34:29,060 --> 00:34:32,190
Just recently, we actually had
an interesting experiment

916
00:34:32,190 --> 00:34:34,949
deploy with a company called CDN
Connect, which does image

917
00:34:34,949 --> 00:34:35,800
optimization.

918
00:34:35,800 --> 00:34:38,400
What they allow you to do is
just upload any image that you

919
00:34:38,400 --> 00:34:40,210
want into their CDN.

920
00:34:40,210 --> 00:34:41,639
They will do all of
the optimization.

921
00:34:41,639 --> 00:34:43,159
They'll handle the Accept
negotiation.

922
00:34:43,159 --> 00:34:45,400
You guys don't even have
to think about it.

923
00:34:45,400 --> 00:34:47,940
And the user gets the
optimized assets.

924
00:34:47,940 --> 00:34:51,230
So hopefully, this motivated
why you should

925
00:34:51,230 --> 00:34:52,590
take a look at WebP.

926
00:34:52,590 --> 00:34:57,090
And hopefully you'll deploy
them in your applications.

927
00:34:57,090 --> 00:34:58,780
And if you guys have any
questions, please

928
00:34:58,780 --> 00:34:59,730
grab one of the mics.

929
00:34:59,730 --> 00:35:01,144
And we'll be happy
to answer them.

930
00:35:01,144 --> 00:35:09,856
[APPLAUSE]

931
00:35:09,856 --> 00:35:10,340
AUDIENCE: Hi.

932
00:35:10,340 --> 00:35:13,061
You guys talked about
encoding--

933
00:35:13,061 --> 00:35:17,080
or you showed example of
decoding on Android and iOS.

934
00:35:17,080 --> 00:35:20,610
I was just wondering if it's
likely or realistic to encode

935
00:35:20,610 --> 00:35:24,440
on Android or iOS in the process
of an application

936
00:35:24,440 --> 00:35:26,960
where you'd be taking a picture
and then want to send

937
00:35:26,960 --> 00:35:29,680
it to a web service and
encode it first.

938
00:35:29,680 --> 00:35:31,460
Can you talk about that?

939
00:35:31,460 --> 00:35:34,430
STEPHEN KONIG: Yeah, I think you
could certainly do that.

940
00:35:34,430 --> 00:35:36,800
The libraries we provide today
are focused on decode because

941
00:35:36,800 --> 00:35:38,350
that's the predominant case.

942
00:35:38,350 --> 00:35:41,910
But literally, they're nothing
more than a port of the full

943
00:35:41,910 --> 00:35:44,080
library that you find
on our site.

944
00:35:44,080 --> 00:35:45,830
So I think we could certainly
look at that.

945
00:35:45,830 --> 00:35:48,445
Or it's something I think you
could do today, just porting

946
00:35:48,445 --> 00:35:49,850
that code for the encoder.

947
00:35:49,850 --> 00:35:52,840

948
00:35:52,840 --> 00:35:54,490
AUDIENCE: I have a question
about using the Accept header

949
00:35:54,490 --> 00:35:56,500
to serve the right
image format.

950
00:35:56,500 --> 00:35:59,160
Right now on our site, all
image links are complete

951
00:35:59,160 --> 00:36:01,650
permalinks that gives you the
same data no matter where you

952
00:36:01,650 --> 00:36:04,370
are or when you are, which is
really nice for a CDN, which

953
00:36:04,370 --> 00:36:05,920
just uses the URL
as a cache key.

954
00:36:05,920 --> 00:36:10,140
And also any caching proxy
between our user and our CDN

955
00:36:10,140 --> 00:36:12,830
can cache based on
just the URL.

956
00:36:12,830 --> 00:36:16,820
So I'm wondering what sort of
CDN support do you see for

957
00:36:16,820 --> 00:36:19,110
using that Accept header as
part of the cache key.

958
00:36:19,110 --> 00:36:22,010
And also how that affects
downstream caching proxies--

959
00:36:22,010 --> 00:36:23,430
are they able to distinguish
that?

960
00:36:23,430 --> 00:36:26,210
Or do we just have to tell them
that the downstream proxy

961
00:36:26,210 --> 00:36:27,610
can't cache it?

962
00:36:27,610 --> 00:36:30,520
ILYA GRIGORIK: So the other part
I didn't cover around the

963
00:36:30,520 --> 00:36:32,960
Accept header is the
Vary Accept.

964
00:36:32,960 --> 00:36:36,820
So when you provide a different
image based on

965
00:36:36,820 --> 00:36:39,300
Accept header, you also have
to basically indicate to

966
00:36:39,300 --> 00:36:43,410
upstream proxies to say, this
image is different based on

967
00:36:43,410 --> 00:36:44,450
certain parameters.

968
00:36:44,450 --> 00:36:46,640
So that's why you specify
Vary Accept.

969
00:36:46,640 --> 00:36:48,830
And we actually have a good
tutorial that I've written up

970
00:36:48,830 --> 00:36:52,620
recently for how to make this
work with nginx and Apache and

971
00:36:52,620 --> 00:36:53,530
other servers.

972
00:36:53,530 --> 00:36:55,580
And working with CDN's--

973
00:36:55,580 --> 00:36:57,330
I've talked to Akamai
and others.

974
00:36:57,330 --> 00:37:00,833
They're in the process of
deploying support for Accept.

975
00:37:00,833 --> 00:37:04,080
AUDIENCE: And in terms of
proxies that you see users

976
00:37:04,080 --> 00:37:06,850
have, do you find that the level
of support for being

977
00:37:06,850 --> 00:37:09,610
able to identify that properly
is high enough that you'd be

978
00:37:09,610 --> 00:37:10,850
willing to send that
to your users?

979
00:37:10,850 --> 00:37:11,615
Or do you see a lot of errors?

980
00:37:11,615 --> 00:37:13,710
ILYA GRIGORIK: So the default
behavior for a lot of proxies

981
00:37:13,710 --> 00:37:17,510
today is if they see anything
but Accept in coding, is to

982
00:37:17,510 --> 00:37:19,240
not cache it.

983
00:37:19,240 --> 00:37:22,320
So that means that it'll
just bypass that cache.

984
00:37:22,320 --> 00:37:24,380
So it won't break your site,
which I think is a more

985
00:37:24,380 --> 00:37:25,790
important part.

986
00:37:25,790 --> 00:37:26,210
AUDIENCE: OK.

987
00:37:26,210 --> 00:37:27,730
Thanks.

988
00:37:27,730 --> 00:37:28,270
AUDIENCE: Yes, hi.

989
00:37:28,270 --> 00:37:32,140
How do you see WebP being used
in medical radiology?

990
00:37:32,140 --> 00:37:32,690
STEPHEN KONIG: In--

991
00:37:32,690 --> 00:37:33,330
sorry, which?

992
00:37:33,330 --> 00:37:35,230
AUDIENCE: In radiology.

993
00:37:35,230 --> 00:37:35,720
STEPHEN KONIG: Good question.

994
00:37:35,720 --> 00:37:38,570
I'm not sure.

995
00:37:38,570 --> 00:37:40,300
We think there's lots
of applications.

996
00:37:40,300 --> 00:37:43,740
We've been heavily focused
on the web for

997
00:37:43,740 --> 00:37:44,680
sort of obvious reasons.

998
00:37:44,680 --> 00:37:47,140
But having said that, I think
there are a lot of additional

999
00:37:47,140 --> 00:37:50,030
types of applications where
WebP makes a lot of sense.

1000
00:37:50,030 --> 00:37:53,520
In the cases where storage is a
primary concern, WebP is an

1001
00:37:53,520 --> 00:37:54,470
obvious choice.

1002
00:37:54,470 --> 00:37:57,750
We can get you the same image
with no loss of visual quality

1003
00:37:57,750 --> 00:38:02,400
or purely lossless if you want
for 30 to 50% less bytes.

1004
00:38:02,400 --> 00:38:04,140
So we haven't been focused
on those kinds of

1005
00:38:04,140 --> 00:38:05,510
applications just yet.

1006
00:38:05,510 --> 00:38:08,270
But I would expect that as we
make more progress in getting

1007
00:38:08,270 --> 00:38:10,970
it deployed across the web,
it makes a lot of sense.

1008
00:38:10,970 --> 00:38:13,930
It would make sense for camera
and device makers to store

1009
00:38:13,930 --> 00:38:15,500
these images as WebP natively.

1010
00:38:15,500 --> 00:38:17,820
Literally, you're going to get a
third more images on your SD

1011
00:38:17,820 --> 00:38:18,940
card by using WebP.

1012
00:38:18,940 --> 00:38:21,920
But the reality is they're not
going to do that until there's

1013
00:38:21,920 --> 00:38:25,800
better support in sites across
the web for uploading WebP.

1014
00:38:25,800 --> 00:38:28,110
So we have to get there first
before we can move on to the

1015
00:38:28,110 --> 00:38:28,860
second tier.

1016
00:38:28,860 --> 00:38:33,230
But I think applications like
that make a lot of sense.

1017
00:38:33,230 --> 00:38:33,570
AUDIENCE: Hi.

1018
00:38:33,570 --> 00:38:36,020
I'm curious about photographs
in particular.

1019
00:38:36,020 --> 00:38:39,570
Typically, they come off of the
camera in a JPEG format.

1020
00:38:39,570 --> 00:38:42,290
Re-encoding it-- would you
want to use the lossless

1021
00:38:42,290 --> 00:38:45,690
re-encoding so as to avoid
introducing new artifacts?

1022
00:38:45,690 --> 00:38:49,120
If so, what kind of savings
do you get there?

1023
00:38:49,120 --> 00:38:51,090
And so on and so forth.

1024
00:38:51,090 --> 00:38:52,390
STEPHEN KONIG: You can
certainly do that.

1025
00:38:52,390 --> 00:38:55,030
Even if you take a JPEG and
recompress it as a lossless

1026
00:38:55,030 --> 00:38:57,040
WebP, you're still going to
get byte savings over the

1027
00:38:57,040 --> 00:38:58,100
original source.

1028
00:38:58,100 --> 00:39:00,310
So that definitely still
makes a lot of sense.

1029
00:39:00,310 --> 00:39:02,390
It depends a little bit on the
quality setting that's coming

1030
00:39:02,390 --> 00:39:02,970
out of the camera.

1031
00:39:02,970 --> 00:39:05,800
If the quality is high,
recompressing into a lossy

1032
00:39:05,800 --> 00:39:08,670
WebP, you're really not going to
get anything significant in

1033
00:39:08,670 --> 00:39:10,630
terms of additional compression
artifacts.

1034
00:39:10,630 --> 00:39:12,500
But it is something that--
as you're thinking about

1035
00:39:12,500 --> 00:39:13,890
deploying this-- and one of
the things that we do

1036
00:39:13,890 --> 00:39:16,320
internally is we do a
visual comparison.

1037
00:39:16,320 --> 00:39:19,180
We take like a couple hundred
to 1,000 images.

1038
00:39:19,180 --> 00:39:21,890
And we'll recompress
them as WebPs.

1039
00:39:21,890 --> 00:39:24,090
And we'll compare them against
the original JPEGs and do

1040
00:39:24,090 --> 00:39:25,105
basically an eyeball
comparison.

1041
00:39:25,105 --> 00:39:27,330
And I think that's important
because depending on the

1042
00:39:27,330 --> 00:39:29,436
nature of the images you have on
your site, you may want to

1043
00:39:29,436 --> 00:39:32,830
tweak the quality settings
to get the right mix.

1044
00:39:32,830 --> 00:39:35,170
The other thing I would say on
that, too, is that sometimes

1045
00:39:35,170 --> 00:39:37,780
the issue is about improving
quality with keeping the file

1046
00:39:37,780 --> 00:39:38,590
size constant.

1047
00:39:38,590 --> 00:39:42,410
We see that, too, in some
cases, where the site is

1048
00:39:42,410 --> 00:39:44,520
actually more interested in
saying, you know, gosh, those

1049
00:39:44,520 --> 00:39:46,210
thumbnails we served today
are really crappy.

1050
00:39:46,210 --> 00:39:47,600
They look terrible.

1051
00:39:47,600 --> 00:39:49,570
But we can't afford to increase
the JPEG quality

1052
00:39:49,570 --> 00:39:51,300
because it would cost
more bytes and

1053
00:39:51,300 --> 00:39:52,490
make the page slower.

1054
00:39:52,490 --> 00:39:54,590
WebP is actually a great way
to solve that problem, too.

1055
00:39:54,590 --> 00:39:57,760
So there's lots of different
ways you can use WebP.

1056
00:39:57,760 --> 00:40:00,470
So at the end of the day, it
just becomes a case where you

1057
00:40:00,470 --> 00:40:02,860
have to compare them and get
to the level that you're

1058
00:40:02,860 --> 00:40:04,960
comfortable with based on what
your corpus looks like.

1059
00:40:04,960 --> 00:40:05,275
AUDIENCE: Great.

1060
00:40:05,275 --> 00:40:05,590
Thanks.

1061
00:40:05,590 --> 00:40:07,280
ILYA GRIGORIK: Maybe I'll just
add one more thing, which is

1062
00:40:07,280 --> 00:40:09,830
in our encoder tool, when you
look at different quality

1063
00:40:09,830 --> 00:40:13,280
levels, so you can actually say
75, 80 and others, we also

1064
00:40:13,280 --> 00:40:14,860
have a couple of profiles
built in.

1065
00:40:14,860 --> 00:40:17,060
There's a photo profile
and a few others.

1066
00:40:17,060 --> 00:40:19,210
So I still encourage you to play
with them and kind of get

1067
00:40:19,210 --> 00:40:20,370
a feel for how it looks.

1068
00:40:20,370 --> 00:40:23,940
But there's some presets
in there.

1069
00:40:23,940 --> 00:40:26,160
AUDIENCE: Hi, I've got
three questions.

1070
00:40:26,160 --> 00:40:33,280
The first one is, is there a way
to do soft tiling and sub

1071
00:40:33,280 --> 00:40:35,560
resolution image decoding?

1072
00:40:35,560 --> 00:40:36,920
The first question.

1073
00:40:36,920 --> 00:40:43,150
The second one is, is the key
frames used in VP9 the same

1074
00:40:43,150 --> 00:40:45,680
decoder that WebP is based on?

1075
00:40:45,680 --> 00:40:47,020
And the last question--

1076
00:40:47,020 --> 00:40:49,490
is there any vector instruction
supporting iOS,

1077
00:40:49,490 --> 00:40:52,980
for the iOS library?

1078
00:40:52,980 --> 00:40:54,190
STEPHEN KONIG: So your last
question, I don't know.

1079
00:40:54,190 --> 00:40:56,120
I'll have to follow up
on that for you.

1080
00:40:56,120 --> 00:40:58,610
In terms of VP9, no.

1081
00:40:58,610 --> 00:41:01,430
So the WebP is based
on a VP8 key frame.

1082
00:41:01,430 --> 00:41:03,830
We've looked at, does it make
sense to transition to VP9?

1083
00:41:03,830 --> 00:41:07,070
And for a variety of reasons
that I can get into offline,

1084
00:41:07,070 --> 00:41:08,290
we feel like it doesn't.

1085
00:41:08,290 --> 00:41:12,450
So we're going to be staying
on the VP8 frame for that.

1086
00:41:12,450 --> 00:41:13,040
And I apologize.

1087
00:41:13,040 --> 00:41:14,040
I've forgotten your
first question.

1088
00:41:14,040 --> 00:41:16,760
But we can follow up offline.

1089
00:41:16,760 --> 00:41:17,190
AUDIENCE: OK, yeah.

1090
00:41:17,190 --> 00:41:22,560
It's to do with like 16 K by
16 K texture maps or tiles.

1091
00:41:22,560 --> 00:41:24,670
Can you generate a
thumbnail without

1092
00:41:24,670 --> 00:41:26,520
decoding the entire image?

1093
00:41:26,520 --> 00:41:29,100
That's sub resolution
image decoding.

1094
00:41:29,100 --> 00:41:31,590
And the last one was soft tiling
to grab a region of

1095
00:41:31,590 --> 00:41:33,720
that 16 K without decoding
the entire thing.

1096
00:41:33,720 --> 00:41:35,060
STEPHEN KONIG: We're looking
at techniques like that.

1097
00:41:35,060 --> 00:41:36,400
We don't have direct support
for it today.

1098
00:41:36,400 --> 00:41:37,650
But those are things
we are looking at.

1099
00:41:37,650 --> 00:41:40,500

1100
00:41:40,500 --> 00:41:43,520
AUDIENCE: You guys mentioned
that encoding is 5 to 10 times

1101
00:41:43,520 --> 00:41:47,430
slower compared to JPEG.

1102
00:41:47,430 --> 00:41:49,590
Is there anything
on the horizon

1103
00:41:49,590 --> 00:41:52,410
where that would improve?

1104
00:41:52,410 --> 00:41:54,560
STEPHEN KONIG: So I mentioned
performance optimizations is

1105
00:41:54,560 --> 00:41:55,500
one of the things we're
working on.

1106
00:41:55,500 --> 00:41:59,230
And encoding performance is
probably the top of that list.

1107
00:41:59,230 --> 00:42:02,630
I would say, just in general,
the reason WebP is smaller is

1108
00:42:02,630 --> 00:42:05,160
because we spend more CPU
cycles to compress.

1109
00:42:05,160 --> 00:42:06,970
And we use more sophisticated
algorithms.

1110
00:42:06,970 --> 00:42:09,340
So we will never
get one to one.

1111
00:42:09,340 --> 00:42:11,820
That's just not going
to happen.

1112
00:42:11,820 --> 00:42:13,890
What we're shooting for, our
goal, is somewhere around 2 to

1113
00:42:13,890 --> 00:42:16,040
3x, is where we hope to be.

1114
00:42:16,040 --> 00:42:18,920

1115
00:42:18,920 --> 00:42:22,960
AUDIENCE: I'd like to mix like
JPEG and WebP files in the

1116
00:42:22,960 --> 00:42:24,710
cache on Android.

1117
00:42:24,710 --> 00:42:30,510
Does the WebP native library can
detect that this is a WebP

1118
00:42:30,510 --> 00:42:34,970
image and this is a JPEG image
and decode that too?

1119
00:42:34,970 --> 00:42:38,570
Does it do redirect to JPEG and
PNG bitmap decompression?

1120
00:42:38,570 --> 00:42:39,760
ILYA GRIGORIK: I don't think
the WebP library

1121
00:42:39,760 --> 00:42:40,820
will do that for you.

1122
00:42:40,820 --> 00:42:43,530
But there are great tools
available where you can just

1123
00:42:43,530 --> 00:42:45,670
read the header of the file,
of any file, and basically

1124
00:42:45,670 --> 00:42:48,720
determine the file type and then
just pick the right path

1125
00:42:48,720 --> 00:42:49,420
in your code.

1126
00:42:49,420 --> 00:42:50,910
AUDIENCE: So I have
to do it manually.

1127
00:42:50,910 --> 00:42:52,160
ILYA GRIGORIK: Correct.

1128
00:42:52,160 --> 00:42:54,280

1129
00:42:54,280 --> 00:42:56,160
AUDIENCE: Does the backport
library support all versions

1130
00:42:56,160 --> 00:42:57,140
of Android?

1131
00:42:57,140 --> 00:43:01,240
STEPHEN KONIG: I believe
everything Froyo and above.

1132
00:43:01,240 --> 00:43:03,770
AUDIENCE: Can you provide some
insight on how WebP behaves

1133
00:43:03,770 --> 00:43:09,060
with images that are a
combination of PNG image and

1134
00:43:09,060 --> 00:43:10,210
JPEG image--

1135
00:43:10,210 --> 00:43:12,260
would be great.

1136
00:43:12,260 --> 00:43:15,800
So for example, a screenshot
or something like that.

1137
00:43:15,800 --> 00:43:18,700
STEPHEN KONIG: So I'm not sure
what your question is.

1138
00:43:18,700 --> 00:43:20,680
Can you elaborate
a little bit?

1139
00:43:20,680 --> 00:43:24,390
AUDIENCE: It seems like WebP
is able to behave great on

1140
00:43:24,390 --> 00:43:28,090
photos or to replace PNG.

1141
00:43:28,090 --> 00:43:31,120
What if the image is a
combination of both?

1142
00:43:31,120 --> 00:43:32,760
STEPHEN KONIG: I see.

1143
00:43:32,760 --> 00:43:35,260
So in general, what you saw,
for example, on G+, is that

1144
00:43:35,260 --> 00:43:38,680
WebP does fantastically well
in cases of photos,

1145
00:43:38,680 --> 00:43:40,560
traditional photos you
see from cameras.

1146
00:43:40,560 --> 00:43:42,550
It does really well on just
about everything.

1147
00:43:42,550 --> 00:43:45,730
It just does even better
on things like photos.

1148
00:43:45,730 --> 00:43:47,490
So if you look back in
the slides, I had a

1149
00:43:47,490 --> 00:43:48,880
chart of 1,000 PNGs.

1150
00:43:48,880 --> 00:43:50,180
And they were different
types of PNGs.

1151
00:43:50,180 --> 00:43:52,030
Some of them were photos.

1152
00:43:52,030 --> 00:43:55,720
Some of them are animated,
just drawings.

1153
00:43:55,720 --> 00:43:57,420
Some of them are screenshots.

1154
00:43:57,420 --> 00:44:02,850
And 98 and 1/2, 99% of those
images are smaller in WebP

1155
00:44:02,850 --> 00:44:04,570
than they are in PNG.

1156
00:44:04,570 --> 00:44:07,200
There's a little bit of a thing
at the end where the PNG

1157
00:44:07,200 --> 00:44:08,620
is smaller.

1158
00:44:08,620 --> 00:44:11,750
Those actually are cases where
the image itself is like four

1159
00:44:11,750 --> 00:44:13,750
by four, something
really tiny.

1160
00:44:13,750 --> 00:44:15,970
And what you find out is that
the container for WebP

1161
00:44:15,970 --> 00:44:17,650
actually is bigger than
the image size.

1162
00:44:17,650 --> 00:44:20,840
And so it winds up being bigger
than the original one.

1163
00:44:20,840 --> 00:44:22,470
So if your images are a lot like
that, then I would tell

1164
00:44:22,470 --> 00:44:25,020
you, stick with PNGs.

1165
00:44:25,020 --> 00:44:27,640
The other case that we see that
I highlighted is cases

1166
00:44:27,640 --> 00:44:30,280
where if you're generating
images as part of

1167
00:44:30,280 --> 00:44:31,500
your serving pipeline--

1168
00:44:31,500 --> 00:44:33,930
so you have something that
you're then creating an image

1169
00:44:33,930 --> 00:44:36,940
from, and that's being generated
dynamically.

1170
00:44:36,940 --> 00:44:39,230
It's not so much a visual
quality issue there as more of

1171
00:44:39,230 --> 00:44:40,020
a performance issue.

1172
00:44:40,020 --> 00:44:41,570
Because it takes longer
to encode that

1173
00:44:41,570 --> 00:44:42,730
as WebP versus PNG.

1174
00:44:42,730 --> 00:44:47,070
So that's another case where PNG
would be a better choice.

1175
00:44:47,070 --> 00:44:49,340
But in general, I would just say
what I said earlier, which

1176
00:44:49,340 --> 00:44:51,900
is at the end of the day, you
have to do a visual comparison

1177
00:44:51,900 --> 00:44:53,820
to make sure you're comfortable
and to make sure

1178
00:44:53,820 --> 00:44:56,960
also all the knobs and buttons
and things that we provide to

1179
00:44:56,960 --> 00:44:59,720
let you control those settings
for WebP are where you want

1180
00:44:59,720 --> 00:45:01,870
them to be.

1181
00:45:01,870 --> 00:45:04,120
ILYA GRIGORIK: Right, so maybe
one more thing that I'll add

1182
00:45:04,120 --> 00:45:06,550
is if you guys have any
follow-up questions later

1183
00:45:06,550 --> 00:45:10,550
about WebP, we do have the
WebP-discuss Google group.

1184
00:45:10,550 --> 00:45:11,860
All of our engineers
monitor it.

1185
00:45:11,860 --> 00:45:12,510
We monitor it.

1186
00:45:12,510 --> 00:45:15,660
So if at any point you guys are
experimenting with it or

1187
00:45:15,660 --> 00:45:18,270
have questions about WebP,
please post there.

1188
00:45:18,270 --> 00:45:20,920
And otherwise, thank
you for coming up.

1189
00:45:20,920 --> 00:45:21,520
STEPHEN KONIG: Thanks.

1190
00:45:21,520 --> 00:45:25,557
[APPLAUSE]

