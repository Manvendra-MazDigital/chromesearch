1
00:00:02,200 --> 00:00:06,200
>>Ilya Grogorik: Hi everyone. My name is Ilya
Grigorik. I'm a developer advocate with the

2
00:00:06,200 --> 00:00:12,269
make the web fast team at Google. One of the
projects we have is the PageSpeed family of

3
00:00:12,269 --> 00:00:16,820
products that can help you both automate web
performance and also give you insights about

4
00:00:16,820 --> 00:00:21,360
what are the kinds of things you can do to
improve the performance of your applications.

5
00:00:21,360 --> 00:00:27,190
So first of all, why do we need this? Why
does web performance matter? It is more to

6
00:00:27,190 --> 00:00:32,160
start at the beginning, motivate the use case.
First of all, as you saw during the keynote.

7
00:00:32,160 --> 00:00:35,570
The web of today, the things we are building
on the web are much more ambitious and more

8
00:00:35,570 --> 00:00:42,410
powerful and more complex, in many ways, and
speed is a feature. We are increasingly hearing

9
00:00:42,410 --> 00:00:48,290
this from our partners that are connecting
performance to bottom line things like revenue

10
00:00:48,290 --> 00:00:54,310
and engagement  &mdash; user engagement and other
things. This is not just something that we

11
00:00:54,310 --> 00:00:59,399
feel is getting more complex. In fact, we
can show this. There's a great project called

12
00:00:59,399 --> 00:01:05,180
HP archive which crawls the web and gathers
statistics about how the web is constructed

13
00:01:05,180 --> 00:01:08,939
and how it is changing over time. And what
this graph shows you very clearly is that

14
00:01:08,939 --> 00:01:13,249
the complexity of our pages, the amount of
HTML, JavaScript, the markup we are putting

15
00:01:13,249 --> 00:01:18,840
on our pages is growing very, very fast. If
anything, if you look at this number here,

16
00:01:18,840 --> 00:01:23,700
an average page on the web today is over one
megabyte in size for desktop size and 700

17
00:01:23,700 --> 00:01:29,490
kilobytes in mobile, which is very large.
Most of that is actually images. So if nothing

18
00:01:29,490 --> 00:01:34,439
else, this is a real interesting insight to
say you should optimize your images or 60%

19
00:01:34,439 --> 00:01:39,119
of all the bytes are images. That's the first
constant. The web is getting  &mdash; we are building

20
00:01:39,119 --> 00:01:43,289
more ambitious applications and they are more
complex. The other interesting thing is that

21
00:01:43,289 --> 00:01:50,289
despite the ever-increasing speed of and demand
from users for performance and other things,

22
00:01:50,619 --> 00:01:54,969
an accelerating pace of life, or so it seems,
there are some pretty good constants. There's

23
00:01:54,969 --> 00:01:59,090
good research that shows in order to feel
instant, an interaction needs to be acknowledged

24
00:01:59,090 --> 00:02:04,369
back to the user within basically a couple
hundred milliseconds. If you respond within

25
00:02:04,369 --> 00:02:09,020
200 milliseconds, it feels nearly instant.
Then there is that kind of gray zone around

26
00:02:09,020 --> 00:02:14,900
one second where the user is still engaged
in the task when they click the button but

27
00:02:14,900 --> 00:02:20,019
after you cross that one-second threshold,
you lose the context as a user. So all of

28
00:02:20,019 --> 00:02:23,599
the sudden your context switch, oh, yeah,
I have to send an email to Bob, and follow

29
00:02:23,599 --> 00:02:30,599
up with Jamie. Before you know it, you lost
track of your user, right? And if you go anywhere

30
00:02:31,019 --> 00:02:37,030
above that, basically the user gets disengaged.
The goal for us is to render pages within

31
00:02:37,030 --> 00:02:41,849
one second and preferably actually much faster,
right? We want a seamless experience for our

32
00:02:41,849 --> 00:02:46,430
easers. That's something we care a lot about
at Google. This is great, right? We have this

33
00:02:46,430 --> 00:02:52,719
research, but you might be something at this
point, that's great and all, but really does

34
00:02:52,719 --> 00:02:57,719
it matter? Does it affect my site? The answer
is yes, it does. There are a number of case

35
00:02:57,719 --> 00:03:02,280
studies out there. This was a case study done.
This was a joint research project between

36
00:03:02,280 --> 00:03:07,000
Google and Bing. What we had done is we actually
slowed down  &mdash; intentionally slowed down our

37
00:03:07,000 --> 00:03:11,870
search pages. The results that you are seeing
here are actually from Bing.com where they

38
00:03:11,870 --> 00:03:16,909
added extra latency into their search pages.
They just measured, how does that impact the

39
00:03:16,909 --> 00:03:23,079
use behavior on the site. Do they click more
or less and other things, right? What you

40
00:03:23,079 --> 00:03:27,219
can see is basically there's a lot of red.
There's a lot of negative signs, and when

41
00:03:27,219 --> 00:03:34,219
the add 2,000 milliseconds, two seconds, the
per-user dropped by 4.3%, which is, of course,

42
00:03:34,480 --> 00:03:39,689
a huge number for a big site like Bing and
Google search. Now, this is not only applicable

43
00:03:39,689 --> 00:03:43,640
to large sites, like search sites, but also
across the web in general. This is a great

44
00:03:43,640 --> 00:03:49,280
case study done by [indiscernible] which looked
at 160 large e-commerce sites. What they found

45
00:03:49,280 --> 00:03:56,280
was that adding one second of extra delay
decreased the user conversions. 7%. Fewer

46
00:03:57,379 --> 00:04:04,249
page views and obviously the customer satisfaction
also dropped quite dramatically. So very quickly

47
00:04:04,249 --> 00:04:08,269
this translates into real dollar. This is
not just dollars and cents, this is millions

48
00:04:08,269 --> 00:04:14,519
of dollars for many large sites. And I think
you'll find this is true for your site as

49
00:04:14,519 --> 00:04:18,530
well. So out of that, of course, we have the
web performance optimization industry, or

50
00:04:18,530 --> 00:04:24,020
WPO industry if you have been following the
space. The basic premise of the WPO industry

51
00:04:24,020 --> 00:04:31,020
is we have this waterfall graph. We are using
a lot of requests, 86 requests an average,

52
00:04:31,120 --> 00:04:36,750
for an average page, over one megabyte. What
can we do to this waterfall graph to make

53
00:04:36,750 --> 00:04:41,000
everything look faster? Can we download less?
Can we execute the code faster? You heard

54
00:04:41,000 --> 00:04:44,940
about the great improvements that we are doing
in JavaScript space and rendering performance

55
00:04:44,940 --> 00:04:50,940
in Chrome. What else can we do as app developers?
The platform can advance, but we can do a

56
00:04:50,940 --> 00:04:57,940
lot of things as developers to optimize this.
Of course, there are a lot of best practices

57
00:04:58,280 --> 00:05:03,160
out there, a lot of good tips about how to
optimize this kind of thing. Great books by

58
00:05:03,160 --> 00:05:07,750
Steve Seibers and others. We have techniques
that I think many of us already do in our

59
00:05:07,750 --> 00:05:13,170
applications and things like image compression
resizing, minimizing assets, caching. The

60
00:05:13,170 --> 00:05:18,660
laundry list goes on and on and on and the
question at this point, of course, great.

61
00:05:18,660 --> 00:05:23,720
We have the industry. We have all the best
practices, so why isn't it that all the web

62
00:05:23,720 --> 00:05:29,340
sites are fast by default? I think the answer
here is that a lot of these practices around

63
00:05:29,340 --> 00:05:34,000
performance can actually slow you down in
other ways. For example, doing things like

64
00:05:34,000 --> 00:05:38,390
image spreading means that you need to talk
to your designers and get them think about

65
00:05:38,390 --> 00:05:45,390
image formats and invest in build tool chain
and a lot of these things, frankly, are hacked.

66
00:05:45,980 --> 00:05:52,920
They slow us down. We want to build features,
we want to focus on features in our apps.

67
00:05:52,920 --> 00:05:57,460
Not necessarily think about minute details
of should I concatenate these back and forth.

68
00:05:57,460 --> 00:06:03,800
It's a trade-off,right. It's a feature. It's
a feature that requires a lot of investment.

69
00:06:03,800 --> 00:06:10,690
It is not something you add at the end. You
don't build your app and at the end say, yeah,

70
00:06:10,690 --> 00:06:14,840
we're going to do a performance print to clean
it up, right? That's how you get it wrong.

71
00:06:14,840 --> 00:06:18,700
It needs to be part of your culture. It needs
to be part of the tool chain. So it's a continuous

72
00:06:18,700 --> 00:06:24,540
process. So that's what PageSpeed is all about.
We do three things. PageSpeed tries to help

73
00:06:24,540 --> 00:06:28,880
you identify what are the potential performance
problems currently on your site? Think of

74
00:06:28,880 --> 00:06:34,720
it as a performance Linter for your application.
Second one is just explaining and providing

75
00:06:34,720 --> 00:06:39,680
guidance for how do you address these problems.
The last one, which I think is the most exciting,

76
00:06:39,680 --> 00:06:45,390
is the automation part. We can actually take
a way a lot of the day-to-day work that you

77
00:06:45,390 --> 00:06:51,900
have to do and do it for you, which is great.
So the rest of this talk is split into two

78
00:06:51,900 --> 00:06:56,860
parts. First we will look at the analysis
and then the optimization parts.

79
00:06:56,860 --> 00:07:02,120
On the analysis part, we have a number of
different options that you should play with.

80
00:07:02,120 --> 00:07:05,800
And each one is good in a different context.
We will cover each. And then there's a number

81
00:07:05,800 --> 00:07:10,190
of optimization products. So we have a plug-ins
for your servers that you can install that

82
00:07:10,190 --> 00:07:15,330
will automate a lot of these best practices.
Let's dive in. Let's start with the analysis

83
00:07:15,330 --> 00:07:20,550
part and look at PageSpeed Insights. PageSpeed
Insights is an extension that you can install

84
00:07:20,550 --> 00:07:25,030
in Google Chrome. Go need to go to the Chrome
store, search for PageSpeed Insights. You

85
00:07:25,030 --> 00:07:30,490
will get a new panel in your DevTools that
will give you a lot of nice performance tips.

86
00:07:30,490 --> 00:07:36,390
Let's actually do a live demo. I was getting
a little hungry earlier today. Looking at

87
00:07:36,390 --> 00:07:43,390
redrobin.com, beautiful site, beautiful images.
Nice little gallery here. Let's open up DevTools.

88
00:07:43,830 --> 00:07:50,830
I have the PageSpeed insights extension installed.
I should click here. I can click analyze.

89
00:07:50,840 --> 00:07:54,710
What it will do, it will reload the page.
It will basically monitor all the network

90
00:07:54,710 --> 00:08:00,240
traffic, all of the assets that you're specifying
on the page and run a number different rules

91
00:08:00,240 --> 00:08:05,770
against them and checks against them. So you
can see, great, here's our report. This page

92
00:08:05,770 --> 00:08:11,260
got a score of 49 out of 100. That immediately
tells me there's room for improvement. The

93
00:08:11,260 --> 00:08:14,820
real interesting stuff is actually here on
the left. So if you pay attention here, right,

94
00:08:14,820 --> 00:08:20,170
we basically prioritize a lot of recommendations
on the left saying there's some high priority

95
00:08:20,170 --> 00:08:24,650
things you can take care of right now to help
optimize your page and then there's other

96
00:08:24,650 --> 00:08:30,310
stuff. Let's start at the top. Optimize images.
It turns out this Red Robin page is actually

97
00:08:30,310 --> 00:08:36,460
about 10 megabytes in size every time you
load it. So  &mdash; and we will come back to why

98
00:08:36,460 --> 00:08:42,200
"every time you load it." By optimizing images,
it turns out that red Robin is actually using

99
00:08:42,200 --> 00:08:48,550
PNG images for the beautiful gallery. By just
converting that to a jpeg or a webp, as you

100
00:08:48,550 --> 00:08:53,990
heard during the keynote, we can save 50%
of the bytes sent for this page. We can reduce

101
00:08:53,990 --> 00:08:59,150
the total size of the page is 4.7 megabytes.
This is a huge amount. Think of the difference

102
00:08:59,150 --> 00:09:05,070
this will make both in speed on desktop and
on mobile. One cool little tip that I like

103
00:09:05,070 --> 00:09:10,230
to share PageSpeed insights, how do we know
that we can save all this data? What PageSpeed

104
00:09:10,230 --> 00:09:15,450
insights does is it takes the images and actually
optimizes it when you run the analysis. It

105
00:09:15,450 --> 00:09:19,890
can give you the optimized assets. So you
have this original picture here, right? We

106
00:09:19,890 --> 00:09:26,890
can click on this guy. If I can go back, I
click on see optimize content. This is the

107
00:09:27,100 --> 00:09:33,940
optimized version. Can you guys see the difference
between the two? It's a lot smaller. Right?

108
00:09:33,940 --> 00:09:38,780
It's about 1.5 megabytes smaller. Right there
and then, you can right click on that image

109
00:09:38,780 --> 00:09:43,820
and save it into your application and be done
with it. Right? Step number one, optimizing

110
00:09:43,820 --> 00:09:47,870
images. Then you continue going down the list.
Things like browser caching. So it turns out

111
00:09:47,870 --> 00:09:53,730
we analyzed all of the assets. This site is
not specifying cache control headers. Every

112
00:09:53,730 --> 00:09:58,260
time you visit the page, you have refetch
all of the CSS, JavaScript and the images.

113
00:09:58,260 --> 00:10:03,690
Instead we should be able to cache on a client.
So very simple thing to fix. If you are not

114
00:10:03,690 --> 00:10:07,450
sure what this actually means or how to do
this, click on learn more, it will take you

115
00:10:07,450 --> 00:10:12,450
to the documentation slide to explain that.
Enabling compression, so it turns out  &mdash; we

116
00:10:12,450 --> 00:10:17,460
talked about images compression. But for text-based
assets, things like JavaScript and CSS, the

117
00:10:17,460 --> 00:10:23,580
site also doesn't have JSUP enabled. There's
a lot of savings we can get here. We also

118
00:10:23,580 --> 00:10:28,640
found that there's a lot of small images.
You can put this into a Sprite. You can minimize

119
00:10:28,640 --> 00:10:32,210
JavaScript to get more performance. You can
see how just going through this list, this

120
00:10:32,210 --> 00:10:37,279
is your performance Linter. You can run this
against any web site, your own site, locally

121
00:10:37,279 --> 00:10:41,940
or elsewhere.
So really, really nice tool. This is effectively

122
00:10:41,940 --> 00:10:46,430
when we just went through. That's the PageSpeed
extension. You can install it, run it against

123
00:10:46,430 --> 00:10:51,650
any app locally or remote. That's great. We
also provide the web tools. If you are just

124
00:10:51,650 --> 00:10:58,080
curious to play with it, you can go to our
developers.google.com/speed site. You can

125
00:10:58,080 --> 00:11:02,480
type in any website and we will run all the
same rules against that site and give you

126
00:11:02,480 --> 00:11:07,170
a report card. As you can see here, it all
looks the same. All the same high priority

127
00:11:07,170 --> 00:11:11,450
recommendations. That's because it's the same
code running under the hood. But great way

128
00:11:11,450 --> 00:11:17,130
to capture this. I can send this to my buddies
and say, hey, we've got a performance problem.

129
00:11:17,130 --> 00:11:23,890
We have to address it. If nothing else, a
great way to play with it.

130
00:11:23,890 --> 00:11:28,600
And finally we also have the PageSpeed insights
API. This is great if you really want to take

131
00:11:28,600 --> 00:11:33,650
it to the next level. So now you have some
built infrastructure, you're checking in code,

132
00:11:33,650 --> 00:11:38,090
you have continues builds kicking off every
time you check in code. You can actually script

133
00:11:38,090 --> 00:11:42,690
this and use our PageSpeed rule engine to
run a number of checks against your code or

134
00:11:42,690 --> 00:11:46,779
against your site periodically and basically
build a performance report. We have things

135
00:11:46,779 --> 00:11:51,020
like  &mdash; you can specify strategy. So you can
say, I want to evaluate the rules against

136
00:11:51,020 --> 00:11:55,650
desktop site and mobile site. We have slightly
different rule sets for mobile, for obvious

137
00:11:55,650 --> 00:12:00,650
reasons, right? It's a very different environment.
I want to check for a specific type of rule.

138
00:12:00,650 --> 00:12:04,640
For example, I want to make sure all the images
optimized. There's a lot of fine grain control.

139
00:12:04,640 --> 00:12:08,910
And a lot of tools are integrating or using
PageSpeed Insights API to pull in that extra

140
00:12:08,910 --> 00:12:14,330
meta data. This is a regular Google API. There's
no extra quirks to it. This is just a quick

141
00:12:14,330 --> 00:12:20,880
example in ruby. Really, really handy. So
that's a very quickly an overview of what

142
00:12:20,880 --> 00:12:26,420
you can do by just leveraging PageSpeed to
find performance problems, right? PageSpeed

143
00:12:26,420 --> 00:12:33,420
insights gives you that hands on look. You
can use the web or the native version. And

144
00:12:33,420 --> 00:12:37,750
then you can use the API to script this stuff
and automate a lot of this work.

145
00:12:37,750 --> 00:12:44,670
Now, we built a rule engine that can scan
your pages. It can track what things you should

146
00:12:44,670 --> 00:12:49,440
do. Can't we just do it for you? Like we have
already given you all of this practices. Giving

147
00:12:49,440 --> 00:12:53,250
you the images. Let's go one step further,
right? That's what PageSpeed Optimization

148
00:12:53,250 --> 00:12:58,400
is all about. So we have this core project,
an open source project that can be leveraged

149
00:12:58,400 --> 00:13:03,480
as part of any web server called PageSpeed
Optimization Libraries. It's basically a set

150
00:13:03,480 --> 00:13:09,589
of C++ classes that takes in some input, say
a style sheet or an image file or something

151
00:13:09,589 --> 00:13:16,200
else, and then optimizes that based on a number
of criteria. So how does this actually look?

152
00:13:16,200 --> 00:13:23,200
The way I think about PageSpeed Optimization
is as a performance jit for your site. Just

153
00:13:23,550 --> 00:13:29,060
like V8 takes your JavaScript and does all
kinds of crazy optimizations to make it run

154
00:13:29,060 --> 00:13:35,020
fast, that's what we do on the server except
we are rewriting and optimizing your JavaScript

155
00:13:35,020 --> 00:13:41,470
CSS images and html. All of that is automated
for you. So you don't have to change your

156
00:13:41,470 --> 00:13:46,610
application. I think that's the real exciting
part. We have a ton of sites, over 400,000

157
00:13:46,610 --> 00:13:52,040
sites using PageSpeed today already and there
is a lot of different filters that will do

158
00:13:52,040 --> 00:13:57,940
this work. So let's take a look at what it
actually does. At a very high level, I have

159
00:13:57,940 --> 00:14:02,670
intentionally made these graphs really, really
tiny. The point is not to focus on what are

160
00:14:02,670 --> 00:14:07,170
each of the assets. But basically, once you
turn on PageSpeed this is hopefully what you

161
00:14:07,170 --> 00:14:12,339
see. We try to reduce the number of requests
by concatenating files and applying all the

162
00:14:12,339 --> 00:14:19,339
best practices. It's a better experience for
the user.

163
00:14:27,089 --> 00:14:30,270
So once again, the cool thing about this is
you don't have to modify your application.

164
00:14:30,270 --> 00:14:34,190
We are not talking about adding more build
steps. This is not something that you run

165
00:14:34,190 --> 00:14:39,360
on a check-in and it mangles your code and
rewrites your code. You don't have to bug

166
00:14:39,360 --> 00:14:44,380
your designer buddies to say, hey, you should
pay attention to image compression because

167
00:14:44,380 --> 00:14:50,460
all this is done on the server. This is especially
awesome for things like user-generated content.

168
00:14:50,460 --> 00:14:54,180
It's one thing for us as developers to build
really optimized sites. Then we hand over

169
00:14:54,180 --> 00:15:00,810
the keys to our awesome, fast-performing sites
to our users. They grab their awesome 50 megapixel

170
00:15:00,810 --> 00:15:06,050
or something camera, snap a couple photos
of kittens, throw up the 80 MEG version on

171
00:15:06,050 --> 00:15:10,310
the web, there you are, right, downloading
these high res images. We can automate that

172
00:15:10,310 --> 00:15:13,899
for you.
So here's an example, right?

173
00:15:13,899 --> 00:15:17,940
This is all really abstract. Let's take a
look at a real example. Let's say you have

174
00:15:17,940 --> 00:15:22,560
some code like the one at the top here. So
we have four different style sheets: yellow,

175
00:15:22,560 --> 00:15:26,680
blue, big, and bold. So we know that one of
the best practices is we want to concatenate

176
00:15:26,680 --> 00:15:32,250
files to reduce the number of requests, such
that it downloads faster.

177
00:15:32,250 --> 00:15:37,520
What PageSpeed will do is it will actually
look at the HTML when the server is serving

178
00:15:37,520 --> 00:15:43,140
that HTML and it will actually rewrite all
of those into this command at the bottom.

179
00:15:43,140 --> 00:15:47,940
And basically this is like a  &mdash; this tells
us the exact thing that we need to do to reconstruct

180
00:15:47,940 --> 00:15:51,740
the entire asset, right? You can kind of decipher
it. It basically says "I want you to combine

181
00:15:51,740 --> 00:15:56,470
yellow with blue with big with bold." Dot
PageSpeed is just our extension that says

182
00:15:56,470 --> 00:16:01,870
to our module that "Hey, you should intercept
it in the future." "cc" stands for combined

183
00:16:01,870 --> 00:16:08,390
CSS. And then we provide a fingerprint. And
the fingerprint is important, because when

184
00:16:08,390 --> 00:16:13,040
you change later the contents of any one of
these files and say blue.CSS, you don't want

185
00:16:13,040 --> 00:16:17,980
to think about like do I need to revalidate
the cache, how does this even work with PageSpeed.

186
00:16:17,980 --> 00:16:21,459
We do all of that for you. We fingerprint
each file such that the moment you change

187
00:16:21,459 --> 00:16:26,540
it we automatically rev the version of the
file. You don't need to think about that.

188
00:16:26,540 --> 00:16:29,520
There's no extra build steps there.
And the other cool thing is because we're

189
00:16:29,520 --> 00:16:35,500
fingerprinting this entire file, we can cache-extend
it for a year, right? This plays really, really

190
00:16:35,500 --> 00:16:41,070
nicely with CDNs and all of your caches that
you're running. Squid, Varnish, and other

191
00:16:41,070 --> 00:16:44,630
things.
So that's kind of a cute example with CSS.

192
00:16:44,630 --> 00:16:48,839
I think a more interesting one is images,
because images as we said is 60% of the bytes,

193
00:16:48,839 --> 00:16:52,470
so what can we do there?
Well, let's take a look at this example. We

194
00:16:52,470 --> 00:16:57,680
have an image which is an awesome cat image
and we want to display it at 800 pixels wide,

195
00:16:57,680 --> 00:17:01,399
right?
Now, this is a PNG file and we know that PNGs

196
00:17:01,399 --> 00:17:05,620
are not good for photos, right? They're not
the most efficient format for serving photos,

197
00:17:05,620 --> 00:17:10,199
so that's already kind of a tipoff. Well,
what PageSpeed will do is it will in the background

198
00:17:10,199 --> 00:17:15,309
take this PNG file which is right now 350
kilobytes and it will try to recompress it

199
00:17:15,309 --> 00:17:20,720
using other codecs. So JPEG and WebP. And
it will kind of stash those in the background,

200
00:17:20,720 --> 00:17:25,350
right? So think of it as a background thread
just optimizing these images for you. We haven't

201
00:17:25,350 --> 00:17:29,110
done anything yet.
Then a request comes to a server, and PageSpeed

202
00:17:29,110 --> 00:17:35,519
will actually run a user agent check to say,
"Okay, this is a Chrome browser. Chrome understands

203
00:17:35,519 --> 00:17:42,519
WebP, which means I can serve it a WebP file,"
versus, "Hey, this is an IE user coming, you

204
00:17:43,249 --> 00:17:48,649
know, an older client coming to my site. They
don't understand WebP so I'll serve a JPEG,"

205
00:17:48,649 --> 00:17:50,330
right?
And all of that is completely transparent

206
00:17:50,330 --> 00:17:54,230
to the user and to your application. This
is done by the server.

207
00:17:54,230 --> 00:17:59,379
Then the next thing that we do is we're actually
much smarter than that. We look at the markup

208
00:17:59,379 --> 00:18:04,320
and we notice that you said you want this
image to be 800 pixels wide, right?

209
00:18:04,320 --> 00:18:08,029
We look at the image that's actually on disk
that you've given us and we say is it 800

210
00:18:08,029 --> 00:18:12,470
pixels wide or are you shipping the  &mdash; you
know, the large image and resizing it on the

211
00:18:12,470 --> 00:18:14,679
client?
Well, turns out because this is an awesome

212
00:18:14,679 --> 00:18:19,789
cat picture, he's 8,000 pixels wide, right?
So you would ship the large version, resize

213
00:18:19,789 --> 00:18:24,529
it on the client. Instead, we will resize
it on the server and serve the right image.

214
00:18:24,529 --> 00:18:29,289
So in the end, what PageSpeed will put in
your markup is kind of this cryptic URL at

215
00:18:29,289 --> 00:18:33,119
the bottom which actually is not that cryptic
once you understand what it does. It's encoding

216
00:18:33,119 --> 00:18:39,580
the size of the image, the name.PageSpeed.image
conversion and once again that half. So if

217
00:18:39,580 --> 00:18:42,139
you change your version, we'll just run the
version.

218
00:18:42,139 --> 00:18:47,999
And this basically automates the entire workflow.
We went from PNG to serving a dynamic WebP

219
00:18:47,999 --> 00:18:53,330
file, right? From 350 kilobytes to 60 kilobytes.
And your application hasn't changed. Which

220
00:18:53,330 --> 00:18:57,779
I think is the best part.
So those are just two examples. We have over

221
00:18:57,779 --> 00:19:02,389
40 different optimization filters as part
of PageSpeed. We can do things like rewriting

222
00:19:02,389 --> 00:19:06,820
JavaScript, combining JavaScript. We can defer
JavaScript. So we find that a lot of pages

223
00:19:06,820 --> 00:19:12,739
have blocking, CSS, and JavaScript files which
are blocking rendering. For example, social

224
00:19:12,739 --> 00:19:16,850
widgets and all the rest. Which we can safely
defer until later such that the page paints

225
00:19:16,850 --> 00:19:21,809
and then we add the extra functionality, things
like social widgets and other things.

226
00:19:21,809 --> 00:19:26,289
Simple things  &mdash; or actually they're not simple.
Things like lazy loading of images, right?

227
00:19:26,289 --> 00:19:29,059
How many people here have tried doing lazy
loading of images.

228
00:19:29,059 --> 00:19:30,879
[ Show of hands ]
>>Ilya Grigorik: Right? It's a pain in the

229
00:19:30,879 --> 00:19:36,210
butt, right? It's like which library do I
use and how do I detect the unscroll event?

230
00:19:36,210 --> 00:19:39,739
When do I know it's in my viewport? We take
care of all of that, right? You basically

231
00:19:39,739 --> 00:19:45,960
set one command line flag in your config and
we just do all of that work for you.

232
00:19:45,960 --> 00:19:51,190
So one thing to note is, of course, you know,
this doesn't come for free, necessarily, so

233
00:19:51,190 --> 00:19:56,320
this runs on your server, and it does consume
some extra cycles. But all the optimizations

234
00:19:56,320 --> 00:20:01,309
are done on demand. So for example, you come
and visit my gallery page. We will optimize

235
00:20:01,309 --> 00:20:05,480
the images in the background. Our goal is
to make your site fast and sometimes optimizing

236
00:20:05,480 --> 00:20:09,989
images may take a while, right? Like it may
take a couple hundred milliseconds. We're

237
00:20:09,989 --> 00:20:15,320
not going to slow down your site. On the first
hit, we may actually serve the original image

238
00:20:15,320 --> 00:20:19,609
because we don't want to block the client,
but on a subsequent visit, we will serve the

239
00:20:19,609 --> 00:20:23,539
optimized assets and you guys will see this
in a second.

240
00:20:23,539 --> 00:20:27,619
So the very cool thing about PageSpeed is,
of course, it's an open source project and

241
00:20:27,619 --> 00:20:31,919
we have modules for Apache, Nginx, and we
have a Google hosted version which means that

242
00:20:31,919 --> 00:20:37,019
we've had a lot of partners that have adopted
PageSpeed. And for example, DreamHost, GoDaddy,

243
00:20:37,019 --> 00:20:41,789
and a number of other hosting providers basically
offer it as a toggle button for your Web site,

244
00:20:41,789 --> 00:20:43,850
right?
You literally go into the control panel and,

245
00:20:43,850 --> 00:20:48,179
just like it says, make my site fast. And
that's what it does. It enables PageSpeed

246
00:20:48,179 --> 00:20:51,850
under the hood.
We have CDNs, large CDNs that are deploying

247
00:20:51,850 --> 00:20:55,690
this technology at the edge, such that they
can revalidate your assets on the fly for

248
00:20:55,690 --> 00:20:59,809
you. And of course we're DogFooding it at
Google as well.

249
00:20:59,809 --> 00:21:05,989
Earlier today at the keynote, you guys saw
Linus talk about Chrome data compression,

250
00:21:05,989 --> 00:21:10,440
so the way that works is your phone connects
to a Google server when you send the request,

251
00:21:10,440 --> 00:21:15,119
and then it's the Google servers that fetch
the content that you requested, we optimize

252
00:21:15,119 --> 00:21:19,539
it, and serve you the optimized version, right?
Which gives us a huge savings in data compression

253
00:21:19,539 --> 00:21:22,669
and other things.
And the core of that is actually powered by

254
00:21:22,669 --> 00:21:26,320
a lot of the PageSpeed logic that we've been
just talking about here, so we're reusing

255
00:21:26,320 --> 00:21:30,190
that same technology to drive Chrome data
compression.

256
00:21:30,190 --> 00:21:37,080
And 50% data compression is a huge win for
a lot of users. Bytes are literally expensive

257
00:21:37,080 --> 00:21:42,119
for a lot of people, right?
You can be charged as high as a dollar per

258
00:21:42,119 --> 00:21:45,970
megabyte when you're roaming, so this stuff
adds up really quickly.

259
00:21:45,970 --> 00:21:50,009
So if you guys haven't tried it yet, I'd definitely
encourage you to. Go and download Chrome beta

260
00:21:50,009 --> 00:21:53,950
from the apps store and go into your settings
and enable this and I think you'll notice

261
00:21:53,950 --> 00:21:59,269
that your pages load much, much faster.
Which is yet more motivation to  &mdash; for why

262
00:21:59,269 --> 00:22:04,460
you need to optimize your pages.
This is a great case study. AOL is rolling

263
00:22:04,460 --> 00:22:11,200
out mod_pagespeed which is our Apache plug-in
for PageSpeed, and they're deploying it on

264
00:22:11,200 --> 00:22:15,190
a number of sites. These are the two most
recent ones, both very high traffic sites.

265
00:22:15,190 --> 00:22:20,289
They enabled PageSpeed and they immediately
got 40% and 20% Page Load Time improvement

266
00:22:20,289 --> 00:22:24,529
by just enabling PageSpeed, right? So no applications
changes. Everything is done by the Apache

267
00:22:24,529 --> 00:22:30,100
server. Nice win.
We've been working with ZippyKid, which is

268
00:22:30,100 --> 00:22:34,830
a great hosting provider for Wordpress and
really focused on performance. We ran a number

269
00:22:34,830 --> 00:22:40,269
of tests, so they're actually using the Nginx
plugin for their servers, and they found that,

270
00:22:40,269 --> 00:22:45,299
you know, they're getting a speedup of over
50% and a huge reduction in savings.

271
00:22:45,299 --> 00:22:49,899
So it turns out that Wordpress sites are very
media heavy. Surprise, right? Like that's

272
00:22:49,899 --> 00:22:53,739
 &mdash; that shouldn't be a surprise.
And you can see results like the one on the

273
00:22:53,739 --> 00:22:57,879
 &mdash; on the left here where the original site
was over 7 megabytes in size. Once we ran

274
00:22:57,879 --> 00:23:03,700
the image optimization and other kind of best
practices, we're down to  &mdash; let's see  &mdash; 1

275
00:23:03,700 --> 00:23:07,639
megabyte and a little bit more, right? 1.4
megabytes.

276
00:23:07,639 --> 00:23:12,190
So huge, huge savings.
So how do you get started?

277
00:23:12,190 --> 00:23:16,940
The best place is actually to just go to mod_pagespeed.com
or Nginx_PageSpeed. I think those are  &mdash; those

278
00:23:16,940 --> 00:23:20,499
are two of the most popular servers out there.
It's open source. You can grab it. You can

279
00:23:20,499 --> 00:23:26,769
play with it. We provide the packaging for
it. You can basically grab the RPM and install

280
00:23:26,769 --> 00:23:33,769
it and also a shout-out to a couple of community-developed
modules. So if you're using IIS server, you

281
00:23:34,570 --> 00:23:39,149
can actually also use PageSpeed. There's a
great new project called IIS Speed that's

282
00:23:39,149 --> 00:23:45,259
being developed and gives you the same functionality
within IIS. And also, the guys at LinkedIn

283
00:23:45,259 --> 00:23:50,450
are running PageSpeed and they're using Apache
traffic server, so they're the ones developing

284
00:23:50,450 --> 00:23:53,999
the Apache traffic server module, which I
think is really cool.

285
00:23:53,999 --> 00:24:00,519
So we're all building off the same core and
continuing to improve this infrastructure.

286
00:24:00,519 --> 00:24:05,679
So this is great, right? Like I have my Web
server. I can install this module. I can configure

287
00:24:05,679 --> 00:24:09,399
it. I can do other things.
But there's still more that I can do. I can

288
00:24:09,399 --> 00:24:15,460
still deploy my assets to a CDN. I want to
have some protection against denial of service

289
00:24:15,460 --> 00:24:19,989
attacks. And a number of other features. Wouldn't
it be nice if somebody did all of this work

290
00:24:19,989 --> 00:24:25,259
for you?
And that, in effect, is what PageSpeed service

291
00:24:25,259 --> 00:24:28,379
is.
So this is a beta product and project that

292
00:24:28,379 --> 00:24:33,820
we have at Google today. You can sign up for
it. It's currently in beta. And the way it

293
00:24:33,820 --> 00:24:38,580
works is, the traffic to your site is routed
through Google servers.

294
00:24:38,580 --> 00:24:45,299
So, you know, if you want to get technical,
you create  &mdash; you cname your www domain to

295
00:24:45,299 --> 00:24:50,019
point to Google servers, such that when users
type in, you know, www your site dot com,

296
00:24:50,019 --> 00:24:54,249
they actually hit a Google server. The Google
server then goes to your server and requests

297
00:24:54,249 --> 00:24:59,330
the actual content. It grabs that content,
does all of the optimization, saves all of

298
00:24:59,330 --> 00:25:03,989
the optimized assets in the Google cloud,
in the Google CDN, and, you know, we have

299
00:25:03,989 --> 00:25:09,779
a few servers around the world to do that
kind of thing, and serves the optimized assets.

300
00:25:09,779 --> 00:25:15,609
So you're getting the benefit of CDN and dynamic
optimization, which is really, really cool.

301
00:25:15,609 --> 00:25:19,979
So I actually have it running on my site and
I want to show you guys a demo of how this

302
00:25:19,979 --> 00:25:25,399
works in practice.
So here I am. Here's my site. I have this

303
00:25:25,399 --> 00:25:30,979
beautiful little gallery of, you know, my
favorite travel photos. I  &mdash; I love them in

304
00:25:30,979 --> 00:25:35,200
all of their high-res glory because I'm a
photographer and I would never think about,

305
00:25:35,200 --> 00:25:39,220
you know, doing anything less, but I think
we can do a lot better, right? So if you go

306
00:25:39,220 --> 00:25:43,259
to the network tab and if we just sort the
file size on the page, you can see that there's

307
00:25:43,259 --> 00:25:49,899
three images, Tokyo, Oxford, and Aurora, weighing
in at about 3 megabytes and they're served

308
00:25:49,899 --> 00:25:54,489
as PNG files. That's how I saved them as.
I think we can do better.

309
00:25:54,489 --> 00:26:01,489
So I have PageSpeed service running on my
site. If I go to my Google API console, I'm

310
00:26:01,659 --> 00:26:06,169
looking at the PageSpeed service tab here.
Let's go to "Overview." So basically what's

311
00:26:06,169 --> 00:26:10,409
happening here is here's my origin server,
PageSpeed server, so the Google servers are

312
00:26:10,409 --> 00:26:16,479
in between, and if we go to configure rewriters,
this is where all of the magic happens, right?

313
00:26:16,479 --> 00:26:21,559
We  &mdash; we basically have a set of check boxes
and let me make that a little bit bigger.

314
00:26:21,559 --> 00:26:25,999
Oops, that's not blowing up.
We have a set of check boxes that just allow

315
00:26:25,999 --> 00:26:31,989
you to apply optimizations without actually
modifying your app. So for example, I'm concerned

316
00:26:31,989 --> 00:26:38,210
about images, so let's go into optimize images
and I want to do a few things.

317
00:26:38,210 --> 00:26:42,179
So I want to resize images on the server,
such that if I'm serving a file size of  &mdash; or

318
00:26:42,179 --> 00:26:46,619
an image that is larger than what I meant
to display, just optimize it for me.

319
00:26:46,619 --> 00:26:52,169
And also convert PNG files to JPEG.
That sounds about like what I want, right?

320
00:26:52,169 --> 00:26:58,419
I'm serving PNGs so let me save that.
I'm going to apply this to the live site and

321
00:26:58,419 --> 00:27:02,129
we're going to refresh the site.
And we're actually going to do this twice.

322
00:27:02,129 --> 00:27:04,789
And the reason we do this twice is remember
what I said earlier, we don't want to slow

323
00:27:04,789 --> 00:27:10,840
down the site? So the first time we may server
the unoptimized asset or the original asset,

324
00:27:10,840 --> 00:27:14,809
but then on the next load, you can see that
the filename has changed. It now has this

325
00:27:14,809 --> 00:27:19,149
PageSpeed URL and now it's being served as
a JPEG. So what PageSpeed service has done

326
00:27:19,149 --> 00:27:22,769
 &mdash; notice that I haven't  &mdash; like I haven't
done anything on my site, right? The Google

327
00:27:22,769 --> 00:27:26,499
cloud is handling all of this. It's rewritten
the image, it's fingerprinted the image, and

328
00:27:26,499 --> 00:27:33,499
it's serving a JPEG, and the images, they're
the same size. That's not good. There we go.

329
00:27:34,919 --> 00:27:40,759
That was just a caching error. So a hundred
kilobytes versus one megabyte, right? But

330
00:27:40,759 --> 00:27:45,070
I think we can do better, right? So right
now, our image  &mdash; our total size of this page

331
00:27:45,070 --> 00:27:52,070
is 467 kilobytes so let's go back to the console
and also enable convert JPEG to WebP and  &mdash; sure,

332
00:27:52,220 --> 00:27:56,649
let's just enable it all. Why not. And apply
to live. And we're going to do the same test

333
00:27:56,649 --> 00:28:00,059
again so we'll refresh it again.
Now, Chrome, of course, understands WebP,

334
00:28:00,059 --> 00:28:06,080
so in theory we should see WebP images coming
through once they're optimized, and there

335
00:28:06,080 --> 00:28:12,970
they are. So we have the WebP  &mdash; let's just
re-share  &mdash; resort here.

336
00:28:12,970 --> 00:28:17,249
So we have the Tokyo file. It's now at 81
kilobytes. Previously it was 120. And the

337
00:28:17,249 --> 00:28:22,649
total size of the page is 328 kilobytes. So
we went from a page that's over 3 megabytes

338
00:28:22,649 --> 00:28:28,609
to 328 kilobytes. That's a 10X improvement,
right? And I didn't have to modify my application.

339
00:28:28,609 --> 00:28:32,809
The images are rescaled on the server and
served in the best possible format.

340
00:28:32,809 --> 00:28:36,539
If we were to open this in IE, it would just
serve a JPEG. I don't have to worry about

341
00:28:36,539 --> 00:28:41,460
that.
So that's pretty awesome.

342
00:28:41,460 --> 00:28:46,019
Now, this works, of course, for any site that
you host on, you know, any hosting provider.

343
00:28:46,019 --> 00:28:50,389
You just need to cname your site. But if you're
using AppEngine, you can also take advantage

344
00:28:50,389 --> 00:28:55,059
of Google PageSpeed service.
What you need to do  &mdash; and unfortunately it's

345
00:28:55,059 --> 00:28:59,970
a little bit small here  &mdash; you can modify
your app.yaml file, and you have good documentation

346
00:28:59,970 --> 00:29:04,489
how to do this, and you can just specify which
filters you want PageSpeed service to apply.

347
00:29:04,489 --> 00:29:08,899
And before the request gets routed to your
application server, it will actually be processed

348
00:29:08,899 --> 00:29:14,029
by our PageSpeed service proxy and it will
do all this work for you.

349
00:29:14,029 --> 00:29:19,679
So we ran this experiment on HTML5 Rocks.
I'm sure you guys have seen the site. If not,

350
00:29:19,679 --> 00:29:23,889
I encourage you to. Lots of great material.
It's actually an AppEngine app. It's a Python

351
00:29:23,889 --> 00:29:27,029
AppEngine app. It's open source. You can actually
check it out on Github and you can check the

352
00:29:27,029 --> 00:29:33,359
exact modules and optimizations we're applying.
So we used Google Analytics to run an experiment

353
00:29:33,359 --> 00:29:38,190
and say what happens if we enable PageSpeed
service and then disable it? So we ran an

354
00:29:38,190 --> 00:29:45,190
A/B test, and, you know, we added six or seven
lines, whatever it is, to our app.yaml file

355
00:29:45,749 --> 00:29:51,499
and we made our site 10% faster. This is as
measured by Page Load Time, right? And there's

356
00:29:51,499 --> 00:29:55,979
another  &mdash; a number of other metrics which
we've improved as well.

357
00:29:55,979 --> 00:30:02,979
So this is a huge, huge win.
Especially for seven lines of modifications.

358
00:30:03,029 --> 00:30:08,200
So I think the takeaway here is automating
Web performance best practices offers a lot

359
00:30:08,200 --> 00:30:12,789
of benefits. First of all, performance is
a continuous process, it's not a checklist

360
00:30:12,789 --> 00:30:16,349
item, it's not something that you add at the
end. Right? So building or leveraging these

361
00:30:16,349 --> 00:30:22,049
automated tools allows us to just not worry
about that.

362
00:30:22,049 --> 00:30:25,820
The other thing is, we just don't have to
worry about things anymore, a lot of things

363
00:30:25,820 --> 00:30:30,489
anymore. So for example, when I save my images
on my own site, I just save them as whatever

364
00:30:30,489 --> 00:30:33,570
format I'm working with, right? Like I'll
save them as a PNG. I don't have to think

365
00:30:33,570 --> 00:30:38,580
about what is the optimal format for this
image. I'll let the computer or the servers

366
00:30:38,580 --> 00:30:42,129
figure that out for me. I can just go into
my control panel and kind of fiddle with the

367
00:30:42,129 --> 00:30:46,109
quality of what goes in and other things.
Not only that but I can also dynamically adjust

368
00:30:46,109 --> 00:30:51,859
the quality based on the client, right? Maybe
for a mobile site, you want to serve slightly

369
00:30:51,859 --> 00:30:55,779
lower quality images because the screens are
smaller, and frankly, the users won't notice,

370
00:30:55,779 --> 00:30:59,190
but that's a huge byte savings that you could
have.

371
00:30:59,190 --> 00:31:02,799
These kinds of things you can't do manually,
right? How do you implement that in your application?

372
00:31:02,799 --> 00:31:06,460
You would have to do  &mdash; use JavaScript with,
you know, detection of the client. It's a

373
00:31:06,460 --> 00:31:09,299
mess, right?
Let the server handle that for you.

374
00:31:09,299 --> 00:31:13,989
Not only that, but we can do dynamic optimizations
that you can't, frankly, do manually, right?

375
00:31:13,989 --> 00:31:19,249
So you saw us serving WebP files. That would
be a disaster to build into your application,

376
00:31:19,249 --> 00:31:24,460
right? It's doable but it's hard.
And then there's things like work on HTTP

377
00:31:24,460 --> 00:31:30,849
2.0 and SPDY, so our SPDY protocol is now
being standardized as HTTP 2.0 and they're

378
00:31:30,849 --> 00:31:34,379
adding a lot of great new improvements to
it, and frankly, it's going to address a lot

379
00:31:34,379 --> 00:31:38,679
of the problems that we have to deal with
today. Things like concatenating files? We

380
00:31:38,679 --> 00:31:43,190
don't have to do that anymore with HTTP 2.0.
Right? So now that all of you guys have concatenated

381
00:31:43,190 --> 00:31:46,710
all of your files, please go ahead and undo
all of that, because that's what you do to

382
00:31:46,710 --> 00:31:51,289
improve performance on HTTP 2.0, right? But
then how do you serve the optimized version

383
00:31:51,289 --> 00:31:56,119
for both, right? Because HTTP 2.0 is not going
to come overnight. It will take a while. And

384
00:31:56,119 --> 00:31:59,969
this is where automation can come in. This
is where the server can automatically decide

385
00:31:59,969 --> 00:32:04,090
and figure out like, "Hey, you're an HTTP
2.0 client. I just won't do this class of

386
00:32:04,090 --> 00:32:11,090
optimizations for you," right? So this is
a great reason to invest into this  &mdash; into

387
00:32:11,179 --> 00:32:14,169
these kinds of tools. And frankly, at the
end of the day it just allows you to focus

388
00:32:14,169 --> 00:32:19,969
on your application. So with that, we have
a little bit of time for questions, and if

389
00:32:19,969 --> 00:32:25,749
you guys can, please grab one of the mics.
>>> Thank you. This is really awesome.

390
00:32:25,749 --> 00:32:30,129
Two questions. Firstly, retina images. Any
thoughts on that?

391
00:32:30,129 --> 00:32:34,869
>>Ilya Grigorik: Yeah. So retina images is
a big discussion, I think, in the web community

392
00:32:34,869 --> 00:32:41,440
today. We're looking at a couple of solutions
for serving high DPI images, like 2X images.

393
00:32:41,440 --> 00:32:47,299
We don't have any built-in filters today,
but we have some in the works, and right now,

394
00:32:47,299 --> 00:32:51,999
I guess the problem is we don't have a generic
way to do that across browsers.

395
00:32:51,999 --> 00:32:56,539
>>> Okay. And sorry, the second one, the service
looks even better. Is that something you expect

396
00:32:56,539 --> 00:32:58,929
to be a paid service when it comes out of
beta?

397
00:32:58,929 --> 00:33:02,940
>>Ilya Grigorik: PageSpeed? Right. So PageSpeed
service is in beta right now. It is free while

398
00:33:02,940 --> 00:33:06,559
it's in beta and we are still trying to determine
what is the right module to actually, you

399
00:33:06,559 --> 00:33:11,330
know, charge for it and all the rest. Because
it is being served through the Google cloud

400
00:33:11,330 --> 00:33:14,659
and, you know, there's  &mdash; there may be some
additional fee in the future,

401
00:33:14,659 --> 00:33:17,909
But I don't think we have a good answer yet.
Yeah.

402
00:33:17,909 --> 00:33:21,599
>>> Thank you.
>>> Can PageSpeed help you if you use a single-page

403
00:33:21,599 --> 00:33:25,960
Web app who loads its content using Ajax?
>>Ilya Grigorik: Yeah, so can PageSpeed help

404
00:33:25,960 --> 00:33:31,830
us with single-page apps? Perhaps not as much,
right, because you are probably doing a lot

405
00:33:31,830 --> 00:33:37,599
of the loading through JavaScript over your
assets and all the rest. But you can  &mdash; if

406
00:33:37,599 --> 00:33:44,169
you leverage things like just regular image
tags and other things, you can configure PageSpeed

407
00:33:44,169 --> 00:33:48,940
to do transparent rewriting and optimization
of images.

408
00:33:48,940 --> 00:33:53,599
I showed you examples where you rewrite the
URL. You can actually configure it the other

409
00:33:53,599 --> 00:33:58,629
way around such that the image is  &mdash; the URL
is the same and then still leverage some of

410
00:33:58,629 --> 00:34:03,229
the functionality.
>>> All right. Thank you.

411
00:34:03,229 --> 00:34:10,229
>>> Let me interrupt you. Sorry. So as a Rails
developer, are there any caveats that we have

412
00:34:10,299 --> 00:34:14,500
to worry about when developing more dynamic
apps? Is this suitable for just sort of static

413
00:34:14,500 --> 00:34:18,289
pages? Or what's the  &mdash; or what do we need
to know about using PageSpeed for dynamic

414
00:34:18,289 --> 00:34:20,039
things?
>>Ilya Grigorik: I don't think there are any

415
00:34:20,039 --> 00:34:24,960
constraints whether it is a static app or
a dynamic app. It really doesn't matter.

416
00:34:24,960 --> 00:34:29,579
So the way PageSpeed works, it basically intercepts
your request at the very end before it gets

417
00:34:29,579 --> 00:34:33,020
served by the server. So it doesn't matter
who generated.

418
00:34:33,020 --> 00:34:37,159
For Rails specifically, Rails, of course,
has asset pipeline and other things that try

419
00:34:37,159 --> 00:34:41,020
to do a lot of this work at deploy time, right,
concatenating files and all the rest.

420
00:34:41,020 --> 00:34:43,809
I would actually say you don't need to do
that anymore. You don't have to worry about

421
00:34:43,809 --> 00:34:48,799
it. PageSpeed will do all of that for you,
plus more, because we can do dynamic optimizations.

422
00:34:48,799 --> 00:34:55,669
>>> So quick question. With the beta that
you have running, is there an upper limit

423
00:34:55,669 --> 00:35:00,020
on the number of assets that we could have
cached if I want to do A/B testing for my

424
00:35:00,020 --> 00:35:02,760
company?
>>Ilya Grigorik: No, there's no limit on that.

425
00:35:02,760 --> 00:35:09,400
>>> Okay. And just to sort of  &mdash; to tag onto
the previous gentleman's question, how would

426
00:35:09,400 --> 00:35:13,770
PageSpeed handle something, like I said, of
using RequireJS or something where we're sort

427
00:35:13,770 --> 00:35:20,770
of doing, like, lazy load of static assets?
>>Ilya Grigorik: Yeah. So we have our own

428
00:35:20,950 --> 00:35:26,599
filters that do, for example, defer JavaScript,
right, which will grab your code and actually

429
00:35:26,599 --> 00:35:30,130
wrap it in our own kind of markup to defer
it to load later.

430
00:35:30,130 --> 00:35:34,549
So RequireJS is effectively that, but you
are doing it manually.

431
00:35:34,549 --> 00:35:40,079
We don't have  &mdash; and it would be very hard
to build scripts that introspect into RequireJS.

432
00:35:40,079 --> 00:35:44,430
So we may not be able to as much if you are
doing this kind of dynamic construction of

433
00:35:44,430 --> 00:35:46,760
the page.
But that's really an area that we are looking

434
00:35:46,760 --> 00:35:50,140
for feedback from you guys as well because,
you know, I think these are  &mdash; these are the

435
00:35:50,140 --> 00:35:55,010
new apps that are being built. So if there
is more interest in that, we'll start looking

436
00:35:55,010 --> 00:35:58,279
in that direction.
>>> Thank you.

437
00:35:58,279 --> 00:36:05,279
>>> I actually have three questions. One is
can we use this with sites that have SSL enabled?

438
00:36:06,599 --> 00:36:09,339
I wouldn't be comfortable giving Google my
SSL certificate.

439
00:36:09,339 --> 00:36:15,200
>>Ilya Grigorik: Yeah, so for SSL, the answer
is yes. Basically, you would determine your

440
00:36:15,200 --> 00:36:20,069
SSL at your server, right? So, okay, there
is a couple, I guess, questions.

441
00:36:20,069 --> 00:36:23,529
Open source or PageSpeed service?
>>> The PageSpeed service.

442
00:36:23,529 --> 00:36:27,380
>>Ilya Grigorik: For PageSpeed service, you
would have to upload your certificates to

443
00:36:27,380 --> 00:36:32,829
one of our servers, so I have it set up on
my site. You can actually try it. I upload

444
00:36:32,829 --> 00:36:36,510
the certificate and the connection is terminated
at the Google server.

445
00:36:36,510 --> 00:36:42,279
>>> Okay. The second question I had was how
much of an additional load in terms of CPU

446
00:36:42,279 --> 00:36:46,510
and memory does PageSpeed module add onto
Apache or Nginx?

447
00:36:46,510 --> 00:36:53,510
>>Ilya Grigorik: That's a great question.
For example, it can take a while, right, hundreds

448
00:36:54,640 --> 00:37:00,980
of milliseconds to do.
So I think it is giving me the boot.

449
00:37:00,980 --> 00:37:04,500
So what we do is we actually give you knobs
to control how much resources you are willing

450
00:37:04,500 --> 00:37:09,299
to give the server. So, for example, you can
tweak the number of threads that we will employ

451
00:37:09,299 --> 00:37:15,020
in the background to optimize the stuff. You
can also tweak the size of our cache. For

452
00:37:15,020 --> 00:37:20,529
multi-server deployments, we actually provide
mem cache  &mdash; caching. Instead of storing the

453
00:37:20,529 --> 00:37:25,029
optimized assets on just one server, you can
share it across a cluster of servers.

454
00:37:25,029 --> 00:37:29,220
So there is a lot of knobs. I didn't cover
these here. There is a lot of great documentation

455
00:37:29,220 --> 00:37:32,110
that we have on our site that you can look
into.

456
00:37:32,110 --> 00:37:35,520
>>> Can we extend the PageSpeed module with
additional filters?

457
00:37:35,520 --> 00:37:39,710
>>Ilya Grigorik: Can you say that again, sorry?
>>> Can we extend the module with additional

458
00:37:39,710 --> 00:37:44,420
filters, if you want to write out custom filters
to do some optimizations?

459
00:37:44,420 --> 00:37:48,099
>>Ilya Grigorik: Oh, sure, yeah. It is an
open source project. Actually, the guy standing

460
00:37:48,099 --> 00:37:53,309
behind you is the guy to talk to.
You can contribute new filters. We would love

461
00:37:53,309 --> 00:38:00,109
your participation. If you want to, we have
a very active mod PageSpeed discussion group.

462
00:38:00,109 --> 00:38:02,350
Just ping us there and we are happy to talk
about it.

463
00:38:02,350 --> 00:38:06,240
>>> Thank you.
>>> Hi. So a lot of applications these days

464
00:38:06,240 --> 00:38:11,059
are written using clientside templating frameworks
like Ember, Angular, Backbone. How does this

465
00:38:11,059 --> 00:38:15,720
play with serving up static templates and
any of the  &mdash;

466
00:38:15,720 --> 00:38:19,599
>>Ilya Grigorik: So, the short answer is I
don't think we have a good answer for that

467
00:38:19,599 --> 00:38:25,799
today. We are basically  &mdash; we rely on being
able to analyze your HTML, your markup, plus

468
00:38:25,799 --> 00:38:32,029
the JavaScript and CSS assets. We discover
those in part through analyzing your HTML.

469
00:38:32,029 --> 00:38:34,559
So there may not be as much that we can do
there.

470
00:38:34,559 --> 00:38:40,289
You can configure the server as I mentioned
earlier to do transparent rewriting of images

471
00:38:40,289 --> 00:38:44,079
and a few other things.
But I think that's an area that we can definitely

472
00:38:44,079 --> 00:38:51,010
do more in, in the future.
>>> Hi. I'm Josh,(saying name). I work on

473
00:38:51,010 --> 00:38:56,900
the PageSpeed optimization project. I wanted
to point out that actually just to this point

474
00:38:56,900 --> 00:39:02,829
and the one made earlier, if you have  &mdash; if
you are loading assets via JavaScript, we

475
00:39:02,829 --> 00:39:07,660
do a pretty good job of optimizing them.
What we don't know is the sizing context because

476
00:39:07,660 --> 00:39:12,630
we just get to  &mdash; we get a request for a JPEG
file and we optimize that based on whatever

477
00:39:12,630 --> 00:39:17,130
the user agent is. We don't know how big it
was supposed to  &mdash; what slot it was supposed

478
00:39:17,130 --> 00:39:20,480
to go in. And we can't change its cache lifetime
if we can't change its URL.

479
00:39:20,480 --> 00:39:25,390
>>Ilya Grigorik: Yep.
>>> But the on-the-fly transcoding that you

480
00:39:25,390 --> 00:39:32,049
get for reducing image size and bandwidth
for Android browsers that uses that flow.

481
00:39:32,049 --> 00:39:36,579
>>Ilya Grigorik: One note to that. As you
guys probably have noticed, we have a performance

482
00:39:36,579 --> 00:39:43,579
area in the Chrome booth section. And we have
a big contingent from the PageSpeed family

483
00:39:44,779 --> 00:39:48,220
of products hanging out there. If you guys
want to talk to us about specific questions,

484
00:39:48,220 --> 00:39:51,640
how to implement stuff or just have ideas,
please drop by.

485
00:39:51,640 --> 00:39:56,940
>>> Yeah. That's just about Java. You showed
us how to implement that on that page using

486
00:39:56,940 --> 00:40:03,940
Python. Do you have any examples in Java?
And you showed us the URL to get to the beta.

487
00:40:04,960 --> 00:40:08,660
If you could share with us these slides or
go back to the URL?

488
00:40:08,660 --> 00:40:12,740
>>Ilya Grigorik: I will take the last one
first. So if you just use your favorite search

489
00:40:12,740 --> 00:40:17,880
engine and look for PageSpeed service, you
will land directly on the link that you need.

490
00:40:17,880 --> 00:40:21,450
That's the simplest way to get there. And
then the other one was  &mdash; question was Java

491
00:40:21,450 --> 00:40:24,859
versus Python examples.
>>> Yeah, you showed us the Python example

492
00:40:24,859 --> 00:40:29,660
and how to do that on yaml file.
>>Ilya Grigorik: Oh, sure. Yeah, the great

493
00:40:29,660 --> 00:40:36,279
thing about PageSpeed service is, it is completely
agnostic of the runtime that you are using.

494
00:40:36,279 --> 00:40:40,160
There is no difference between Java, Python,
and all the rest.

495
00:40:40,160 --> 00:40:45,170
If you go to the Google AppEngine documentation
and just search for PageSpeed, you will have

496
00:40:45,170 --> 00:40:48,650
the specific commands that you need in there.
>>> Awesome. Thank you.

497
00:40:48,650 --> 00:40:52,670
>>Ilya Grigorik: Yep.
>>> Thank you. Hi. I have been using PageSpeed

498
00:40:52,670 --> 00:40:57,329
service for a while and it is pretty impressive.
And I have one question, is that you mentioned

499
00:40:57,329 --> 00:41:02,279
you deployed several servers and words to
get  &mdash; to make the optimization.

500
00:41:02,279 --> 00:41:06,470
>>Ilya Grigorik: Yeah.
>>> So we know in order to make the optimization,

501
00:41:06,470 --> 00:41:12,640
you need to make several subsequent  &mdash; subrequests
of the first requests. So I was wondering,

502
00:41:12,640 --> 00:41:19,640
can you share a little bit about your global
deployment and the method you used to determine

503
00:41:20,390 --> 00:41:25,829
the closest server for optimization.
>>Ilya Grigorik: So, thankfully, we actually

504
00:41:25,829 --> 00:41:29,599
on PageSpeed service don't necessarily need
to do anything. This is part of the global

505
00:41:29,599 --> 00:41:34,910
Google caching policy, right? Whenever you
issue a request to Google Search, we try to

506
00:41:34,910 --> 00:41:38,500
determine what is the closest location. We
can do that through DNS, through I.P. lookups.

507
00:41:38,500 --> 00:41:42,150
There is a variety of different methods. And
we just leverage all of that infrastructure

508
00:41:42,150 --> 00:41:45,109
at PageSpeed.
So, basically, your site is getting deployed

509
00:41:45,109 --> 00:41:49,440
on the same infrastructure that is powering
Google Search and other things, all right?

510
00:41:49,440 --> 00:41:55,460
So picking the closest server to the user
is just part of the magic, if you will. It

511
00:41:55,460 --> 00:41:59,140
is not something you need to configure at
all or worry about within your application.

512
00:41:59,140 --> 00:42:01,869
>>> Thank you.
>>Ilya Grigorik: Yep.

513
00:42:01,869 --> 00:42:07,589
>>> Are there any optimizations that are device-dependent?
So, for instance, having images that would

514
00:42:07,589 --> 00:42:10,839
be more optimized for mobile devices versus
browsers?

515
00:42:10,839 --> 00:42:17,539
>>Ilya Grigorik: The answer is absolutely
yes. The best one is the WebP example I shared.

516
00:42:17,539 --> 00:42:22,170
Only certain user agents are able to use it.
Another example would be leveraging local

517
00:42:22,170 --> 00:42:27,529
storage. So not all clients are able to leverage
local search, and we actually have a filter

518
00:42:27,529 --> 00:42:30,519
that can use local storage as a cache for
your assets.

519
00:42:30,519 --> 00:42:33,890
And we will deploy those optimizations conditionally.
And Josh is going to  &mdash;

520
00:42:33,890 --> 00:42:39,609
>>> Yeah, you can also say for small screens
compress more aggressively than for large

521
00:42:39,609 --> 00:42:41,400
screens.
>>Ilya Grigorik: Yep, yep.

522
00:42:41,400 --> 00:42:45,890
>>> So kind of a follow-up on that, both for
the service as well as for something like

523
00:42:45,890 --> 00:42:50,849
mod PageSpeed, how is the universe of user
agents that are being identified to optimize

524
00:42:50,849 --> 00:42:54,799
for being managed and the frequency with which
it gets updated?

525
00:42:54,799 --> 00:43:00,920
>>Ilya Grigorik: So we  &mdash; Right. So we test
the stuff very extensively. All the code is

526
00:43:00,920 --> 00:43:05,230
open source.
Josh, do you want to share any details? I

527
00:43:05,230 --> 00:43:10,740
think  &mdash; so one thing I didn't mention, I
had in those slides, we have two sets of filters,

528
00:43:10,740 --> 00:43:17,740
COR and optional filters. COR filters are
the safe filters. They should be  &mdash; can be

529
00:43:17,940 --> 00:43:23,950
applied to any site without any risk or minimal
risk on the site in terms of modifying the

530
00:43:23,950 --> 00:43:26,710
look and feel.
And then there's an extended list of other

531
00:43:26,710 --> 00:43:31,619
optimizations which we can do on a per-user-agent
basis and the rest.

532
00:43:31,619 --> 00:43:38,119
>>> So in the open source world, we have to
kind of cut releases and ship product. So

533
00:43:38,119 --> 00:43:45,000
we have  &mdash; we take kind of a white-listing
view of what we can do for different browsers.

534
00:43:45,000 --> 00:43:49,869
So if you are using mod PageSpeed from last
month and this month there is a new device

535
00:43:49,869 --> 00:43:54,019
that can support WebP, we won't know about
it.

536
00:43:54,019 --> 00:43:58,760
>>Ilya Grigorik: Back in November of last
year, we shipped the 1.0 of mod PageSpeed.

537
00:43:58,760 --> 00:44:03,160
And when we did that switch, we are shipping
two channels. There is a beta channel, and

538
00:44:03,160 --> 00:44:07,029
there is a stable channel, very similar to
Chrome.

539
00:44:07,029 --> 00:44:10,559
If you want to be on the edge and try all
the latest optimizations that's where you

540
00:44:10,559 --> 00:44:15,900
would be. If you are a little bit more nervous
about how this will work across all the devices,

541
00:44:15,900 --> 00:44:19,750
you should stick with the stable channel.
>>> Another question is, all this is awesome

542
00:44:19,750 --> 00:44:25,260
to have it happen Automagically. When it does
that, does it also output reports so you can

543
00:44:25,260 --> 00:44:29,490
go back to your developers and say: Hey, you
should code better and this is how.

544
00:44:29,490 --> 00:44:33,589
>>Ilya Grigorik: That's PageSpeed insights.
We are effectively taking that same engine,

545
00:44:33,589 --> 00:44:35,940
or the same rules and just automating all
of that for you.

546
00:44:35,940 --> 00:44:38,779
>>> Does it output of what it's actually done
so you can go back without having to run it

547
00:44:38,779 --> 00:44:42,920
through insights on its own? Do you get some
logging of, Hey, we did these concatenations

548
00:44:42,920 --> 00:44:45,799
aside from the image optimization.
>>Ilya Grigorik: That's interesting. I don't

549
00:44:45,799 --> 00:44:50,109
think we actually  &mdash; we do have a statistics
screen where we can go and kind of gather

550
00:44:50,109 --> 00:44:54,890
some data about what is a server doing. How
is it doing to tune its performance? We don't

551
00:44:54,890 --> 00:45:00,140
have an audit log today to say, like, these
are the explanations we have performed.

552
00:45:00,140 --> 00:45:04,720
>>> Okay. Thank you.
>>> I realize we are wrapping up. I will go

553
00:45:04,720 --> 00:45:10,470
quick. Is there any danger zones, things you
should not use  &mdash; not do  &mdash; not  &mdash; if you

554
00:45:10,470 --> 00:45:13,609
are using this, you should probably not use
PageSpeed on your server if, we are using

555
00:45:13,609 --> 00:45:17,940
open source Apache and Nginx models?
>>Ilya Grigorik: Sorry, can you  &mdash;

556
00:45:17,940 --> 00:45:24,940
>>> Talking too fast. If I'm doing X, then
is there something that I  &mdash; should I not

557
00:45:25,809 --> 00:45:31,819
in this case use PageSpeed?
>>Ilya Grigorik: Oh, I see. No. So coming

558
00:45:31,819 --> 00:45:37,430
back to COR filters, the safe filters, we
try to be careful about what kind of optimizations,

559
00:45:37,430 --> 00:45:40,750
rewriting, we do to your markup, JavaScript
and CSS.

560
00:45:40,750 --> 00:45:44,880
I would actually say once you have PageSpeed
in place, you can undo a lot of the stuff

561
00:45:44,880 --> 00:45:50,430
that you're doing. So it probably makes sense
just from simplifying your workflow, not having

562
00:45:50,430 --> 00:45:55,569
to work about a bunch of things.
If you stick with the COR filters, you should

563
00:45:55,569 --> 00:46:00,940
be pretty safe. But please test first.
One thing I didn't mention and I should have,

564
00:46:00,940 --> 00:46:07,940
a really great tip, if you go to webpagetest.org/compare,
you can type in your site and it will run

565
00:46:10,130 --> 00:46:15,400
it through PageSpeed service and it will give
you a side-by-side comparison.

566
00:46:15,400 --> 00:46:22,119
If you enabled this thing, what would you
get? So in the  &mdash; in our documentation, we

567
00:46:22,119 --> 00:46:27,920
provide a lot of toggles to selectively enable
specific filters. Like, you can pass us a

568
00:46:27,920 --> 00:46:31,579
query parameter string to say, I'm curious
what is going to happen if I enable image

569
00:46:31,579 --> 00:46:36,910
lazy loading. And you can do that on a per-request
basis such that as a developer, you can test

570
00:46:36,910 --> 00:46:41,220
one of these optimizations and then decide
whether you want to make that part of your

571
00:46:41,220 --> 00:46:47,569
COR configuration.
All right. Thanks, guys. If you have more

572
00:46:47,569 --> 00:46:51,930
questions, as I mentioned, please come by
our Chrome area and ask us.

573
00:46:51,930 --> 00:46:52,520
[ Applause ]

