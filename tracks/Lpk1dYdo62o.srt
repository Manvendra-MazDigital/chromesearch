1
00:00:00,000 --> 00:00:00,497

2
00:00:00,497 --> 00:01:08,765
[MUSIC PLAYING]

3
00:01:08,765 --> 00:01:19,244

4
00:01:19,244 --> 00:01:22,140
SHAWN: Hi, my name is Shawn.

5
00:01:22,140 --> 00:01:25,720
Today I'd like to talk about
how WebCore, Blink, and

6
00:01:25,720 --> 00:01:29,490
WebKit, how we do compositing
in WebKit.

7
00:01:29,490 --> 00:01:33,270
So the way Chromium works,
we actually have several

8
00:01:33,270 --> 00:01:35,030
different pieces that
fit together.

9
00:01:35,030 --> 00:01:40,530
Blink is basically our
rendering engine.

10
00:01:40,530 --> 00:01:42,680
We forked from WebKit
recently.

11
00:01:42,680 --> 00:01:47,070
And what happens is, Blink as
a rendering engine uses a

12
00:01:47,070 --> 00:01:47,940
compositor.

13
00:01:47,940 --> 00:01:50,470
The compositor is implemented
in Chromium.

14
00:01:50,470 --> 00:01:53,580
What I'd like to talk about
today is how Blink actually

15
00:01:53,580 --> 00:01:55,550
chooses what gets composited.

16
00:01:55,550 --> 00:01:57,450
What does compositing
really mean?

17
00:01:57,450 --> 00:01:59,400
And these sorts of
basic concepts.

18
00:01:59,400 --> 00:02:03,570
And I will also get into bits
of implementation detail and

19
00:02:03,570 --> 00:02:06,520
code pads for those who are
interested at the end.

20
00:02:06,520 --> 00:02:07,890
So yeah, let's get started.

21
00:02:07,890 --> 00:02:12,260
And maybe you can go
to the slides now.

22
00:02:12,260 --> 00:02:19,710
OK so what you're seeing here is
imagine maybe this is some

23
00:02:19,710 --> 00:02:21,030
sort of HTML page.

24
00:02:21,030 --> 00:02:25,400
These boxes could be considered
as divs, and the

25
00:02:25,400 --> 00:02:28,590
question here is as we see this
animation happening on

26
00:02:28,590 --> 00:02:32,890
the yellow div, what actually
needs to be

27
00:02:32,890 --> 00:02:35,930
rerendered or repainted?

28
00:02:35,930 --> 00:02:39,760
If we assume the traditional
rendering model where we have

29
00:02:39,760 --> 00:02:43,260
software just going pixel by
pixel and figuring out what

30
00:02:43,260 --> 00:02:46,470
the color of each pixel is, and
we only have one set of

31
00:02:46,470 --> 00:02:49,990
pixels to represent the final
output image, the answer would

32
00:02:49,990 --> 00:02:52,730
be portions of all
four layers.

33
00:02:52,730 --> 00:02:57,610
Now, yeah, if we're smart enough
in WebKit or in Blink,

34
00:02:57,610 --> 00:03:02,930
we could say, yes, there's
actually only a portion of the

35
00:03:02,930 --> 00:03:07,890
actual full size image that
needs to be rerendered.

36
00:03:07,890 --> 00:03:09,790
So I'll look again.

37
00:03:09,790 --> 00:03:12,190
Yeah, only this portion needs
to be rerendered.

38
00:03:12,190 --> 00:03:17,590
But still all four layers really
do need to be repainted

39
00:03:17,590 --> 00:03:19,810
in order to get that
scene correct.

40
00:03:19,810 --> 00:03:21,940
So what that means is, and by
the way, the fourth layer here

41
00:03:21,940 --> 00:03:24,920
is the gray background.

42
00:03:24,920 --> 00:03:28,230
So what that really means is as
this yellow div, say as it

43
00:03:28,230 --> 00:03:32,920
spins around, for example, it
will actually expose parts of

44
00:03:32,920 --> 00:03:34,770
the gray element
underneath it.

45
00:03:34,770 --> 00:03:38,050
And that gray really does need
to be repainted just as much

46
00:03:38,050 --> 00:03:41,720
as the yellow layer actually
needs to be repainted as well.

47
00:03:41,720 --> 00:03:44,410
The same would be true for the
blue layer underneath the

48
00:03:44,410 --> 00:03:48,280
yellow one and even, possibly,
unless we're very clever,

49
00:03:48,280 --> 00:03:52,640
which we're actually not in
Blink we would also actually

50
00:03:52,640 --> 00:03:55,590
have to repaint portions of this
red layer on top of the

51
00:03:55,590 --> 00:03:58,230
yellow layer.

52
00:03:58,230 --> 00:04:01,210
One thing to point out is that
computing these pixels, the

53
00:04:01,210 --> 00:04:03,540
value, the color
of these pixels

54
00:04:03,540 --> 00:04:07,080
actually gets pretty expensive.

55
00:04:07,080 --> 00:04:08,750
It's surprisingly complicated.

56
00:04:08,750 --> 00:04:11,360
Not only do we have things like
background colors, we

57
00:04:11,360 --> 00:04:12,390
also have borders.

58
00:04:12,390 --> 00:04:13,670
The borders could be curved.

59
00:04:13,670 --> 00:04:16,279
We need anti-aliasing
for the borders.

60
00:04:16,279 --> 00:04:18,750
Then we need to support things
like blending for

61
00:04:18,750 --> 00:04:19,820
transparency.

62
00:04:19,820 --> 00:04:23,110
Text rendering, anti-alias text
rendering, is a whole

63
00:04:23,110 --> 00:04:24,340
other beast.

64
00:04:24,340 --> 00:04:27,650
All of these things add up and
it becomes quite expensive to

65
00:04:27,650 --> 00:04:30,840
figure out what the color of
each pixel is to actually

66
00:04:30,840 --> 00:04:33,300
render a page.

67
00:04:33,300 --> 00:04:37,900
Another example here is imagine
if we have a web page

68
00:04:37,900 --> 00:04:39,180
that we want to scroll.

69
00:04:39,180 --> 00:04:42,890
I wasn't able to get this to
animate or interact on the

70
00:04:42,890 --> 00:04:47,200
presentation, but if you just
imagine this blue layer here

71
00:04:47,200 --> 00:04:49,410
scrolling up and down.

72
00:04:49,410 --> 00:04:52,600
What that really means is that
we actually have to repaint,

73
00:04:52,600 --> 00:04:55,800
rerender every pixel,
almost every pixel

74
00:04:55,800 --> 00:04:58,660
on this entire view.

75
00:04:58,660 --> 00:05:01,185
And, again, that's
very expensive.

76
00:05:01,185 --> 00:05:03,910

77
00:05:03,910 --> 00:05:07,260
Now, you might be asking, well
couldn't we just recognize

78
00:05:07,260 --> 00:05:11,780
that this layer is shifting and
instead of rerendering and

79
00:05:11,780 --> 00:05:16,150
recomputing every pixel
maybe we can just

80
00:05:16,150 --> 00:05:18,430
shift that pixel up.

81
00:05:18,430 --> 00:05:20,690
And that is a very
good observation.

82
00:05:20,690 --> 00:05:25,510
In fact, that's exactly what we
would use compositing for.

83
00:05:25,510 --> 00:05:29,170
And, in particular, what we
would need is not just one

84
00:05:29,170 --> 00:05:33,200
backing store, not just one
buffer of pixels, but we

85
00:05:33,200 --> 00:05:36,650
actually need multiple buffers
of pixels so that we could

86
00:05:36,650 --> 00:05:39,590
store this blue layer
in a separate layer,

87
00:05:39,590 --> 00:05:42,560
in a separate buffer.

88
00:05:42,560 --> 00:05:46,950
And then when we need to, we can
just copy it over to the

89
00:05:46,950 --> 00:05:51,220
final output image in
a shifted position.

90
00:05:51,220 --> 00:05:54,250
So that's basically what
compositing is.

91
00:05:54,250 --> 00:05:57,710
It's the use of multiple backing
stores to cache and

92
00:05:57,710 --> 00:05:59,060
group chunks of the
render tree.

93
00:05:59,060 --> 00:06:01,770

94
00:06:01,770 --> 00:06:04,480
So how does this help us?

95
00:06:04,480 --> 00:06:06,990
Well, like I just said,
it can help us to

96
00:06:06,990 --> 00:06:09,520
avoid unnecessary repaints.

97
00:06:09,520 --> 00:06:12,520
We don't have to figure out what
the color of every pixel

98
00:06:12,520 --> 00:06:15,080
is every time we need
to change something.

99
00:06:15,080 --> 00:06:19,840
Instead, we can just cache
that and redraw it.

100
00:06:19,840 --> 00:06:21,670
It's a little bit of a
terminology thing.

101
00:06:21,670 --> 00:06:24,530
Repainting, in our case, would
mean that we really have to

102
00:06:24,530 --> 00:06:27,450
rerender every pixel and figure
out what color it is.

103
00:06:27,450 --> 00:06:30,590
Redrawing would be when we
already know the color of the

104
00:06:30,590 --> 00:06:35,360
pixel and we just need to
display it to the screen.

105
00:06:35,360 --> 00:06:38,750
So, again, repainting would
be considered very costly.

106
00:06:38,750 --> 00:06:40,550
Redrawing is very cheap.

107
00:06:40,550 --> 00:06:43,390

108
00:06:43,390 --> 00:06:45,740
So, for example, in this
animation that you had seen

109
00:06:45,740 --> 00:06:49,990
already, if we had a layer for
the yellow that was a separate

110
00:06:49,990 --> 00:06:50,960
backing store.

111
00:06:50,960 --> 00:06:53,480
If we had a separate backing
store for the red layer.

112
00:06:53,480 --> 00:06:56,170
These two layers, both, so
that we could put the red

113
00:06:56,170 --> 00:06:58,210
layer on top of yellow, and
the yellow on top of

114
00:06:58,210 --> 00:07:02,480
everything else, then we would
actually not need to repaint

115
00:07:02,480 --> 00:07:06,760
anything as that example
animates.

116
00:07:06,760 --> 00:07:10,290
So other benefits of
compositing, it also makes

117
00:07:10,290 --> 00:07:12,970
some things practical
that otherwise just

118
00:07:12,970 --> 00:07:13,630
wouldn't really work.

119
00:07:13,630 --> 00:07:18,151
Especially if we use hardware
accelerated compositing.

120
00:07:18,151 --> 00:07:21,180
In particular, things like
WebGL or hardware video

121
00:07:21,180 --> 00:07:25,730
decoding they are just
best done on the GPU.

122
00:07:25,730 --> 00:07:30,030
And having to read back from the
GPU to be able to render a

123
00:07:30,030 --> 00:07:33,380
final output image can get
pretty costly and performance

124
00:07:33,380 --> 00:07:34,270
would just go out the window.

125
00:07:34,270 --> 00:07:38,620
So being able to composite what
we render on WebGL or

126
00:07:38,620 --> 00:07:42,600
what we decode from hardware
video at the same time as

127
00:07:42,600 --> 00:07:47,140
compositing both on the GPU,
it's a great enabler to make

128
00:07:47,140 --> 00:07:49,370
things like WebGL and hardware
video decoding possible.

129
00:07:49,370 --> 00:07:53,050

130
00:07:53,050 --> 00:07:57,690
So what really needs to be
done when we talk about

131
00:07:57,690 --> 00:07:58,190
compositing?

132
00:07:58,190 --> 00:08:01,420
It's really just three
basic tasks.

133
00:08:01,420 --> 00:08:02,480
Three straightforward tasks.

134
00:08:02,480 --> 00:08:06,180
One, we need to figure out what
we would like to put in a

135
00:08:06,180 --> 00:08:07,990
separate backing store.

136
00:08:07,990 --> 00:08:11,610
And I tend to call these
composited layers as opposed

137
00:08:11,610 --> 00:08:15,430
to what WebCore rendering
layers.

138
00:08:15,430 --> 00:08:18,510
We also need to figure out what
the contents of those

139
00:08:18,510 --> 00:08:20,760
layers will be, render
the pixels.

140
00:08:20,760 --> 00:08:23,540
And that's what we're
calling painting.

141
00:08:23,540 --> 00:08:29,200
And we also need to finally draw
the composited layers in

142
00:08:29,200 --> 00:08:31,850
order to render the
final webpage.

143
00:08:31,850 --> 00:08:37,480
So step three is what the
compositor's job is.

144
00:08:37,480 --> 00:08:40,650
And we actually won't be
focusing on how the compositor

145
00:08:40,650 --> 00:08:44,480
actually works in Chromium, but
for this talk what I would

146
00:08:44,480 --> 00:08:47,590
like to talk about is just a
small little micro slice of

147
00:08:47,590 --> 00:08:50,550
things where we actually
figure out what gets

148
00:08:50,550 --> 00:08:52,920
composited and why.

149
00:08:52,920 --> 00:08:56,930
And in order to explain things
clearly I will also have to

150
00:08:56,930 --> 00:09:00,420
talk a little bit about how
things are painted.

151
00:09:00,420 --> 00:09:04,850
So in case you're interested in
the bigger picture and how

152
00:09:04,850 --> 00:09:08,570
things fit together, there's
several other talks and links.

153
00:09:08,570 --> 00:09:12,780
These slides will be available
on dev.Chromium.org under the

154
00:09:12,780 --> 00:09:14,710
Tech Talks Slides link.

155
00:09:14,710 --> 00:09:19,920
And these talks and these docs
are also available there.

156
00:09:19,920 --> 00:09:25,600
So Eric Seidel gave to talk a
while ago about WebCore's guts

157
00:09:25,600 --> 00:09:28,810
and how rendering works, even
the software world with

158
00:09:28,810 --> 00:09:33,210
respect to things like taking
the HTML that you provide and

159
00:09:33,210 --> 00:09:36,900
converting it from a DOM tree
to a rendering tree.

160
00:09:36,900 --> 00:09:38,390
That's what Eric's
talk is about.

161
00:09:38,390 --> 00:09:42,220
Brett Wilson also gave a talk
on some other details of how

162
00:09:42,220 --> 00:09:43,110
painting works.

163
00:09:43,110 --> 00:09:49,170
In particular, the API is used
to actually do painting.

164
00:09:49,170 --> 00:09:52,720
Chromium's compositor has
quite a few docs.

165
00:09:52,720 --> 00:09:57,520
This link is one that I think
is the overall one.

166
00:09:57,520 --> 00:10:00,170
Also available on
dev.chromium.org.

167
00:10:00,170 --> 00:10:05,800
And what I would do in this talk
is bridge the gap between

168
00:10:05,800 --> 00:10:10,380
once we have a tree of render
layers that we can actually

169
00:10:10,380 --> 00:10:14,790
render to the screen, how we
go from there to a tree of

170
00:10:14,790 --> 00:10:18,900
composited layers that the
compositor knows how to draw.

171
00:10:18,900 --> 00:10:21,700
And it actually is pretty
insightful for web developers

172
00:10:21,700 --> 00:10:24,100
to have this in mind.

173
00:10:24,100 --> 00:10:27,660
Maybe it's not necessarily
appropriate to develop your

174
00:10:27,660 --> 00:10:32,360
web to tailor to compositing,
but it is very appropriate to

175
00:10:32,360 --> 00:10:35,400
be aware of these issues when
you think about how you want

176
00:10:35,400 --> 00:10:36,650
to design your page.

177
00:10:36,650 --> 00:10:38,740

178
00:10:38,740 --> 00:10:42,640
So in order to describe why we
would choose things to become

179
00:10:42,640 --> 00:10:46,350
composited and how we do that,
let's really, really quickly

180
00:10:46,350 --> 00:10:51,160
cover some CSS details.

181
00:10:51,160 --> 00:10:55,220
So you might already know
about positioning.

182
00:10:55,220 --> 00:10:58,570
Elements can be either in what's
called normal flow

183
00:10:58,570 --> 00:11:02,300
where layout really does
position them automatically,

184
00:11:02,300 --> 00:11:05,260
and elements interact with each
other when they're all in

185
00:11:05,260 --> 00:11:07,280
normal flow.

186
00:11:07,280 --> 00:11:10,100
Relative position you can
specify on elements.

187
00:11:10,100 --> 00:11:13,640
It keeps your elements in a
normal flow, but it allows you

188
00:11:13,640 --> 00:11:17,370
to position the element with
respect to where it would've

189
00:11:17,370 --> 00:11:20,340
been in normal flow.

190
00:11:20,340 --> 00:11:22,490
Absolute positioned elements and
fixed position elements,

191
00:11:22,490 --> 00:11:25,630
on the other hand, actually are
taken out of normal flow.

192
00:11:25,630 --> 00:11:29,470
So when this layout is computed
for normal flow

193
00:11:29,470 --> 00:11:32,350
elements, absolute position
elements and fixed position

194
00:11:32,350 --> 00:11:34,510
elements actually do not affect

195
00:11:34,510 --> 00:11:36,240
that part of the layout.

196
00:11:36,240 --> 00:11:38,700
And this allows you to actually
position with a bit

197
00:11:38,700 --> 00:11:41,430
more control your elements.

198
00:11:41,430 --> 00:11:45,410
So absolute positioned elements
would be positioned

199
00:11:45,410 --> 00:11:47,940
with respect to a containing
block.

200
00:11:47,940 --> 00:11:50,570
Fixed positioned elements would
typically be positioned

201
00:11:50,570 --> 00:11:52,210
with respect to a viewport.

202
00:11:52,210 --> 00:11:55,710

203
00:11:55,710 --> 00:12:00,230
So from there CSS also has
this concept of a Z-index

204
00:12:00,230 --> 00:12:03,610
which allows you to control the
ordering of how elements

205
00:12:03,610 --> 00:12:06,180
are layered on top
of each other.

206
00:12:06,180 --> 00:12:11,700
And this is the beginnings of
where compositing becomes

207
00:12:11,700 --> 00:12:12,190
interesting.

208
00:12:12,190 --> 00:12:16,230
Because in order to render
things that are stacked on top

209
00:12:16,230 --> 00:12:18,410
of each other, and they may be
dynamically changing, they may

210
00:12:18,410 --> 00:12:20,690
have animations.

211
00:12:20,690 --> 00:12:23,540
The Z-index is what causes
that, typically.

212
00:12:23,540 --> 00:12:28,150
And so the compositor really
relies on Z-index

213
00:12:28,150 --> 00:12:29,400
a lot of the time.

214
00:12:29,400 --> 00:12:32,630

215
00:12:32,630 --> 00:12:37,020
Yes, so one important thing to
note is that if we have a

216
00:12:37,020 --> 00:12:41,500
positioned element that also has
a Z-index according to the

217
00:12:41,500 --> 00:12:52,870
CSS spec, that would be defined
as a stacking context.

218
00:12:52,870 --> 00:12:54,360
So what is the stacking
context?

219
00:12:54,360 --> 00:12:57,080
A stacking context, it's a very
nice concept, actually.

220
00:12:57,080 --> 00:13:00,430
And I think it actually gets
overlooked quite a lot from a

221
00:13:00,430 --> 00:13:01,700
web developer's perspective.

222
00:13:01,700 --> 00:13:08,230
A stacking context is a way to
flatten a group of layers into

223
00:13:08,230 --> 00:13:13,440
a single conceptual layer from
outside of the subtree.

224
00:13:13,440 --> 00:13:17,120
So here is an example where I
have four different stacking

225
00:13:17,120 --> 00:13:18,990
contexts in this example.

226
00:13:18,990 --> 00:13:22,460
The fourth, the smaller stacking
context over here, is

227
00:13:22,460 --> 00:13:25,770
actually a stacking
context within the

228
00:13:25,770 --> 00:13:28,420
green stacking context.

229
00:13:28,420 --> 00:13:29,580
There's no way to
indicate that.

230
00:13:29,580 --> 00:13:31,510
I'm just telling you that that's
what I had intended

231
00:13:31,510 --> 00:13:34,290
when making this figure.

232
00:13:34,290 --> 00:13:37,520
And you'll see that, OK, so a
negative Z-index renders below

233
00:13:37,520 --> 00:13:41,730
a 0 is Z-index value, which
renders below a

234
00:13:41,730 --> 00:13:43,680
Z-index value of 1.

235
00:13:43,680 --> 00:13:47,390
And you note that even though I
have large Z-indexes here in

236
00:13:47,390 --> 00:13:51,050
the blue and also in yellow
layers here, these are

237
00:13:51,050 --> 00:13:54,780
actually inside of a stacking
context which means that they

238
00:13:54,780 --> 00:13:57,810
are flattened to their stacking
context before they

239
00:13:57,810 --> 00:14:00,370
are rendered with respect
to everything

240
00:14:00,370 --> 00:14:01,620
else in the DOM tree.

241
00:14:01,620 --> 00:14:04,170

242
00:14:04,170 --> 00:14:07,910
So, for example, if we made
the Z-index 2 on this blue

243
00:14:07,910 --> 00:14:11,670
stacking context, it suddenly
is designated as the one on

244
00:14:11,670 --> 00:14:13,630
top of everything else, and
that's what you would see.

245
00:14:13,630 --> 00:14:18,000
So the previous example the
Z-index was 0 making it 2

246
00:14:18,000 --> 00:14:19,800
would actually render
everything on top.

247
00:14:19,800 --> 00:14:22,900

248
00:14:22,900 --> 00:14:27,230
So the way to interpret stacking
contexts is they're

249
00:14:27,230 --> 00:14:28,970
really flattening the
element's subtree.

250
00:14:28,970 --> 00:14:33,760
So it forms a nice isolation
between what's in the subtree

251
00:14:33,760 --> 00:14:36,980
of a stacking context and what's
outside of the subtree.

252
00:14:36,980 --> 00:14:41,050
Inside of the subtree of this
stacking context, all layers

253
00:14:41,050 --> 00:14:43,490
think that they have their own
isolated universe without

254
00:14:43,490 --> 00:14:45,530
knowing about anything else.

255
00:14:45,530 --> 00:14:49,280
Outside of the stacking context,
that stacking context

256
00:14:49,280 --> 00:14:54,350
is then just treated like a
normal conceptual layer.

257
00:14:54,350 --> 00:14:55,750
Atomic, that's the key word.

258
00:14:55,750 --> 00:14:59,000
An atomic conceptual layer.

259
00:14:59,000 --> 00:15:02,940
So at the end of the day, what
CSS Spec found that is that

260
00:15:02,940 --> 00:15:08,160
this is a very nice place to
define the order of how we're

261
00:15:08,160 --> 00:15:11,800
supposed to paint things when
you give us a web page.

262
00:15:11,800 --> 00:15:16,130
And, yes, actually CSS spec
does specify paint order.

263
00:15:16,130 --> 00:15:19,170
It's a little bit complicated,
you can see the full details

264
00:15:19,170 --> 00:15:22,590
in section 9.9 in Appendix
E of the spec.

265
00:15:22,590 --> 00:15:24,870
You can just find
it on Google.

266
00:15:24,870 --> 00:15:30,030
But the basic idea is that first
we paint backgrounds and

267
00:15:30,030 --> 00:15:32,180
borders for a given element.

268
00:15:32,180 --> 00:15:36,660
And then we paint the negative
Z-index children.

269
00:15:36,660 --> 00:15:39,260
Then, whatever contents of the
layers itself or any other

270
00:15:39,260 --> 00:15:43,350
normal flow elements that are
part of this layers subtree

271
00:15:43,350 --> 00:15:45,690
get painted.

272
00:15:45,690 --> 00:15:48,940
After that we do absolute
position and

273
00:15:48,940 --> 00:15:51,690
positive Z-index children.

274
00:15:51,690 --> 00:15:56,300
So what this means is that we're
actually creating a tree

275
00:15:56,300 --> 00:15:58,770
that is not quite corresponding
to the DOM tree.

276
00:15:58,770 --> 00:16:02,700
There's cases where you can
have an element in the DOM

277
00:16:02,700 --> 00:16:08,300
tree that may appear first in
the list of children, but if

278
00:16:08,300 --> 00:16:09,210
you put the [? Craig ?]

279
00:16:09,210 --> 00:16:11,720
Z-index on it, it may have
to paint last on top of

280
00:16:11,720 --> 00:16:14,860
everything else.

281
00:16:14,860 --> 00:16:18,190
Another thing would be that
depending on how the tree is

282
00:16:18,190 --> 00:16:21,850
structured, you may even get,
what you had as parent-child

283
00:16:21,850 --> 00:16:26,540
pairs in the DOM, might be more
appropriate as siblings

284
00:16:26,540 --> 00:16:30,050
when we talk about the order
in which they paint.

285
00:16:30,050 --> 00:16:34,290
And that's how things are
implemented in Blink.

286
00:16:34,290 --> 00:16:39,050
Where we actually take render
layers as the data structure

287
00:16:39,050 --> 00:16:46,080
and instead of using the tree of
render layers that coarsely

288
00:16:46,080 --> 00:16:51,030
approximates the DOM, instead
we actually collect layers

289
00:16:51,030 --> 00:16:53,140
into a different tree.

290
00:16:53,140 --> 00:16:57,810
And I'll call that the paint
order entry in this case.

291
00:16:57,810 --> 00:17:02,070
But otherwise, it implements
equivalently the same paint

292
00:17:02,070 --> 00:17:07,040
order as the CSS spec.

293
00:17:07,040 --> 00:17:11,390
So given that, how do we choose
to composite layers?

294
00:17:11,390 --> 00:17:15,180
Which layers do we choose
to be composited?

295
00:17:15,180 --> 00:17:17,980
Well we would choose composited
layers based on

296
00:17:17,980 --> 00:17:19,980
when it benefits us or when
we really need to.

297
00:17:19,980 --> 00:17:24,280
So cases where it benefits us
is if we have transparency.

298
00:17:24,280 --> 00:17:27,980
Maybe we have a transform that
is just easier to apply by

299
00:17:27,980 --> 00:17:31,060
feeding transform matrix
to the GPU.

300
00:17:31,060 --> 00:17:34,130
There may be some filters
like blur.

301
00:17:34,130 --> 00:17:39,030
Reflections where it's nice to
be able to just have that

302
00:17:39,030 --> 00:17:41,870
chunk of layers or that subtree
of layers cached

303
00:17:41,870 --> 00:17:44,370
before we actually reflect it.

304
00:17:44,370 --> 00:17:46,840
It's a good opportunity to make
it a composited layer so

305
00:17:46,840 --> 00:17:50,170
that all we have to do instead
of rerendering it twice is

306
00:17:50,170 --> 00:17:54,980
just redraw this same
pixels reflected.

307
00:17:54,980 --> 00:17:59,320
Scrolling is another example
where instead of having to

308
00:17:59,320 --> 00:18:02,270
repaint we can just put
everything into a layer and

309
00:18:02,270 --> 00:18:04,250
shift the layer and give the

310
00:18:04,250 --> 00:18:06,280
wonderful allusion of scrolling.

311
00:18:06,280 --> 00:18:09,710
Fixed-position elements that
need to stay fixed even though

312
00:18:09,710 --> 00:18:12,550
things underneath it may change
is another example

313
00:18:12,550 --> 00:18:17,040
where if we just composite this
fixed-position element we

314
00:18:17,040 --> 00:18:19,490
don't have to redraw it
every time things

315
00:18:19,490 --> 00:18:20,740
underneath it changed.

316
00:18:20,740 --> 00:18:22,980

317
00:18:22,980 --> 00:18:25,520
And then, of course, as I said
before things, like WebGL or

318
00:18:25,520 --> 00:18:31,080
hardware video coding are also
nice to make composited layers

319
00:18:31,080 --> 00:18:33,600
just so that we can take
advantage of not having to

320
00:18:33,600 --> 00:18:35,910
read them back into
software before we

321
00:18:35,910 --> 00:18:37,160
actually render them.

322
00:18:37,160 --> 00:18:39,970

323
00:18:39,970 --> 00:18:46,090
There's also a necessary evil of
having to deal with when we

324
00:18:46,090 --> 00:18:49,560
really need to composite.

325
00:18:49,560 --> 00:18:54,450
Now part of this is, I have to
admit, how WebCore and Blink

326
00:18:54,450 --> 00:18:55,710
are actually implemented.

327
00:18:55,710 --> 00:18:59,110
How the compositing is
actually implemented?

328
00:18:59,110 --> 00:19:01,700
But for the foreseeable future
this is going to be the way

329
00:19:01,700 --> 00:19:02,390
things are.

330
00:19:02,390 --> 00:19:05,300
And these are realities
we have to live with.

331
00:19:05,300 --> 00:19:08,660
If there's a layer that overlaps
another composited

332
00:19:08,660 --> 00:19:12,260
layer, and I'll show an example
of this in a second,

333
00:19:12,260 --> 00:19:17,190
then we actually have to make
that composited as well.

334
00:19:17,190 --> 00:19:20,750
Another issue is that if there's
some sort of CSS

335
00:19:20,750 --> 00:19:24,340
property that needs to be
propagated down to composited

336
00:19:24,340 --> 00:19:28,470
layers, for example, opacity,
or maybe some transform is

337
00:19:28,470 --> 00:19:30,970
inherited by an ancestor.

338
00:19:30,970 --> 00:19:34,260
Those are cases where the
parent that has that

339
00:19:34,260 --> 00:19:37,560
information needs to be
composited just for the sake

340
00:19:37,560 --> 00:19:41,270
of having that information in
the composited tree as well as

341
00:19:41,270 --> 00:19:42,350
in the render tree.

342
00:19:42,350 --> 00:19:44,760
So that all the composited
layers actually get the

343
00:19:44,760 --> 00:19:47,610
information that they need.

344
00:19:47,610 --> 00:19:50,380
So here's an example
of overlap.

345
00:19:50,380 --> 00:19:56,580
Imagine we have one backing
store in our webpage.

346
00:19:56,580 --> 00:19:57,940
If that's all we had.

347
00:19:57,940 --> 00:20:00,270
And this backing store I'm just
representing that by a

348
00:20:00,270 --> 00:20:02,450
red rectangle here.

349
00:20:02,450 --> 00:20:05,340
If that's all we had, then we
would repaint all of these

350
00:20:05,340 --> 00:20:07,440
pixels in one backing
store and be

351
00:20:07,440 --> 00:20:09,120
done with it, no problem.

352
00:20:09,120 --> 00:20:13,640
But suppose we thought we would
benefit for some reason

353
00:20:13,640 --> 00:20:17,800
from making this blue layer a
separately composited layer.

354
00:20:17,800 --> 00:20:20,760
So what we would have is backing
store one would draw

355
00:20:20,760 --> 00:20:22,490
underneath backing store two.

356
00:20:22,490 --> 00:20:25,000
Or, actually, it might be more
appropriate to say backing

357
00:20:25,000 --> 00:20:29,350
store two, depending on how we
talk about things, would

358
00:20:29,350 --> 00:20:33,180
actually redraw itself into
backing store one.

359
00:20:33,180 --> 00:20:36,100

360
00:20:36,100 --> 00:20:39,360
If we do that the green element
that we had intended

361
00:20:39,360 --> 00:20:43,440
to be on top would not be on
top because we're painting

362
00:20:43,440 --> 00:20:45,690
this into backing store one.

363
00:20:45,690 --> 00:20:50,740
This is the case where overlap
requires us to create another

364
00:20:50,740 --> 00:20:55,380
composited layer so that the
green element can actually

365
00:20:55,380 --> 00:20:58,680
draw on top of what we thought
we would like composite, which

366
00:20:58,680 --> 00:21:01,010
was the blue layer.

367
00:21:01,010 --> 00:21:03,800
So it's interesting that
this comes up.

368
00:21:03,800 --> 00:21:09,210
In the real world this can
cause an explosion of the

369
00:21:09,210 --> 00:21:14,650
number of composited layers,
which can drain GP resources

370
00:21:14,650 --> 00:21:15,630
quite badly.

371
00:21:15,630 --> 00:21:18,130
So this is something
to be aware of.

372
00:21:18,130 --> 00:21:20,960
In general, personally, I
haven't found any explosion of

373
00:21:20,960 --> 00:21:23,930
layer counts too badly
in the real world.

374
00:21:23,930 --> 00:21:26,080
But it's something
to be aware of.

375
00:21:26,080 --> 00:21:29,370
If you're making a very
complicated web app that

376
00:21:29,370 --> 00:21:33,660
things that overlap something
that might get composited will

377
00:21:33,660 --> 00:21:35,090
probably also have to
get composited.

378
00:21:35,090 --> 00:21:38,200

379
00:21:38,200 --> 00:21:43,630
So there are some other cases
where overlap becomes

380
00:21:43,630 --> 00:21:44,430
interesting.

381
00:21:44,430 --> 00:21:48,170
Animations, in particular, is an
interesting one where it's

382
00:21:48,170 --> 00:21:54,160
actually not really practical
to predict what will overlap

383
00:21:54,160 --> 00:21:56,960
an animated layer at
any given time.

384
00:21:56,960 --> 00:22:01,140
So instead we just assume that
everything on top is going to

385
00:22:01,140 --> 00:22:02,760
overlap, even if it doesn't.

386
00:22:02,760 --> 00:22:04,330
And I'll actually show
an example of

387
00:22:04,330 --> 00:22:07,060
that in just a second.

388
00:22:07,060 --> 00:22:09,520
So that's another interesting
thing to be aware of is that

389
00:22:09,520 --> 00:22:12,490
when you have animations you
might actually see lots of

390
00:22:12,490 --> 00:22:15,560
layers suddenly pop up,
composited layers, pop up on

391
00:22:15,560 --> 00:22:18,500
your page simply because
the animation

392
00:22:18,500 --> 00:22:19,320
is underneath things.

393
00:22:19,320 --> 00:22:23,780
And by bringing animation on top
you might be able to avoid

394
00:22:23,780 --> 00:22:26,010
unnecessarily causing
things to be

395
00:22:26,010 --> 00:22:27,260
composited in your webpage.

396
00:22:27,260 --> 00:22:32,450

397
00:22:32,450 --> 00:22:36,470
This third point is also very
interesting to note.

398
00:22:36,470 --> 00:22:37,910
This is where stacking contexts

399
00:22:37,910 --> 00:22:39,060
actually become very useful.

400
00:22:39,060 --> 00:22:43,010
Because if you have children
that are inside of a second

401
00:22:43,010 --> 00:22:47,170
context, you know that they
are treated as atomic with

402
00:22:47,170 --> 00:22:51,590
respect to everything else
outside of that subtree.

403
00:22:51,590 --> 00:22:54,100
And what that allows you to
do then, is if you made a

404
00:22:54,100 --> 00:22:58,040
stacking context out of the
subtree of your DOM, you can

405
00:22:58,040 --> 00:23:00,630
feel a little bit more
comfortable that you won't

406
00:23:00,630 --> 00:23:04,020
have an explosion of composited
layers inside of

407
00:23:04,020 --> 00:23:04,980
that subtree.

408
00:23:04,980 --> 00:23:07,420
Instead, the compositor will
recognize, OK, this is

409
00:23:07,420 --> 00:23:08,620
stacking context.

410
00:23:08,620 --> 00:23:11,340
I can make one composited
layer for this

411
00:23:11,340 --> 00:23:13,430
entire stacking context.

412
00:23:13,430 --> 00:23:16,850
And I don't need to check if
everything else overlaps

413
00:23:16,850 --> 00:23:19,015
inside of the subtree if it
overlaps other content.

414
00:23:19,015 --> 00:23:23,020

415
00:23:23,020 --> 00:23:27,510
So basically what we do then
in Blink is we iterate over

416
00:23:27,510 --> 00:23:29,980
this paint order tree,
recursively.

417
00:23:29,980 --> 00:23:32,400
And we ask, does this layer
need compositing?

418
00:23:32,400 --> 00:23:34,770
Would we benefit from it?

419
00:23:34,770 --> 00:23:39,520
And then we also ask, now that
we've chosen composited layers

420
00:23:39,520 --> 00:23:42,460
for the subtree, once we
bubble back up from the

421
00:23:42,460 --> 00:23:44,960
recursion we have to ask, well,
is there some reason

422
00:23:44,960 --> 00:23:50,210
that maybe we ought to composite
this parent as well?

423
00:23:50,210 --> 00:23:51,470
For example, overlap.

424
00:23:51,470 --> 00:23:54,240
Or if something in the subtree
became composited that needs

425
00:23:54,240 --> 00:23:58,510
some properties like transform
or opacity.

426
00:23:58,510 --> 00:24:01,270
And at the end, once we've
decided if something change

427
00:24:01,270 --> 00:24:05,620
its state whether a subtree
needs to be composited or not

428
00:24:05,620 --> 00:24:07,250
composited we also have
to issue that

429
00:24:07,250 --> 00:24:10,030
it needs to be repainted.

430
00:24:10,030 --> 00:24:11,570
OK, let's go to some demos.

431
00:24:11,570 --> 00:24:14,700
See some examples of this
stuff in action.

432
00:24:14,700 --> 00:24:18,500
If you'd like to try this on
your own, there's probably

433
00:24:18,500 --> 00:24:20,420
four essential--

434
00:24:20,420 --> 00:24:25,470
or maybe these first three are
the most essential command

435
00:24:25,470 --> 00:24:28,480
line flags that you'd
like to use.

436
00:24:28,480 --> 00:24:30,290
First, force-compositing mode.

437
00:24:30,290 --> 00:24:31,170
Just in case.

438
00:24:31,170 --> 00:24:34,590
For example, if you're on
Linux or if you're in a

439
00:24:34,590 --> 00:24:38,130
situation where it seems like
you might be running software

440
00:24:38,130 --> 00:24:40,560
mode instead, force-compositing
mode will

441
00:24:40,560 --> 00:24:44,390
ensure that you're actually
using accelerated compositing

442
00:24:44,390 --> 00:24:47,740
on all your pages, even if they
didn't really require it.

443
00:24:47,740 --> 00:24:52,050
So just in case you actually
don't see what you expect, try

444
00:24:52,050 --> 00:24:53,510
force-compositing mode.

445
00:24:53,510 --> 00:24:56,090
Show composited layer
borders is probably

446
00:24:56,090 --> 00:24:57,350
the most useful one.

447
00:24:57,350 --> 00:25:01,830
This allows you to visualize
orange and some other color

448
00:25:01,830 --> 00:25:04,890
borders around layers that
become composited.

449
00:25:04,890 --> 00:25:07,020
And it's very insightful.

450
00:25:07,020 --> 00:25:09,130
Show paint rects is also
very valuable.

451
00:25:09,130 --> 00:25:13,830
What this shows is regions of
the page and regions of

452
00:25:13,830 --> 00:25:17,330
various layers that actually
needed to be repainted.

453
00:25:17,330 --> 00:25:21,960
That implies that we had to do
very expensive paint process

454
00:25:21,960 --> 00:25:25,330
to figure out the pixels
of that region.

455
00:25:25,330 --> 00:25:27,840
And generally what you would
like to do to get really

456
00:25:27,840 --> 00:25:30,820
performant web apps is minimize
the amount of paint

457
00:25:30,820 --> 00:25:34,440
rects that you see if you
were to visualize this.

458
00:25:34,440 --> 00:25:37,370
Another one that we have, it's
not really as useful, but it

459
00:25:37,370 --> 00:25:40,980
is still there, is show
property change recs.

460
00:25:40,980 --> 00:25:44,470
What you'll see here is these
will be layers that, for

461
00:25:44,470 --> 00:25:47,720
example, have an animation
where, yes, they did not need

462
00:25:47,720 --> 00:25:50,740
repainting, but they had some
property that changed on them

463
00:25:50,740 --> 00:25:52,870
that does require them
to be redrawn.

464
00:25:52,870 --> 00:25:57,180
If you see these sorts of recs
then chances are you're in a

465
00:25:57,180 --> 00:25:59,710
good state because you didn't
need to repaint.

466
00:25:59,710 --> 00:26:02,360
But rather, you can just
quickly redraw them.

467
00:26:02,360 --> 00:26:05,970
So, for example, in animation
you might actually see that.

468
00:26:05,970 --> 00:26:10,660
So yeah let's run some demos
and see how this looks.

469
00:26:10,660 --> 00:26:14,100
So I have a script of my
own called runtest.

470
00:26:14,100 --> 00:26:17,220
This is basically just my way
of running Chrome from the

471
00:26:17,220 --> 00:26:18,830
command line.

472
00:26:18,830 --> 00:26:23,840
I have a command line [? rx ?]
show composite layer borders.

473
00:26:23,840 --> 00:26:27,490
Let's see, we can go to Poster
Circle is it as one of the

474
00:26:27,490 --> 00:26:32,070
standard examples for
looking at 3D CSS.

475
00:26:32,070 --> 00:26:35,330
And what you see here
is orange borders.

476
00:26:35,330 --> 00:26:38,640
This is the composited layer
borders flag showing you that

477
00:26:38,640 --> 00:26:42,610
all of these layers here that
are being animated in 3D,

478
00:26:42,610 --> 00:26:46,810
they're getting composited so
that the GPU can do 3D stuff

479
00:26:46,810 --> 00:26:49,450
much faster and much
more easily.

480
00:26:49,450 --> 00:26:51,790
It also happens, it looks like
we have a scroll bar here on

481
00:26:51,790 --> 00:26:55,990
the right even though,
OK, there it is.

482
00:26:55,990 --> 00:26:57,880
Yeah, so we have a scroll
bar here on the right.

483
00:26:57,880 --> 00:26:59,610
This gets separately
composited as

484
00:26:59,610 --> 00:27:03,410
well for various reasons.

485
00:27:03,410 --> 00:27:07,970
For example, when we scroll it's
easier to have the scroll

486
00:27:07,970 --> 00:27:09,370
bar as a separate layer.

487
00:27:09,370 --> 00:27:12,590
So that we don't have to change
any contents of this

488
00:27:12,590 --> 00:27:17,830
huge root layer, so to speak,
underneath it, as we shift

489
00:27:17,830 --> 00:27:19,490
that layer up and down.

490
00:27:19,490 --> 00:27:21,290
So another interesting
thing we can do

491
00:27:21,290 --> 00:27:22,540
is, let's go to Inspector.

492
00:27:22,540 --> 00:27:27,970

493
00:27:27,970 --> 00:27:34,381
And what I'd like to do is,
you can see that basically

494
00:27:34,381 --> 00:27:36,780
this text here, they're
really just

495
00:27:36,780 --> 00:27:38,520
simple paragraph elements.

496
00:27:38,520 --> 00:27:41,220
There's nothing special
about them.

497
00:27:41,220 --> 00:27:44,300
And there's this animation going
on that is completely

498
00:27:44,300 --> 00:27:47,060
unrelated to these paragraphs.

499
00:27:47,060 --> 00:27:51,990
However, if I create some layer
here with a Z-index

500
00:27:51,990 --> 00:27:53,240
that's positive.

501
00:27:53,240 --> 00:28:03,510

502
00:28:03,510 --> 00:28:07,190
And I also need to actually
make it a stacking context

503
00:28:07,190 --> 00:28:10,520
just so that the render tree
recognizes it as a separate

504
00:28:10,520 --> 00:28:11,880
render layer.

505
00:28:11,880 --> 00:28:13,360
So I'll just make a
position relative.

506
00:28:13,360 --> 00:28:15,680
So I'm not actually changing
its position.

507
00:28:15,680 --> 00:28:19,950
But what you see now is suddenly
this paragraph

508
00:28:19,950 --> 00:28:21,610
becomes composited.

509
00:28:21,610 --> 00:28:22,670
Why is that?

510
00:28:22,670 --> 00:28:26,420
Well the answer is that because
of this animation we

511
00:28:26,420 --> 00:28:31,820
weren't able to assume where
this text is with respect to

512
00:28:31,820 --> 00:28:32,950
the animation.

513
00:28:32,950 --> 00:28:35,040
And so we have to
assume that it

514
00:28:35,040 --> 00:28:37,060
might overlap the animation.

515
00:28:37,060 --> 00:28:40,070
And therefore we create a
composited layer out of it.

516
00:28:40,070 --> 00:28:43,600
Now, in this case, we would
judge that this layer is

517
00:28:43,600 --> 00:28:45,230
really unnecessary.

518
00:28:45,230 --> 00:28:50,070
And the way we could avoid that
is change the Z-index so

519
00:28:50,070 --> 00:28:53,560
that it's actually underneath
this animation.

520
00:28:53,560 --> 00:28:58,750
So here what I have a Z-index
of one on that paragraph, it

521
00:28:58,750 --> 00:29:02,150
actually is stacked on
top of the animation.

522
00:29:02,150 --> 00:29:04,260
And we have to assume
that it overlaps.

523
00:29:04,260 --> 00:29:07,030
So we make it a composited
layer.

524
00:29:07,030 --> 00:29:11,170
If I made a Z-index that was
underneath the animation, then

525
00:29:11,170 --> 00:29:13,900
there would be no reason to
composite it because it does

526
00:29:13,900 --> 00:29:14,450
not overlap.

527
00:29:14,450 --> 00:29:17,230
In fact, it's underneath
the animation.

528
00:29:17,230 --> 00:29:19,560
So that's example number one.

529
00:29:19,560 --> 00:29:21,820
Let's see.

530
00:29:21,820 --> 00:29:23,300
A few other examples.

531
00:29:23,300 --> 00:29:35,340

532
00:29:35,340 --> 00:29:36,630
MapsGL is a fun example.

533
00:29:36,630 --> 00:29:39,650

534
00:29:39,650 --> 00:29:45,670
Not only does it show off WebGL,
but it also shows off

535
00:29:45,670 --> 00:29:47,770
how a compositor is smart
enough to render

536
00:29:47,770 --> 00:29:49,440
stuff on top of WebGL.

537
00:29:49,440 --> 00:29:54,820
So what I have here is using
the vector form of MapGL.

538
00:29:54,820 --> 00:30:01,390
So this map is actually a WebGL
canvas on the page.

539
00:30:01,390 --> 00:30:04,630
And these elements on top
are overlapping a

540
00:30:04,630 --> 00:30:07,130
composited WebGL element.

541
00:30:07,130 --> 00:30:09,040
And so they also have
to get composited.

542
00:30:09,040 --> 00:30:12,522

543
00:30:12,522 --> 00:30:13,700
Let's see.

544
00:30:13,700 --> 00:30:14,980
Any other interesting?

545
00:30:14,980 --> 00:30:17,840
Android apps is also
a fun example.

546
00:30:17,840 --> 00:30:21,920
Here you can see animations in
action that actually cause

547
00:30:21,920 --> 00:30:25,130
other layers to get created.

548
00:30:25,130 --> 00:30:30,110
So what you see here is as I
interact, as I mouse over the

549
00:30:30,110 --> 00:30:34,140
shadow, the halo around
this [? holes ?]

550
00:30:34,140 --> 00:30:37,720
changes some of these highlight
elements like the

551
00:30:37,720 --> 00:30:40,880
brackets that are focusing
on different

552
00:30:40,880 --> 00:30:42,660
elements as I mouse over.

553
00:30:42,660 --> 00:30:43,650
They animate.

554
00:30:43,650 --> 00:30:46,750
And what you see is that
depending on what needs to

555
00:30:46,750 --> 00:30:51,080
animate, it might actually have
a lot of things on top.

556
00:30:51,080 --> 00:30:54,280
And those a lot of things on top
then also need to become

557
00:30:54,280 --> 00:30:55,250
composited.

558
00:30:55,250 --> 00:30:59,900
Because we can't assume that the
animation is not actually

559
00:30:59,900 --> 00:31:00,450
overlapping.

560
00:31:00,450 --> 00:31:02,760
We have to assume that
it might overlap.

561
00:31:02,760 --> 00:31:06,850
And so this is a pitfall that,
in this case, it's actually

562
00:31:06,850 --> 00:31:07,690
very reasonable.

563
00:31:07,690 --> 00:31:09,570
The number of layers
is not too bad.

564
00:31:09,570 --> 00:31:12,270
The animations are
very controlled.

565
00:31:12,270 --> 00:31:16,550
The layer explosion disappears
after the animations are done,

566
00:31:16,550 --> 00:31:20,690
which is generally
a good thing.

567
00:31:20,690 --> 00:31:23,710
But it's still interesting to
note that it can accidentally

568
00:31:23,710 --> 00:31:26,470
get out of hand if you're
not careful in

569
00:31:26,470 --> 00:31:28,570
making your web page.

570
00:31:28,570 --> 00:31:30,810
It's also interesting to note
that we have some 3D layers

571
00:31:30,810 --> 00:31:32,060
here that get composited.

572
00:31:32,060 --> 00:31:34,980

573
00:31:34,980 --> 00:31:37,240
There's a flip card
animation here.

574
00:31:37,240 --> 00:31:42,420
If you see the purple
composited

575
00:31:42,420 --> 00:31:45,180
layer flipping around.

576
00:31:45,180 --> 00:31:48,280
The reason that it's purple is
because in our compositor we

577
00:31:48,280 --> 00:31:51,890
actually have to create a
secondary intermediate thing

578
00:31:51,890 --> 00:31:55,390
where we render a bunch of
composited layers into another

579
00:31:55,390 --> 00:31:56,700
intermediate surface.

580
00:31:56,700 --> 00:31:58,320
That's what this purple is.

581
00:31:58,320 --> 00:32:01,100
The reason we have to do that
is because we have something

582
00:32:01,100 --> 00:32:04,340
like this 3D composited
layer inside of it.

583
00:32:04,340 --> 00:32:06,430
But we're going to want
to do something 3D to

584
00:32:06,430 --> 00:32:08,070
this outside layer.

585
00:32:08,070 --> 00:32:11,390
Like a flip card animation.

586
00:32:11,390 --> 00:32:14,000
And so what that requires is
that we actually have to

587
00:32:14,000 --> 00:32:16,870
render a bunch of composited
layers down to an

588
00:32:16,870 --> 00:32:17,730
intermediate surface.

589
00:32:17,730 --> 00:32:21,170
And that's what this blue
layer actually is.

590
00:32:21,170 --> 00:32:24,580
In our Chromium compositor
terminology we call that a

591
00:32:24,580 --> 00:32:25,490
render surface.

592
00:32:25,490 --> 00:32:28,470
If you encounter that.

593
00:32:28,470 --> 00:32:33,280
Let me go back to the command
line here really quickly and

594
00:32:33,280 --> 00:32:36,220
show you what it looks like
to see paper rects.

595
00:32:36,220 --> 00:32:42,400

596
00:32:42,400 --> 00:32:45,340
So here is poster
circle again.

597
00:32:45,340 --> 00:32:48,680
Now notice that you're not
seeing any visualizations on

598
00:32:48,680 --> 00:32:51,240
top of the page itself yet.

599
00:32:51,240 --> 00:32:53,020
And the reason is is
because nothing is

600
00:32:53,020 --> 00:32:54,210
actually being repainted.

601
00:32:54,210 --> 00:32:56,030
And that's a very
wonderful thing.

602
00:32:56,030 --> 00:32:58,760
That's a great place to
be on your web page as

603
00:32:58,760 --> 00:33:00,440
often as you can.

604
00:33:00,440 --> 00:33:02,840
If I actually select some text,
though, you can actually

605
00:33:02,840 --> 00:33:07,230
see that there's this red
visualization that comes up on

606
00:33:07,230 --> 00:33:12,570
top showing that, oh, actually
this is a region of the page

607
00:33:12,570 --> 00:33:15,850
that needed to be repainted
at that particular frame.

608
00:33:15,850 --> 00:33:17,670
And the reason it's flickering
on and off is because the

609
00:33:17,670 --> 00:33:21,270
animation is actually going on
as well, at the same time.

610
00:33:21,270 --> 00:33:25,990
And so the next frame is so soon
after that the paint rect

611
00:33:25,990 --> 00:33:27,830
for the previous frame
disappears.

612
00:33:27,830 --> 00:33:28,720
That's why it's flickering.

613
00:33:28,720 --> 00:33:32,050
If you had a more static page
and you selected some text,

614
00:33:32,050 --> 00:33:34,560
you would see that visualization
stick because no

615
00:33:34,560 --> 00:33:39,340
other frame has been rendered
after that yet.

616
00:33:39,340 --> 00:33:40,620
So that's interesting.

617
00:33:40,620 --> 00:33:44,800
Maybe one last thing to show
is property change rects.

618
00:33:44,800 --> 00:33:49,830
Again, show paint rects is
probably the most important,

619
00:33:49,830 --> 00:33:51,890
especially to get web apps.

620
00:33:51,890 --> 00:33:57,100
You want to avoid paint rects
showing up if you use that

621
00:33:57,100 --> 00:33:58,130
visualization.

622
00:33:58,130 --> 00:33:59,710
But in the case of property
change rects.

623
00:33:59,710 --> 00:34:07,510

624
00:34:07,510 --> 00:34:09,760
In the case of property
change rects, it's

625
00:34:09,760 --> 00:34:11,179
actually a good thing.

626
00:34:11,179 --> 00:34:14,340
And so what you're seeing here
is that well the animations

627
00:34:14,340 --> 00:34:18,929
here are actually animating the
CSS transform property.

628
00:34:18,929 --> 00:34:21,190
And so that property is
changing every frame.

629
00:34:21,190 --> 00:34:24,949
And these rects are just a rough
visualization to show

630
00:34:24,949 --> 00:34:27,639
that here the layers that
actually did need to be

631
00:34:27,639 --> 00:34:30,840
redrawn even though nothing
needed to be repainted.

632
00:34:30,840 --> 00:34:32,550
That's what this visualization
shows.

633
00:34:32,550 --> 00:34:36,500

634
00:34:36,500 --> 00:34:37,750
OK back to the slides.

635
00:34:37,750 --> 00:34:44,840

636
00:34:44,840 --> 00:34:49,230
So I just want to briefly go
over some of how WebCore and

637
00:34:49,230 --> 00:34:53,550
Blink actually implement the
choice of how composited

638
00:34:53,550 --> 00:34:55,080
layers work.

639
00:34:55,080 --> 00:34:57,620
It turns out there's actually
lots of levels of abstraction

640
00:34:57,620 --> 00:35:00,450
here just to get different
pieces of

641
00:35:00,450 --> 00:35:02,220
software clumped together.

642
00:35:02,220 --> 00:35:06,960
So at the bottom of this stack
here we sort of have the

643
00:35:06,960 --> 00:35:10,960
output of the Blink side
of compositing.

644
00:35:10,960 --> 00:35:15,020
The output is a tree of
composited layers.

645
00:35:15,020 --> 00:35:20,150
CC is the name space for
Chromium's compositor.

646
00:35:20,150 --> 00:35:25,040
So ultimately the output of
Blink deciding what's

647
00:35:25,040 --> 00:35:29,540
composite is a tree of these
CC layer data structures.

648
00:35:29,540 --> 00:35:32,170
For each CC layer, then, what
the compositor will do is it

649
00:35:32,170 --> 00:35:35,800
will actually hook back into
Blink asking Blink, when it's

650
00:35:35,800 --> 00:35:39,440
ready it will say Blink please
repeat this composited layer.

651
00:35:39,440 --> 00:35:43,660
Blink then has the knowledge
of what render layers and

652
00:35:43,660 --> 00:35:47,060
render objects and just how to
render what's inside of that

653
00:35:47,060 --> 00:35:49,780
particular composited layer.

654
00:35:49,780 --> 00:35:53,430
So just to bridge the gap
between Chromium and Blink we

655
00:35:53,430 --> 00:35:58,930
have several levels of
interaction where they're

656
00:35:58,930 --> 00:36:04,210
really just essentially
wrappers to CC layer.

657
00:36:04,210 --> 00:36:06,940
But it's just necessary for the
fact that these are two

658
00:36:06,940 --> 00:36:09,500
separate pieces of software that
are interacting with each

659
00:36:09,500 --> 00:36:11,980
other and they need to
talk back and forth.

660
00:36:11,980 --> 00:36:14,610
So we have this interface
called web layer.

661
00:36:14,610 --> 00:36:16,590
And web layer impl is the
implementation of that.

662
00:36:16,590 --> 00:36:19,380

663
00:36:19,380 --> 00:36:24,610
From there on the Blink side,
then, we have graphics layer

664
00:36:24,610 --> 00:36:27,180
Chromium is the actual
Chromium-specific

665
00:36:27,180 --> 00:36:31,660
implementation of a
graphics layer.

666
00:36:31,660 --> 00:36:35,940
And a graphics layer, then,
this is really Blink's

667
00:36:35,940 --> 00:36:40,140
representation of a single
individual composited layer.

668
00:36:40,140 --> 00:36:42,600
Not all of these will actually
draw things.

669
00:36:42,600 --> 00:36:46,470
They may exist in the tree just
to represent a transform

670
00:36:46,470 --> 00:36:49,030
or maybe a clipping region.

671
00:36:49,030 --> 00:36:54,340
But the idea is that a tree of
graphics layer generally

672
00:36:54,340 --> 00:37:00,590
corresponds to a tree of
Chromium compositor layers.

673
00:37:00,590 --> 00:37:02,450
Basically one to one.

674
00:37:02,450 --> 00:37:05,580
Not quite, but basically.

675
00:37:05,580 --> 00:37:08,040
So the real interesting stuff is
actually at the top of the

676
00:37:08,040 --> 00:37:09,270
stack here.

677
00:37:09,270 --> 00:37:11,490
It's these top three things.

678
00:37:11,490 --> 00:37:15,130
So we have graphics layer as our
Blink representation of a

679
00:37:15,130 --> 00:37:16,920
composited layer.

680
00:37:16,920 --> 00:37:22,100
Then we have this bridge call
render layer backing.

681
00:37:22,100 --> 00:37:26,470
Render layer backing is the
bridge between render layers

682
00:37:26,470 --> 00:37:27,960
and graphics layers.

683
00:37:27,960 --> 00:37:32,190
So render layers, I'll just
assume that this is the input

684
00:37:32,190 --> 00:37:35,990
to our problem statement
in this talk here.

685
00:37:35,990 --> 00:37:40,410
But it actually came from taking
the DOM tree, computing

686
00:37:40,410 --> 00:37:43,620
render tree of render objects,
that's another class in

687
00:37:43,620 --> 00:37:46,700
WebCore name space is
render objects.

688
00:37:46,700 --> 00:37:49,560
These render objects,
some of them become

689
00:37:49,560 --> 00:37:52,160
promoted to render layers.

690
00:37:52,160 --> 00:37:56,720
And so we have a tree of render
layers that some of

691
00:37:56,720 --> 00:37:59,680
these render layers will have,
we would decide to be

692
00:37:59,680 --> 00:38:00,620
composited.

693
00:38:00,620 --> 00:38:03,200
And those composited render
layers will have

694
00:38:03,200 --> 00:38:04,850
render layer backings.

695
00:38:04,850 --> 00:38:08,440
The render layer backings then
will have a small chunk of

696
00:38:08,440 --> 00:38:12,130
graphics layers that it puts
together to create the entire

697
00:38:12,130 --> 00:38:14,370
composited layer tree.

698
00:38:14,370 --> 00:38:17,070
So I know that might be a little
confusing, yet here's a

699
00:38:17,070 --> 00:38:20,370
visualization that hopefully
clears up a bit of it.

700
00:38:20,370 --> 00:38:23,850
On the left-hand side we start
with the render layer paint

701
00:38:23,850 --> 00:38:25,170
order tree.

702
00:38:25,170 --> 00:38:30,240
So the idea would be that here
where my mouse is is actually

703
00:38:30,240 --> 00:38:35,540
maybe the root, the root render
view of the page.

704
00:38:35,540 --> 00:38:39,050
These other layers are not
necessarily composited, but

705
00:38:39,050 --> 00:38:43,970
let's say over here this next
red circle is also we chose to

706
00:38:43,970 --> 00:38:47,660
make a composited layer
in the paint order.

707
00:38:47,660 --> 00:38:52,480
What would happen then is these
composited layers would

708
00:38:52,480 --> 00:38:56,840
have a reference, or actually
they would own a

709
00:38:56,840 --> 00:38:57,730
render layer backing.

710
00:38:57,730 --> 00:39:00,910
Which is represented in these
blue circles here.

711
00:39:00,910 --> 00:39:04,640
By themselves the render layer
backings are not the final

712
00:39:04,640 --> 00:39:06,890
output that we can actually
take in the

713
00:39:06,890 --> 00:39:08,290
compositor and renderer.

714
00:39:08,290 --> 00:39:13,310
Instead, the render layer
backings each manage a small

715
00:39:13,310 --> 00:39:17,040
chunk of graphics layers.

716
00:39:17,040 --> 00:39:20,320
And I'll show you in a second
what the purpose of some of

717
00:39:20,320 --> 00:39:21,870
these graphics layers are.

718
00:39:21,870 --> 00:39:25,750
But basically what happens
then is that these render

719
00:39:25,750 --> 00:39:28,980
layer backings will stitch
together their chunks of

720
00:39:28,980 --> 00:39:31,760
graphics layers to create the
actual graphics layer tree.

721
00:39:31,760 --> 00:39:35,140
So the graphics layer tree, that
would basically be output

722
00:39:35,140 --> 00:39:40,426
to the Chromium compositor, is
this tree of gray squares that

723
00:39:40,426 --> 00:39:43,250
you see here.

724
00:39:43,250 --> 00:39:46,670
And so it's interesting to
note that from the render

725
00:39:46,670 --> 00:39:50,050
layer tree to the graphics layer
tree, it's not really a

726
00:39:50,050 --> 00:39:51,110
direct correspondence.

727
00:39:51,110 --> 00:39:55,590
You can't quite easily say that
this layer on the render

728
00:39:55,590 --> 00:39:57,630
layer tree corresponds
to this layer in the

729
00:39:57,630 --> 00:39:59,730
graphics layer tree.

730
00:39:59,730 --> 00:40:02,940
What you have to say is that
this chunk of the render layer

731
00:40:02,940 --> 00:40:07,610
tree corresponds to this chunk
of the graphics layer tree.

732
00:40:07,610 --> 00:40:13,880
That's the way to more easily
see what's going on here.

733
00:40:13,880 --> 00:40:17,020
So inside the render layer
backing, there's actually a

734
00:40:17,020 --> 00:40:19,730
fairly complicated, hopefully
we can simplify this over

735
00:40:19,730 --> 00:40:22,330
time, but for now the way it's
implemented, it's a fairly

736
00:40:22,330 --> 00:40:28,020
complicated set of layers that
are used just for convenience.

737
00:40:28,020 --> 00:40:32,940
That we can more easily handle
things like clipping or

738
00:40:32,940 --> 00:40:36,060
containment of a separate
background in a foreground if

739
00:40:36,060 --> 00:40:39,350
we found that while we're
computing what should be

740
00:40:39,350 --> 00:40:43,700
composited, there's some cases
where it's actually reasonable

741
00:40:43,700 --> 00:40:46,650
to separate the background
from the foreground.

742
00:40:46,650 --> 00:40:49,610
And so that's what it is
represented here inside a

743
00:40:49,610 --> 00:40:51,730
render layer backing.

744
00:40:51,730 --> 00:40:54,370
Clip layers and container
layers

745
00:40:54,370 --> 00:40:56,230
generally won't draw anything.

746
00:40:56,230 --> 00:40:59,390
Instead their purpose is simply
to be a little bit

747
00:40:59,390 --> 00:41:01,790
easier to represent something
in the tree.

748
00:41:01,790 --> 00:41:04,940
So the clip layer would
basically clip its entire

749
00:41:04,940 --> 00:41:08,500
subtree from the composited
layer tree's perspective.

750
00:41:08,500 --> 00:41:12,220
And then, of course, once we
reach this end game here at

751
00:41:12,220 --> 00:41:15,710
the bottom of the chunk of tree
here, we would have a

752
00:41:15,710 --> 00:41:18,620
container that actually contains
the other render

753
00:41:18,620 --> 00:41:22,030
layer children as needed.

754
00:41:22,030 --> 00:41:25,800

755
00:41:25,800 --> 00:41:29,130
So I basically just said
already, why do we need so

756
00:41:29,130 --> 00:41:29,620
many layers?

757
00:41:29,620 --> 00:41:32,410
Well scroll bars is one
I didn't mention.

758
00:41:32,410 --> 00:41:34,910
It's always nice to keep scroll
bars separate so that

759
00:41:34,910 --> 00:41:37,280
you don't have to change the
contents of a layer just

760
00:41:37,280 --> 00:41:38,810
because you scrolled it.

761
00:41:38,810 --> 00:41:41,720
All you have to do is then just
repaint the scroll bar as

762
00:41:41,720 --> 00:41:44,330
things scroll around.

763
00:41:44,330 --> 00:41:48,030
And then, yes, as I said clips,
background, foreground.

764
00:41:48,030 --> 00:41:51,690
Grouping things together, such
as when you have contents that

765
00:41:51,690 --> 00:41:53,940
would scroll you want
to group them.

766
00:41:53,940 --> 00:41:57,020
Masks, reflections, these are
actually implicit if you look

767
00:41:57,020 --> 00:41:57,890
at the code.

768
00:41:57,890 --> 00:42:01,080
These are not actually
represented as part of this

769
00:42:01,080 --> 00:42:06,590
tree, but rather each individual
layer might contain

770
00:42:06,590 --> 00:42:09,145
a reference to mask or a
reference to a reflection.

771
00:42:09,145 --> 00:42:13,910

772
00:42:13,910 --> 00:42:16,920
So in terms of code paths, I'm
going to go over this quickly.

773
00:42:16,920 --> 00:42:20,150
The slides will be
available online.

774
00:42:20,150 --> 00:42:21,860
It's really something that
you just have to

775
00:42:21,860 --> 00:42:24,350
read and look through.

776
00:42:24,350 --> 00:42:27,140
This is more of a reference than
anything that is really

777
00:42:27,140 --> 00:42:29,510
worth explaining in a talk.

778
00:42:29,510 --> 00:42:34,100
But I will at least quickly say,
what we have then is we

779
00:42:34,100 --> 00:42:40,870
have a paint code path which
Chromium asks Blink to paint.

780
00:42:40,870 --> 00:42:50,670
And basically what happens is
each graphics layer here has

781
00:42:50,670 --> 00:42:52,940
an associated paint
face with it.

782
00:42:52,940 --> 00:42:57,670
And that paint phase is the way
that a render layer knows

783
00:42:57,670 --> 00:43:00,450
how to paint itself.

784
00:43:00,450 --> 00:43:03,790
So when we actually ask Blink,
please paint this composited

785
00:43:03,790 --> 00:43:08,260
layer using your subtree of
render layers, the render

786
00:43:08,260 --> 00:43:12,440
layers will then paint based on
if they contribute to that

787
00:43:12,440 --> 00:43:13,580
particular graphics layer.

788
00:43:13,580 --> 00:43:16,780
And the way they recognize
whether they contribute is

789
00:43:16,780 --> 00:43:17,600
through this phase.

790
00:43:17,600 --> 00:43:19,470
So they kind of filter
themselves out.

791
00:43:19,470 --> 00:43:23,250
And they don't paint themselves
to composited

792
00:43:23,250 --> 00:43:28,510
layers that they don't actually
contribute to.

793
00:43:28,510 --> 00:43:32,340
So it's this phase mechanism
that couples that.

794
00:43:32,340 --> 00:43:35,820
If you're asking how a render
layer paints into a graphics

795
00:43:35,820 --> 00:43:40,105
layer the answer is it uses a
phase to recognize which layer

796
00:43:40,105 --> 00:43:42,180
it paints into.

797
00:43:42,180 --> 00:43:44,890
And then we have the code path
which actually computes what

798
00:43:44,890 --> 00:43:46,310
actually gets composited.

799
00:43:46,310 --> 00:43:49,270
This is the recursive algorithm
I mentioned earlier.

800
00:43:49,270 --> 00:43:50,620
There's basically two
parts to this.

801
00:43:50,620 --> 00:43:53,590
One is you want to determine
what gets composited.

802
00:43:53,590 --> 00:43:56,480
And the second part is you
actually need to stitch

803
00:43:56,480 --> 00:43:59,800
together these data structures
and initialize these data

804
00:43:59,800 --> 00:44:00,660
structures.

805
00:44:00,660 --> 00:44:03,360
So that second part is rebuild
compositing layer tree.

806
00:44:03,360 --> 00:44:08,880

807
00:44:08,880 --> 00:44:12,390
And it's worth mentioning if you
do look at this code, when

808
00:44:12,390 --> 00:44:17,110
you paint, knowing what you
paint into is actually

809
00:44:17,110 --> 00:44:19,610
implicitly represented
by a context.

810
00:44:19,610 --> 00:44:23,060
This graphics context is
basically the 2D drawing

811
00:44:23,060 --> 00:44:28,670
library that is given to a set
of render layers which was

812
00:44:28,670 --> 00:44:30,550
then used to actually draw.

813
00:44:30,550 --> 00:44:35,150
So in this 2D library what's
implied underneath is that you

814
00:44:35,150 --> 00:44:37,400
already know what is the buffer
of pixels that you're

815
00:44:37,400 --> 00:44:38,940
going to be painting into.

816
00:44:38,940 --> 00:44:41,380
And so all you have to do is
use this pointer, use this

817
00:44:41,380 --> 00:44:45,250
reference, this context, to
actually invoke your 2D

818
00:44:45,250 --> 00:44:47,330
drawing commands.

819
00:44:47,330 --> 00:44:49,370
And it will draw into
the correct buffer.

820
00:44:49,370 --> 00:44:56,130
So this is the context that's
passed from the compositor to

821
00:44:56,130 --> 00:45:01,230
Blink to identify your painting
into this correct

822
00:45:01,230 --> 00:45:03,320
buffer of pixels.

823
00:45:03,320 --> 00:45:05,250
And then as I mentioned before,
it uses the painting

824
00:45:05,250 --> 00:45:08,730
phase mechanism for render
layers to identify which

825
00:45:08,730 --> 00:45:12,170
composited layers
it paints into.

826
00:45:12,170 --> 00:45:15,420
So these are basically the two
pieces of data that need to be

827
00:45:15,420 --> 00:45:19,825
passed from the compositor to
the render layer in order to

828
00:45:19,825 --> 00:45:21,075
paint correctly.

829
00:45:21,075 --> 00:45:26,790

830
00:45:26,790 --> 00:45:30,690
Yes and I think I'll let you
all look at these slides on

831
00:45:30,690 --> 00:45:32,850
your own afterwards.

832
00:45:32,850 --> 00:45:37,660
Let's talk about some of the
issues that come up with

833
00:45:37,660 --> 00:45:38,230
compositing.

834
00:45:38,230 --> 00:45:42,680
Compositing seems like it may
solve the world's problems,

835
00:45:42,680 --> 00:45:44,130
but it actually doesn't.

836
00:45:44,130 --> 00:45:47,220
And it has its own set of
problems that gets created.

837
00:45:47,220 --> 00:45:51,740
Ideally, what we would like is
the compositor to be super

838
00:45:51,740 --> 00:45:55,660
intelligent and it knows
what can we composite.

839
00:45:55,660 --> 00:45:58,340
What would be the cost
of doing so?

840
00:45:58,340 --> 00:46:01,780
What would be the memory cost,
the computation cost?

841
00:46:01,780 --> 00:46:02,920
What do we gain?

842
00:46:02,920 --> 00:46:06,120
And it would be able to optimize
between the trade off

843
00:46:06,120 --> 00:46:09,000
of what we gain by compositing,
in particular

844
00:46:09,000 --> 00:46:12,420
avoiding repainting, versus the
cost of actually computing

845
00:46:12,420 --> 00:46:14,590
all that stuff in
the first place.

846
00:46:14,590 --> 00:46:18,100
Realistically, that's
a very hard problem.

847
00:46:18,100 --> 00:46:21,370
And it's not always clear that
there is actually an ideal

848
00:46:21,370 --> 00:46:24,690
answer for various algorithms
or various policies or

849
00:46:24,690 --> 00:46:28,100
heuristics we choose, we may
be trading off making some

850
00:46:28,100 --> 00:46:30,620
pages better and other
pages worse.

851
00:46:30,620 --> 00:46:35,570
So, in reality, what we really
do is just we composite when

852
00:46:35,570 --> 00:46:39,620
we believe that we need it, or
when we really do need it.

853
00:46:39,620 --> 00:46:42,960
For example, 3D transforms are
not supported unless you have

854
00:46:42,960 --> 00:46:46,310
the accelerated compositor
enabled.

855
00:46:46,310 --> 00:46:52,770
And once we do that and we
accept that it is what it is,

856
00:46:52,770 --> 00:46:56,770
whatever we've composited
blindly, we just accept that

857
00:46:56,770 --> 00:46:59,450
the overhead exists.

858
00:46:59,450 --> 00:47:05,740
And we rely on ourselves as
architects of this to add

859
00:47:05,740 --> 00:47:08,510
heuristics or to identify cases
where the overhead can

860
00:47:08,510 --> 00:47:09,910
be reduced.

861
00:47:09,910 --> 00:47:13,570
But as an algorithm itself,
the principal and the

862
00:47:13,570 --> 00:47:16,240
fundamental design of the
algorithm is basically blind.

863
00:47:16,240 --> 00:47:19,330

864
00:47:19,330 --> 00:47:20,940
What are the overheads
of compositing?

865
00:47:20,940 --> 00:47:24,650
Well there's the computational
cost of actually checking for

866
00:47:24,650 --> 00:47:27,550
overlap, iterating over
all the render layers.

867
00:47:27,550 --> 00:47:29,940
Where they are there can be
hundreds, even thousands on

868
00:47:29,940 --> 00:47:31,510
some pages.

869
00:47:31,510 --> 00:47:34,500
Most of them won't get
composited, but they all have

870
00:47:34,500 --> 00:47:38,130
to be visited in order to
determine whether we might

871
00:47:38,130 --> 00:47:41,560
need to composite them.

872
00:47:41,560 --> 00:47:43,680
That can get pretty costly.

873
00:47:43,680 --> 00:47:46,930
There's the cost of actually
managing several more layer

874
00:47:46,930 --> 00:47:48,680
tree data structures.

875
00:47:48,680 --> 00:47:52,760
We have the composited layer
tree structure in Chromium.

876
00:47:52,760 --> 00:47:54,890
We have the graphics later
composited layer tree

877
00:47:54,890 --> 00:47:56,840
structure in Blink.

878
00:47:56,840 --> 00:48:00,570
We have the paint order
render layer tree.

879
00:48:00,570 --> 00:48:04,990
There's actually a few extra
layer trees inside of the

880
00:48:04,990 --> 00:48:08,140
Chromium compositor itself.

881
00:48:08,140 --> 00:48:15,120
And mostly I think the worst
issue is that when we choose

882
00:48:15,120 --> 00:48:19,560
to create a composite layer out
of a render layer, we are

883
00:48:19,560 --> 00:48:24,060
saying that we intend to
allocate pixels to represent

884
00:48:24,060 --> 00:48:28,000
that layer or that group of
layers, that subtree.

885
00:48:28,000 --> 00:48:32,500
And that greatly increases
memory cost

886
00:48:32,500 --> 00:48:34,120
for rendering a page.

887
00:48:34,120 --> 00:48:39,030

888
00:48:39,030 --> 00:48:41,510
There's also some issues for
just rendering in general.

889
00:48:41,510 --> 00:48:45,950

890
00:48:45,950 --> 00:48:49,230
In theory you should not know if
we are actually compositing

891
00:48:49,230 --> 00:48:50,620
things or not.

892
00:48:50,620 --> 00:48:52,850
But realistically there are
some things that you,

893
00:48:52,850 --> 00:48:57,900
especially as a web developer,
might want to be aware of.

894
00:48:57,900 --> 00:49:01,690
Anti-aliasing we would actually
do around the edges

895
00:49:01,690 --> 00:49:03,510
of our composited layers.

896
00:49:03,510 --> 00:49:07,720
But we wouldn't necessarily be
able to anti-alias as nicely

897
00:49:07,720 --> 00:49:10,220
the contents inside
of a layer.

898
00:49:10,220 --> 00:49:15,170
So, for example, if you had
elements with a border inside

899
00:49:15,170 --> 00:49:18,950
of a composited layer and then
you maybe rotated that layer,

900
00:49:18,950 --> 00:49:23,300
the edges of the composited
layer outside would look

901
00:49:23,300 --> 00:49:25,430
smooth because we are able
to anti-alias those.

902
00:49:25,430 --> 00:49:29,360
But the border on the inside
that renders in that layer may

903
00:49:29,360 --> 00:49:32,530
not necessarily look smooth
because it's actually just

904
00:49:32,530 --> 00:49:37,500
pixel data that's rendered into
the composited layer.

905
00:49:37,500 --> 00:49:40,800
Another issue that comes up is
the difference between LCD

906
00:49:40,800 --> 00:49:46,440
text anti-aliasing and non LCD
text anti-aliasing, which

907
00:49:46,440 --> 00:49:49,170
looks a bit blurrier.

908
00:49:49,170 --> 00:49:54,310
Unless we know for sure that
the composited layer is

909
00:49:54,310 --> 00:49:58,100
completely opaque, we
actually cannot.

910
00:49:58,100 --> 00:50:02,170
There's just some fundamental
limitations that solving them

911
00:50:02,170 --> 00:50:03,360
is actually bit costly.

912
00:50:03,360 --> 00:50:05,880
And it's an open problem of how
we might eventually solve

913
00:50:05,880 --> 00:50:08,290
this, but we actually
cannot do LCD text

914
00:50:08,290 --> 00:50:11,230
anti-aliasing in that case.

915
00:50:11,230 --> 00:50:14,560
The best we can do then is
resort to the blurry text

916
00:50:14,560 --> 00:50:16,000
anti-aliasiing.

917
00:50:16,000 --> 00:50:22,130
And for devices that don't
have a high resolution,

918
00:50:22,130 --> 00:50:24,150
switching between these two
actually becomes very

919
00:50:24,150 --> 00:50:26,780
noticeable and unpleasing.

920
00:50:26,780 --> 00:50:29,440
And in many cases it's not
even just the switching

921
00:50:29,440 --> 00:50:31,950
between the two that would look
like the text is sort of

922
00:50:31,950 --> 00:50:36,250
flickering or wiggling a little,
but also just the fact

923
00:50:36,250 --> 00:50:38,640
that you might get blurry text
where you would prefer to have

924
00:50:38,640 --> 00:50:41,000
very nicely anti-alias text.

925
00:50:41,000 --> 00:50:45,070
A good example of this is in
menus, nav bars at the top

926
00:50:45,070 --> 00:50:47,760
that you might make fixed
position, for example.

927
00:50:47,760 --> 00:50:50,060
If they become composited
for some reason.

928
00:50:50,060 --> 00:50:53,890
Maybe they overlap some other
composited stuff, their text

929
00:50:53,890 --> 00:50:59,810
might not be able to get nice
LCD text anti-aliasing.

930
00:50:59,810 --> 00:51:01,500
In theory we also want
to render at

931
00:51:01,500 --> 00:51:04,500
least as fast as software.

932
00:51:04,500 --> 00:51:06,250
And generally we do.

933
00:51:06,250 --> 00:51:10,540
It is usually quite successful
at rendering very fast.

934
00:51:10,540 --> 00:51:14,880
But there's often cases where
once a page becomes

935
00:51:14,880 --> 00:51:18,570
complicated enough, especially
if we cannot benefit from

936
00:51:18,570 --> 00:51:19,730
avoiding repainting.

937
00:51:19,730 --> 00:51:24,910
If we still really need to
repaint layers every frame,

938
00:51:24,910 --> 00:51:30,730
then compositing actually is not
going to be as beneficial.

939
00:51:30,730 --> 00:51:32,220
We would have to
repaint anyway.

940
00:51:32,220 --> 00:51:35,560
We would have to not only do the
repainting whether we were

941
00:51:35,560 --> 00:51:38,630
in software or in composited
mode, but we would also then

942
00:51:38,630 --> 00:51:42,510
with composited mode have
potentially a larger number of

943
00:51:42,510 --> 00:51:44,660
layers that cost more memory.

944
00:51:44,660 --> 00:51:49,490
And sometimes the bandwidth of
just drawing these layers on a

945
00:51:49,490 --> 00:51:52,610
lightweight mobile GPU, for
example, can actually become

946
00:51:52,610 --> 00:51:56,770
the bottleneck that maybe is
just more costly than the

947
00:51:56,770 --> 00:51:58,830
painting itself in
some rare cases.

948
00:51:58,830 --> 00:52:02,230

949
00:52:02,230 --> 00:52:04,970
So I think that's about it.

950
00:52:04,970 --> 00:52:08,540
If you have any questions I'd
be happy to taking them over

951
00:52:08,540 --> 00:52:13,180
the graphics dev at chromium.org
discussion list.

952
00:52:13,180 --> 00:52:14,920
My LDAP is Shawn Singh.

953
00:52:14,920 --> 00:52:19,120
That's spelled S-H-A-WN
S-I-N-G-H @chromium.org.

954
00:52:19,120 --> 00:52:22,630
Chromium I'm happy to receive
emails as well.

955
00:52:22,630 --> 00:52:23,870
And thank you for your time.

956
00:52:23,870 --> 00:52:24,620
Thank you for listening.

957
00:52:24,620 --> 00:52:25,870
I hope you enjoyed it.

958
00:52:25,870 --> 00:52:38,140

959
00:52:38,140 --> 00:54:13,950
[MUSIC PLAYING]

