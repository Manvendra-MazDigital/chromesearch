1
00:00:00,000 --> 00:00:03,060

2
00:00:03,060 --> 00:00:05,141
Good morning.

3
00:00:05,141 --> 00:00:05,890
I'm Brian McQuade.

4
00:00:05,890 --> 00:00:07,306
I'm a software
engineer at Google.

5
00:00:07,306 --> 00:00:09,410
I work on making the mobile
web faster and better.

6
00:00:09,410 --> 00:00:11,160
And today I'm going
to talk about building

7
00:00:11,160 --> 00:00:13,090
an instant mobile web apps.

8
00:00:13,090 --> 00:00:16,100
So we'll take the next 30
minutes to cover two topics.

9
00:00:16,100 --> 00:00:17,810
The first will be,
I'll give an overview

10
00:00:17,810 --> 00:00:19,920
of the process my
team actually took

11
00:00:19,920 --> 00:00:22,106
to optimize one of
the apps I work on.

12
00:00:22,106 --> 00:00:23,480
And then in the
second half we'll

13
00:00:23,480 --> 00:00:26,470
take from that some learnings
or some generalizations and best

14
00:00:26,470 --> 00:00:28,750
practices that hopefully
you can take with you

15
00:00:28,750 --> 00:00:30,580
to make your mobile apps faster.

16
00:00:30,580 --> 00:00:34,350

17
00:00:34,350 --> 00:00:37,190
OK, so our goal
specifically, more precisely,

18
00:00:37,190 --> 00:00:39,960
is to render app content
on the phone in a second.

19
00:00:39,960 --> 00:00:42,980
So from the time a user
clicks a link, to the time

20
00:00:42,980 --> 00:00:45,520
they actually start to
see content on your phone

21
00:00:45,520 --> 00:00:48,122
and you're able to interact with
it, should be about a second.

22
00:00:48,122 --> 00:00:49,580
And this one second
target actually

23
00:00:49,580 --> 00:00:51,570
comes from some work
linked here at the bottom

24
00:00:51,570 --> 00:00:53,070
by Jakob Nielsen &mdash;
hopefully you can

25
00:00:53,070 --> 00:00:55,900
see that &mdash; that talks about
some different thresholds

26
00:00:55,900 --> 00:00:59,289
of human perception, where,
sort of, behavior changes.

27
00:00:59,289 --> 00:01:01,080
And that one second
boundary is interesting

28
00:01:01,080 --> 00:01:03,205
because that's the point
at which a user will start

29
00:01:03,205 --> 00:01:06,930
to disengage with the
activity they've initiated.

30
00:01:06,930 --> 00:01:09,110
They'll start to think
about doing something else.

31
00:01:09,110 --> 00:01:13,594
And so to keep the user
engaged, to keep them wanting

32
00:01:13,594 --> 00:01:16,010
to use your app, we want to
try to deliver that content as

33
00:01:16,010 --> 00:01:18,400
quickly as possible, ideally
within that roughly one

34
00:01:18,400 --> 00:01:21,070
second boundary.

35
00:01:21,070 --> 00:01:24,179
So a lot of what I'm going
to talk about focuses

36
00:01:24,179 --> 00:01:26,720
on this concept of the critical
rendering path, which you may

37
00:01:26,720 --> 00:01:29,225
have heard Ilya talk about
or others talk about.

38
00:01:29,225 --> 00:01:31,350
At a really high level,
the critical rendering path

39
00:01:31,350 --> 00:01:33,860
is sort of the
sequence of resources

40
00:01:33,860 --> 00:01:35,690
that need to be
loaded and parsed,

41
00:01:35,690 --> 00:01:40,620
usually JavaScript and
style sheet resources,

42
00:01:40,620 --> 00:01:43,050
that prevent content on
the page from actually

43
00:01:43,050 --> 00:01:44,270
rendering from the screen.

44
00:01:44,270 --> 00:01:47,624
So actually it's easiest
to explain, I think,

45
00:01:47,624 --> 00:01:48,290
with an example.

46
00:01:48,290 --> 00:01:52,110

47
00:01:52,110 --> 00:01:54,510
So here along the top
we've got a timeline

48
00:01:54,510 --> 00:01:57,880
that shows how an example page
that I'm using for this example

49
00:01:57,880 --> 00:02:01,720
renders over time, out to 20
seconds on a mobile device.

50
00:02:01,720 --> 00:02:03,437
So we have a performance
problem here.

51
00:02:03,437 --> 00:02:05,520
And the question becomes,
well, why is it so slow?

52
00:02:05,520 --> 00:02:08,229
Why is it taking nine seconds to
render anything to the screen,

53
00:02:08,229 --> 00:02:11,450
and why does it take 20
seconds to finish rendering?

54
00:02:11,450 --> 00:02:15,010
And that's what the critical
rendering path tries to answer.

55
00:02:15,010 --> 00:02:17,280
So if we have an example
network waterfall here,

56
00:02:17,280 --> 00:02:18,780
we can walk through
and try to start

57
00:02:18,780 --> 00:02:21,780
to make sense of what this
critical rendering path is all

58
00:02:21,780 --> 00:02:22,280
about.

59
00:02:22,280 --> 00:02:26,350
So obviously, we start by
loading the HTML resource.

60
00:02:26,350 --> 00:02:27,840
That comes back
with some content.

61
00:02:27,840 --> 00:02:30,790
It might have a style sheet,
and a script resource.

62
00:02:30,790 --> 00:02:32,820
And so at this point
we have &mdash; like I said,

63
00:02:32,820 --> 00:02:36,500
the critical path includes,
usually, script and styles.

64
00:02:36,500 --> 00:02:37,990
These resources
block the browser

65
00:02:37,990 --> 00:02:39,865
from actually painting
content to the screen.

66
00:02:39,865 --> 00:02:41,369
So while a style
sheet is pending,

67
00:02:41,369 --> 00:02:43,410
the browser is going to
wait for that style sheet

68
00:02:43,410 --> 00:02:44,600
to load before it
actually paints

69
00:02:44,600 --> 00:02:45,720
any content to the screen.

70
00:02:45,720 --> 00:02:48,945
So we can't paint anything until
these resources finish loading.

71
00:02:48,945 --> 00:02:51,930

72
00:02:51,930 --> 00:02:54,610
Imagine that we sent out the
request for both of those.

73
00:02:54,610 --> 00:02:57,590
The response comes back to the
JavaScript in nine seconds,

74
00:02:57,590 --> 00:03:00,767
and at that point, we can
begin to paint something

75
00:03:00,767 --> 00:03:01,350
to the screen.

76
00:03:01,350 --> 00:03:03,160
It may not be the content
the user actually wants,

77
00:03:03,160 --> 00:03:03,760
unfortunately.

78
00:03:03,760 --> 00:03:05,070
That's sort of at the end.

79
00:03:05,070 --> 00:03:06,880
But we've sort of
started to paint.

80
00:03:06,880 --> 00:03:10,030
And then from there imagine the
JavaScript resource adds a CSS

81
00:03:10,030 --> 00:03:12,050
resource to the DOM, a
style sheet to the DOM,

82
00:03:12,050 --> 00:03:14,000
and so now that's
on the critical path

83
00:03:14,000 --> 00:03:15,790
for subsequent paints.

84
00:03:15,790 --> 00:03:20,160
Once that loads, we can paint
a little bit more content.

85
00:03:20,160 --> 00:03:23,670
The style sheet maybe had
some stylings for the footer.

86
00:03:23,670 --> 00:03:27,430
Additionally, we've loaded, say,
a second JavaScript resource

87
00:03:27,430 --> 00:03:29,470
from that first
JavaScript resource.

88
00:03:29,470 --> 00:03:31,270
And say that's used
to actually render

89
00:03:31,270 --> 00:03:32,920
the main content on the screen.

90
00:03:32,920 --> 00:03:34,490
And so that now
has to load, parse,

91
00:03:34,490 --> 00:03:35,610
and execute before
you can actually

92
00:03:35,610 --> 00:03:37,580
see any content on the
screen &mdash; or, I'm sorry,

93
00:03:37,580 --> 00:03:38,940
see the final content.

94
00:03:38,940 --> 00:03:41,280
And then finally around
19 or 20 seconds,

95
00:03:41,280 --> 00:03:44,440
all of that finishes, that
whole process of these things

96
00:03:44,440 --> 00:03:46,180
loading in the browser
finishes, and we

97
00:03:46,180 --> 00:03:48,360
could paint these finished
content to the screen

98
00:03:48,360 --> 00:03:49,991
and show that the user.

99
00:03:49,991 --> 00:03:51,490
So the critical
rendering path tries

100
00:03:51,490 --> 00:03:54,350
to focus on the most
significant resources that

101
00:03:54,350 --> 00:03:58,070
cause render-blocking,
and explain

102
00:03:58,070 --> 00:03:59,500
why we see these delays.

103
00:03:59,500 --> 00:04:01,920
But this becomes especially
important on mobile, where

104
00:04:01,920 --> 00:04:04,020
we have these very high
network round-trip times,

105
00:04:04,020 --> 00:04:06,290
and loading extra
JavaScript and CSS resources

106
00:04:06,290 --> 00:04:09,810
ends up having a
significant cost.

107
00:04:09,810 --> 00:04:13,199
So now, we'll focus
more on thinking

108
00:04:13,199 --> 00:04:14,490
about optimizing critical path.

109
00:04:14,490 --> 00:04:17,769
We know, here, that we've got
this really long critical path

110
00:04:17,769 --> 00:04:18,570
of resources.

111
00:04:18,570 --> 00:04:20,630
This is just a toy example.

112
00:04:20,630 --> 00:04:22,780
So the question becomes,
how do we actually

113
00:04:22,780 --> 00:04:23,951
address and optimize that?

114
00:04:23,951 --> 00:04:25,950
I'm going to talk about
the process my team went

115
00:04:25,950 --> 00:04:29,280
through about a year ago to do
just that for one of the apps

116
00:04:29,280 --> 00:04:31,779
I work on, PageSpeed Insights.

117
00:04:31,779 --> 00:04:33,570
So PageSpeed Insights
is a tool you can use

118
00:04:33,570 --> 00:04:36,759
at
developers.google.com/pagespeed.

119
00:04:36,759 --> 00:04:39,300
This is a tool where you could
enter a URL into the box here.

120
00:04:39,300 --> 00:04:44,010
We go off and we render the
page in a headless browser.

121
00:04:44,010 --> 00:04:46,050
We analyze how it loads.

122
00:04:46,050 --> 00:04:48,080
And we come back and give
you a prioritized list

123
00:04:48,080 --> 00:04:50,720
of recommendations to
make the page load faster.

124
00:04:50,720 --> 00:04:52,470
And about a year ago,
we had this problem.

125
00:04:52,470 --> 00:04:54,000
Well, we started
to think about, OK,

126
00:04:54,000 --> 00:04:57,500
how do we make this page
really fast on mobile?

127
00:04:57,500 --> 00:05:00,350
We knew we weren't doing great,
but the first thing we did

128
00:05:00,350 --> 00:05:03,586
is we wanted to see exactly
how poorly we were doing.

129
00:05:03,586 --> 00:05:05,210
And so what we saw
really surprised us.

130
00:05:05,210 --> 00:05:07,870
It was worse than we expected.

131
00:05:07,870 --> 00:05:10,112
Now you can see where
the example comes from.

132
00:05:10,112 --> 00:05:12,070
It took nine seconds to
render anything at all,

133
00:05:12,070 --> 00:05:14,590
but it took about 19 or 20
seconds on a 3G connection

134
00:05:14,590 --> 00:05:16,740
or on an iPhone 4, in
this case, to render

135
00:05:16,740 --> 00:05:18,199
what the user
actually cared about,

136
00:05:18,199 --> 00:05:19,906
which was that initial
text box that they

137
00:05:19,906 --> 00:05:21,590
could use to interact
with the app.

138
00:05:21,590 --> 00:05:25,990
And so, 20 seconds.

139
00:05:25,990 --> 00:05:27,810
Our target is one second.

140
00:05:27,810 --> 00:05:30,140
We've got a really
significant problem here,

141
00:05:30,140 --> 00:05:32,450
and we knew we needed
to really rethink a lot,

142
00:05:32,450 --> 00:05:34,810
or try to figure out what
we had missed, right?

143
00:05:34,810 --> 00:05:36,870
This app was reasonably
fast on desktop,

144
00:05:36,870 --> 00:05:39,960
but on a high latency
mobile connection,

145
00:05:39,960 --> 00:05:41,530
it just took way
too long to load.

146
00:05:41,530 --> 00:05:44,217
So we started to
look at the markup.

147
00:05:44,217 --> 00:05:46,050
We saw we had some
render-blocking resources

148
00:05:46,050 --> 00:05:46,984
in the head.

149
00:05:46,984 --> 00:05:48,650
But this isn't all
that uncommon, right?

150
00:05:48,650 --> 00:05:49,860
You see this in lots of apps.

151
00:05:49,860 --> 00:05:51,734
So there's nothing that
really stood out here

152
00:05:51,734 --> 00:05:53,820
as being particularly costly.

153
00:05:53,820 --> 00:05:56,850
So we went back to our timeline.

154
00:05:56,850 --> 00:05:58,770
Then we looked at a
network waterfall.

155
00:05:58,770 --> 00:06:01,980
You can see we load
about 25 resources here.

156
00:06:01,980 --> 00:06:03,970
And the question came
up, OK, well we're

157
00:06:03,970 --> 00:06:06,720
loading all these resources,
but which of these resources

158
00:06:06,720 --> 00:06:09,530
are actually contributing
to making the page slower?

159
00:06:09,530 --> 00:06:12,710
Which of these are on the
critical rendering path?

160
00:06:12,710 --> 00:06:15,360
And so one of the things that
PageSpeed Insights actually

161
00:06:15,360 --> 00:06:18,992
does today is it can
tell you which resources

162
00:06:18,992 --> 00:06:20,450
are on the critical
rendering path.

163
00:06:20,450 --> 00:06:22,480
And so we can go here.

164
00:06:22,480 --> 00:06:25,460
We can click through.

165
00:06:25,460 --> 00:06:28,080
And we can see we've got these
JavaScript resources, these CSS

166
00:06:28,080 --> 00:06:30,204
resources that are on that
critical rendering path,

167
00:06:30,204 --> 00:06:32,780
that block rendering of
content on the screen,

168
00:06:32,780 --> 00:06:34,760
and then use that to go
back to our waterfall

169
00:06:34,760 --> 00:06:39,060
and start to focus on
which resources actually

170
00:06:39,060 --> 00:06:39,840
block rendering.

171
00:06:39,840 --> 00:06:44,040
So now we have about a
dozen resources to focus on.

172
00:06:44,040 --> 00:06:46,287
And we're able to focus
more precisely on,

173
00:06:46,287 --> 00:06:48,620
what are the render-blocking
effects of these resources?

174
00:06:48,620 --> 00:06:50,490
And then, how do
we address those?

175
00:06:50,490 --> 00:06:52,500
And so we can begin to
sort of match up here.

176
00:06:52,500 --> 00:06:57,610
We've got some content that
loads before the nine second

177
00:06:57,610 --> 00:06:58,130
first paint.

178
00:06:58,130 --> 00:07:00,850
We can start to notice
which of those resources

179
00:07:00,850 --> 00:07:01,850
are blocking that point.

180
00:07:01,850 --> 00:07:03,632
I'll get into that
in just a minute.

181
00:07:03,632 --> 00:07:05,590
But this was sort of the
starting point for us,

182
00:07:05,590 --> 00:07:08,440
was looking at this
and figuring out,

183
00:07:08,440 --> 00:07:11,230
how do we optimize the critical
rendering path for this page?

184
00:07:11,230 --> 00:07:17,690

185
00:07:17,690 --> 00:07:20,420
At a high level we felt like
we had two problems here.

186
00:07:20,420 --> 00:07:24,410
One was that we had a bunch
of render-blocking JavaScript

187
00:07:24,410 --> 00:07:28,660
and CSS loaded in a way that
blocked any content at all

188
00:07:28,660 --> 00:07:31,420
from rendering the page &mdash;
rendering on the page.

189
00:07:31,420 --> 00:07:33,950
So this block of
JavaScript and CSS

190
00:07:33,950 --> 00:07:37,650
here, which declared in
the head of the HTML, all

191
00:07:37,650 --> 00:07:40,050
had to be downloaded,
parsed, and executed in order

192
00:07:40,050 --> 00:07:42,330
for anything at all
to render on screen.

193
00:07:42,330 --> 00:07:46,820
And as we know, mobile networks
have really high latency,

194
00:07:46,820 --> 00:07:49,950
so downloading
additional resources has

195
00:07:49,950 --> 00:07:52,220
a pretty significant,
pretty high cost,

196
00:07:52,220 --> 00:07:54,650
all the while your users are
looking at a blank screen,

197
00:07:54,650 --> 00:07:56,570
waiting and wondering
if your app is working,

198
00:07:56,570 --> 00:07:59,724
thinking about transitioning
away to do something else.

199
00:07:59,724 --> 00:08:01,890
So for us &mdash; and I'll show
it in a little more detail

200
00:08:01,890 --> 00:08:04,150
in a minute &mdash; what we
concluded we needed to do

201
00:08:04,150 --> 00:08:07,240
was basically eliminate
all of these resources

202
00:08:07,240 --> 00:08:08,597
from being render-blocking.

203
00:08:08,597 --> 00:08:10,680
And that amounted to doing
two things, which we'll

204
00:08:10,680 --> 00:08:14,004
dive into &mdash; loading our
render-blocking JavaScript

205
00:08:14,004 --> 00:08:15,670
asynchronously, and
then really thinking

206
00:08:15,670 --> 00:08:17,330
about what is the
minimal amount of CSS

207
00:08:17,330 --> 00:08:19,110
we actually need
to render this out,

208
00:08:19,110 --> 00:08:21,422
and loading that in a
blocking way, but making sure

209
00:08:21,422 --> 00:08:22,880
we weren't loading
any more than we

210
00:08:22,880 --> 00:08:24,360
needed in a render-blocking way.

211
00:08:24,360 --> 00:08:27,479

212
00:08:27,479 --> 00:08:29,020
And so recall, this
is the screenshot

213
00:08:29,020 --> 00:08:33,340
that was associated with
that point in the page load.

214
00:08:33,340 --> 00:08:35,489
The thing to note here is
that we haven't actually

215
00:08:35,489 --> 00:08:37,280
rendered the content
the user really cared,

216
00:08:37,280 --> 00:08:40,510
that text box to interact
with the app yet.

217
00:08:40,510 --> 00:08:43,110
So the second issue
was, we were actually

218
00:08:43,110 --> 00:08:45,680
rendering that sort
of critical content,

219
00:08:45,680 --> 00:08:49,290
the text box, that the user
could use to actually analyze

220
00:08:49,290 --> 00:08:51,650
a page, using a
JavaScript resource.

221
00:08:51,650 --> 00:08:54,341
We made it to download a
large chunk of JavaScript,

222
00:08:54,341 --> 00:08:56,590
download, parse, and execute
that JavaScript before we

223
00:08:56,590 --> 00:08:58,880
actually rendered
that, using JavaScript

224
00:08:58,880 --> 00:09:00,490
to construct the DOM.

225
00:09:00,490 --> 00:09:03,020
So this added another
roughly 10 seconds of latency

226
00:09:03,020 --> 00:09:05,100
here before we could
get to this point.

227
00:09:05,100 --> 00:09:11,610
So all in all, we had at a
high level these two problems.

228
00:09:11,610 --> 00:09:14,240
And so we sat down and we
tried to address these things.

229
00:09:14,240 --> 00:09:16,882
The thing we did for this was
we realized most of the content,

230
00:09:16,882 --> 00:09:18,340
we're rendering it
with JavaScript,

231
00:09:18,340 --> 00:09:20,780
and that's fine and great,
but it just wasn't performant.

232
00:09:20,780 --> 00:09:24,950
And so what we did is we
inlined that initial view.

233
00:09:24,950 --> 00:09:27,830
Or I should say, we put the
initial view's HTML markup

234
00:09:27,830 --> 00:09:31,070
directly in HTML, no longer
depending on JavaScript

235
00:09:31,070 --> 00:09:34,209
to actually render that, which
allowed us to present that

236
00:09:34,209 --> 00:09:36,000
to the user that much
faster without having

237
00:09:36,000 --> 00:09:40,490
to wait for that render-blocking
JavaScript to load.

238
00:09:40,490 --> 00:09:42,930
So I just wanted to show
a quick before and after.

239
00:09:42,930 --> 00:09:45,860
Here's that HTML markup
for the original page that

240
00:09:45,860 --> 00:09:48,220
took 19 seconds, at
least part of it.

241
00:09:48,220 --> 00:09:50,570
We've got our render-blocking
JavaScript in the head.

242
00:09:50,570 --> 00:09:56,380
We've got some markup
for the content,

243
00:09:56,380 --> 00:09:58,477
but we don't have, you'll
notice, the input box.

244
00:09:58,477 --> 00:10:00,560
That was rendered with
JavaScript, so some of that

245
00:10:00,560 --> 00:10:01,840
comes later.

246
00:10:01,840 --> 00:10:07,300
The after case &mdash; here, we've
got a slightly different markup.

247
00:10:07,300 --> 00:10:10,530
First, we've got an inline style
block that contains the CSS.

248
00:10:10,530 --> 00:10:12,840
We need to style the
content in the initial view.

249
00:10:12,840 --> 00:10:14,410
So we don't have
to go to network

250
00:10:14,410 --> 00:10:16,300
to download additional
style sheets, which

251
00:10:16,300 --> 00:10:18,820
will incur additional mobile
network round trips, which

252
00:10:18,820 --> 00:10:21,790
are significantly slower,
or significantly slow

253
00:10:21,790 --> 00:10:24,030
down the page load.

254
00:10:24,030 --> 00:10:25,490
And then as I
mentioned, now we've

255
00:10:25,490 --> 00:10:27,880
made sure that all
the markup we need

256
00:10:27,880 --> 00:10:30,960
to render the above the fold
content is directly in HTML.

257
00:10:30,960 --> 00:10:34,090
We're not using JavaScript to
render any of this content.

258
00:10:34,090 --> 00:10:36,810
And then finally,
because we're including

259
00:10:36,810 --> 00:10:39,840
all the markup we need to
render the initial view directly

260
00:10:39,840 --> 00:10:43,432
in HTML, we can load our
JavaScript asynchronously

261
00:10:43,432 --> 00:10:44,890
because we don't
need it to render,

262
00:10:44,890 --> 00:10:46,473
so we don't want it
to block rendering

263
00:10:46,473 --> 00:10:50,240
of the initial presentation.

264
00:10:50,240 --> 00:10:52,667
So that high level was the
process we went through.

265
00:10:52,667 --> 00:10:54,250
And so the question
is, how did we do?

266
00:10:54,250 --> 00:10:56,690
Did we actually
speed the page up?

267
00:10:56,690 --> 00:11:00,270
So here's the waterfall
for the original page.

268
00:11:00,270 --> 00:11:04,660
We've got about 25
resources in total.

269
00:11:04,660 --> 00:11:07,420
And then here's the waterfall
for this rewrite that

270
00:11:07,420 --> 00:11:09,760
was focused on delivering
a really fast experience

271
00:11:09,760 --> 00:11:10,530
on mobile.

272
00:11:10,530 --> 00:11:12,730
And you can see we've got
about 20 resources now.

273
00:11:12,730 --> 00:11:16,836
So we had 25 before, 20 now.

274
00:11:16,836 --> 00:11:18,460
It's not really
significantly different

275
00:11:18,460 --> 00:11:19,876
if you look at the
total waterfall

276
00:11:19,876 --> 00:11:21,330
size, total number of requests.

277
00:11:21,330 --> 00:11:22,788
But I think what's
really important

278
00:11:22,788 --> 00:11:25,202
here is looking not at the
total number of requests,

279
00:11:25,202 --> 00:11:27,160
but the relative size of
the two critical paths

280
00:11:27,160 --> 00:11:30,490
between the critical rendering
paths, between the two pages.

281
00:11:30,490 --> 00:11:32,937
So in the old example, we had
a bunch of resources here.

282
00:11:32,937 --> 00:11:34,520
We've got everything
we need to render

283
00:11:34,520 --> 00:11:37,200
the initial view in
the HTML payload.

284
00:11:37,200 --> 00:11:39,750
So the critical path, the
critical rendering path,

285
00:11:39,750 --> 00:11:41,180
is this one HTML resource.

286
00:11:41,180 --> 00:11:43,750
And we can render
much more quickly

287
00:11:43,750 --> 00:11:46,370
than in the original case
where we had a dozen resources.

288
00:11:46,370 --> 00:11:49,280
So we often talk
about, well, reducing

289
00:11:49,280 --> 00:11:51,494
requests is a goal
with performance

290
00:11:51,494 --> 00:11:52,410
and with optimization.

291
00:11:52,410 --> 00:11:53,909
But I think what's
more important is

292
00:11:53,909 --> 00:11:55,830
to think about reducing
the number of requests

293
00:11:55,830 --> 00:11:57,400
on the critical rendering path.

294
00:11:57,400 --> 00:12:01,420
That's really where you
will see your big returns.

295
00:12:01,420 --> 00:12:02,300
So let's look.

296
00:12:02,300 --> 00:12:05,000
Let's do sort of a side
by side, before and after.

297
00:12:05,000 --> 00:12:07,840
So the optimized case,
we start to render in

298
00:12:07,840 --> 00:12:09,680
about a second a half,
and we're completely

299
00:12:09,680 --> 00:12:10,596
done at three seconds.

300
00:12:10,596 --> 00:12:12,530
All the images,
everything, have come back.

301
00:12:12,530 --> 00:12:13,910
And recall the original case.

302
00:12:13,910 --> 00:12:15,694
We're still waiting.

303
00:12:15,694 --> 00:12:17,860
We can't actually really
interact with the app, even

304
00:12:17,860 --> 00:12:20,670
at this point, because we
don't have the text box.

305
00:12:20,670 --> 00:12:28,850
So we were able to reduce
the render time down

306
00:12:28,850 --> 00:12:31,620
from about 20 seconds down
to one or one half seconds.

307
00:12:31,620 --> 00:12:34,240
So we more or less
accomplished our goal.

308
00:12:34,240 --> 00:12:36,480
So that's the process
we went through,

309
00:12:36,480 --> 00:12:39,170
and now I'm going to
spend little time talking

310
00:12:39,170 --> 00:12:42,080
about the process of
optimizing your app's content.

311
00:12:42,080 --> 00:12:43,180
So what did we learn?

312
00:12:43,180 --> 00:12:44,960
What are the general
best practices there?

313
00:12:44,960 --> 00:12:47,510
How can you deliver this instant
experience for your users

314
00:12:47,510 --> 00:12:49,072
on mobile?

315
00:12:49,072 --> 00:12:51,030
So the first thing we
learned &mdash; the first thing

316
00:12:51,030 --> 00:12:54,010
we identified as an
important best practice &mdash;

317
00:12:54,010 --> 00:12:55,500
is to load script
asynchronously.

318
00:12:55,500 --> 00:12:59,670
So don't load scripts in a way
that blocks rendering, because

319
00:12:59,670 --> 00:13:03,460
on mobile networks, with the
high latency, high round trip

320
00:13:03,460 --> 00:13:05,160
times, each additional
resource you

321
00:13:05,160 --> 00:13:06,760
load in the critical
rendering path

322
00:13:06,760 --> 00:13:10,530
pushes out the time the user
has to wait to start interacting

323
00:13:10,530 --> 00:13:12,690
with your app pretty
significantly.

324
00:13:12,690 --> 00:13:16,810
So here we've got your
sort of standard page,

325
00:13:16,810 --> 00:13:19,810
group source equals all
that JS in the head.

326
00:13:19,810 --> 00:13:21,652
And we've got the
content right beneath it.

327
00:13:21,652 --> 00:13:23,860
The browser receives that
at the same time, probably,

328
00:13:23,860 --> 00:13:24,830
as the script.

329
00:13:24,830 --> 00:13:29,150
But it can't show it to the user
until the script has finished

330
00:13:29,150 --> 00:13:30,700
downloading, parsing,
and executing

331
00:13:30,700 --> 00:13:32,630
on the mobile device,
which introduces

332
00:13:32,630 --> 00:13:37,410
really significant additional
render latencies for the user.

333
00:13:37,410 --> 00:13:39,530
And so what do we do?

334
00:13:39,530 --> 00:13:41,970
In the best case, you
can take advantage

335
00:13:41,970 --> 00:13:45,430
of the HMTL5 async tag, which
tells the browser, yes, I

336
00:13:45,430 --> 00:13:48,360
need this script, I need
to load this script,

337
00:13:48,360 --> 00:13:51,786
but you don't need to execute
it inline at the point

338
00:13:51,786 --> 00:13:53,160
where it appears
in the document.

339
00:13:53,160 --> 00:13:55,674
Execute it sometime later
when it finishes downloading,

340
00:13:55,674 --> 00:13:57,090
and then go ahead
and just proceed

341
00:13:57,090 --> 00:13:59,374
parsing the rest
of the document,

342
00:13:59,374 --> 00:14:01,790
and render that content to the
user as quickly as you can.

343
00:14:01,790 --> 00:14:04,660
So this gets scripts out of
the critical rendering path,

344
00:14:04,660 --> 00:14:09,610
which is a really
important thing to do.

345
00:14:09,610 --> 00:14:12,860
So I'll say there are
some subtleties here.

346
00:14:12,860 --> 00:14:14,360
It's often not quite
as easy as just

347
00:14:14,360 --> 00:14:16,230
dropping the async tag in there.

348
00:14:16,230 --> 00:14:18,410
If you use document.write
in your JavaScript,

349
00:14:18,410 --> 00:14:20,900
this is a really
dangerous thing to do.

350
00:14:20,900 --> 00:14:23,280
And there are other
subtleties that I'd

351
00:14:23,280 --> 00:14:26,130
be happy to talk
about at the session.

352
00:14:26,130 --> 00:14:29,570
And I guess it'll be 45 minutes.

353
00:14:29,570 --> 00:14:32,750
So second, render the initial
view server-side as HTML.

354
00:14:32,750 --> 00:14:35,820
You'll recall we had
about six seconds

355
00:14:35,820 --> 00:14:37,440
of render-blocking
JavaScript and CSS,

356
00:14:37,440 --> 00:14:42,150
but then we had 10 seconds
to load that final JavaScript

357
00:14:42,150 --> 00:14:44,400
resource, download,
parse, and execute it

358
00:14:44,400 --> 00:14:46,150
before the app
finished rendering.

359
00:14:46,150 --> 00:14:48,630
And the problem was we were
loading this big JavaScript

360
00:14:48,630 --> 00:14:51,380
bundle, whose job it was to
actually construct the DOM.

361
00:14:51,380 --> 00:14:53,220
So we had to go to
network in order

362
00:14:53,220 --> 00:14:55,490
to create the DOM that
the user would see.

363
00:14:55,490 --> 00:14:58,010
And this is just, unfortunately,
an inherently slow process

364
00:14:58,010 --> 00:14:58,820
on mobile.

365
00:14:58,820 --> 00:15:01,974
Rendering client-side &mdash;
let's talk about &mdash; so

366
00:15:01,974 --> 00:15:03,640
what do we mean by
server-side rendering

367
00:15:03,640 --> 00:15:04,990
versus client-side rendering?

368
00:15:04,990 --> 00:15:09,050
So client-side rendering,
you're using JavaScript

369
00:15:09,050 --> 00:15:11,420
to actually render the
content in the document.

370
00:15:11,420 --> 00:15:13,200
So here we load up that JS.

371
00:15:13,200 --> 00:15:17,000
The DOM itself doesn't
really contain any markup.

372
00:15:17,000 --> 00:15:20,940
It doesn't contain mark up
that you see on the screen.

373
00:15:20,940 --> 00:15:22,690
It's just to figure
out a placeholder div,

374
00:15:22,690 --> 00:15:25,175
and then when app.js
finishes loading,

375
00:15:25,175 --> 00:15:27,550
we might get something like
this that actually constructs

376
00:15:27,550 --> 00:15:30,470
the DOM once that
resource finishes loading.

377
00:15:30,470 --> 00:15:35,449
By contrast, server-side
rendering &mdash; everything

378
00:15:35,449 --> 00:15:37,240
that we need to display
in the initial view

379
00:15:37,240 --> 00:15:40,050
is present right
in the HTML markup,

380
00:15:40,050 --> 00:15:41,810
and so no additional
resources are needed.

381
00:15:41,810 --> 00:15:43,330
As soon as that
HTML comes back, we

382
00:15:43,330 --> 00:15:45,080
can render that to the
screen and the user

383
00:15:45,080 --> 00:15:47,410
sees that as
quickly as possible.

384
00:15:47,410 --> 00:15:48,994
So this is just, on
mobile especially,

385
00:15:48,994 --> 00:15:50,826
this is just a much
more performant approach

386
00:15:50,826 --> 00:15:51,840
for the initial view.

387
00:15:51,840 --> 00:15:54,750
So certainly, once the
app has finished loading,

388
00:15:54,750 --> 00:15:57,040
and the user is
interacting with your app &mdash;

389
00:15:57,040 --> 00:15:59,715
they're changing the way
the content is presented,

390
00:15:59,715 --> 00:16:01,840
maybe they're navigating
through a menu &mdash; certainly

391
00:16:01,840 --> 00:16:03,756
at that point it makes
sense to use JavaScript

392
00:16:03,756 --> 00:16:05,260
to construct your document.

393
00:16:05,260 --> 00:16:07,830
But for that initial
view, you should

394
00:16:07,830 --> 00:16:10,840
do as much server-side rendering
to HTML as you possibly can.

395
00:16:10,840 --> 00:16:14,250

396
00:16:14,250 --> 00:16:15,750
So we found this to be true.

397
00:16:15,750 --> 00:16:17,370
But we weren't the only ones.

398
00:16:17,370 --> 00:16:21,510
Twitter also came to
the same conclusion.

399
00:16:21,510 --> 00:16:23,260
So they wrote a blog
post about a year ago

400
00:16:23,260 --> 00:16:24,620
where they talked about this.

401
00:16:24,620 --> 00:16:27,990
In 2010, they'd
released new Twitter,

402
00:16:27,990 --> 00:16:30,340
where all the rendering
happened on the client.

403
00:16:30,340 --> 00:16:32,116
And they talked about
how that allowed

404
00:16:32,116 --> 00:16:33,740
them to do some
interesting new things,

405
00:16:33,740 --> 00:16:37,620
but it came at the consequence
of significant regression

406
00:16:37,620 --> 00:16:39,839
in actual client-side
render time.

407
00:16:39,839 --> 00:16:41,380
So in 2012, they
wrote this blog post

408
00:16:41,380 --> 00:16:43,630
where they talk about taking
back control of front end

409
00:16:43,630 --> 00:16:47,310
performance by moving
rendering back to the server.

410
00:16:47,310 --> 00:16:54,870
And what they found is that
page load times dropped really

411
00:16:54,870 --> 00:16:55,540
significantly.

412
00:16:55,540 --> 00:16:57,450
So wasn't like
10% or 15%, it was

413
00:16:57,450 --> 00:16:59,230
1/5 of what they
were previously.

414
00:16:59,230 --> 00:17:01,480
So this was a really
big thing for them.

415
00:17:01,480 --> 00:17:04,440
And in order to deliver that
instant experience on mobile,

416
00:17:04,440 --> 00:17:07,010
it's pretty much a
requirement that you

417
00:17:07,010 --> 00:17:10,170
render that initial
view server-side.

418
00:17:10,170 --> 00:17:13,185
So Twitter wasn't
the only organization

419
00:17:13,185 --> 00:17:14,900
to come to this conclusion.

420
00:17:14,900 --> 00:17:17,230
Airbnb had a very similar
conclusion in a blog post

421
00:17:17,230 --> 00:17:18,640
earlier this year.

422
00:17:18,640 --> 00:17:20,254
And they said under
their old design,

423
00:17:20,254 --> 00:17:21,629
the external
JavaScript files had

424
00:17:21,629 --> 00:17:23,087
to download,
evaluate, and execute.

425
00:17:23,087 --> 00:17:27,619

426
00:17:27,619 --> 00:17:28,994
Only then would
the app discover,

427
00:17:28,994 --> 00:17:31,160
oh, the user's intent was
to do x, who would call up

428
00:17:31,160 --> 00:17:33,220
the API, which was an
additional network request,

429
00:17:33,220 --> 00:17:36,182
that became part of that
critical rendering path.

430
00:17:36,182 --> 00:17:37,640
Here we are in a
mobile connection,

431
00:17:37,640 --> 00:17:40,560
which has really high latency.

432
00:17:40,560 --> 00:17:42,789
Which led to, for them, a
time to content &mdash; the time

433
00:17:42,789 --> 00:17:45,080
until the user could get the
content that they wanted &mdash;

434
00:17:45,080 --> 00:17:48,591
of upwards of 10
seconds, in bad cases.

435
00:17:48,591 --> 00:17:50,590
So then they switched to
server-side rendering &mdash;

436
00:17:50,590 --> 00:17:53,090
which, by the way, they open
sourced the infrastructure they

437
00:17:53,090 --> 00:17:56,150
used for this, so it's worth
a look at this blog post.

438
00:17:56,150 --> 00:18:00,280
When they moved to serving the
initial view as HTML generated

439
00:18:00,280 --> 00:18:02,722
on the server, it felt
five times faster.

440
00:18:02,722 --> 00:18:03,930
So similar conclusion, right?

441
00:18:03,930 --> 00:18:05,440
Twitter &mdash; 1/5.

442
00:18:05,440 --> 00:18:09,270
Here, Airbnb &mdash;
five times faster.

443
00:18:09,270 --> 00:18:11,270
So in my opinion, if you
want to deliver a truly

444
00:18:11,270 --> 00:18:13,145
instant experience &mdash;
and there's a trade off.

445
00:18:13,145 --> 00:18:16,194

446
00:18:16,194 --> 00:18:18,360
So if you want to deliver
that experience on mobile,

447
00:18:18,360 --> 00:18:19,650
you really need
to be server-side

448
00:18:19,650 --> 00:18:20,816
rendering that initial view.

449
00:18:20,816 --> 00:18:23,307
Loading JavaScript to create
the initial presentation

450
00:18:23,307 --> 00:18:24,890
is just going to be
too slow on mobile

451
00:18:24,890 --> 00:18:26,930
for it to be an
instant experience.

452
00:18:26,930 --> 00:18:32,710
And we saw Twitter and Airbnb
both had really dramatic speed

453
00:18:32,710 --> 00:18:37,462
reductions as a result of
adopting this technique.

454
00:18:37,462 --> 00:18:39,670
So I would say, when choosing
a JavaScript framework,

455
00:18:39,670 --> 00:18:41,430
you want to look for a
framework ideally that

456
00:18:41,430 --> 00:18:42,721
supports server-side rendering.

457
00:18:42,721 --> 00:18:45,905

458
00:18:45,905 --> 00:18:47,780
Airbnb talked about the
one they open source.

459
00:18:47,780 --> 00:18:48,960
Not all the JavaScript
frameworks out

460
00:18:48,960 --> 00:18:51,376
there today do support this,
but if you're using one today

461
00:18:51,376 --> 00:18:53,965
that you do like that doesn't
support server-side rendering,

462
00:18:53,965 --> 00:18:55,590
you should push on
the development team

463
00:18:55,590 --> 00:18:57,990
or pitch in and
help out to make it

464
00:18:57,990 --> 00:19:00,680
easy to do that as part
of using that framework.

465
00:19:00,680 --> 00:19:04,190
So you can take advantage
of this automatically.

466
00:19:04,190 --> 00:19:08,910
So the third area I
want to talk about

467
00:19:08,910 --> 00:19:10,890
is minimizing
render-blocking CSS.

468
00:19:10,890 --> 00:19:15,310
And I think this is the topic
we get the most questions on.

469
00:19:15,310 --> 00:19:18,015
So I'm going to go through a
couple common questions here.

470
00:19:18,015 --> 00:19:20,390
The first of which, people
say, well what do you mean CSS

471
00:19:20,390 --> 00:19:21,009
is blocking?

472
00:19:21,009 --> 00:19:23,300
Why is this part of this
blocking critical render path?

473
00:19:23,300 --> 00:19:27,050
JavaScript blocks, yes, but
what do you mean CSS blocks?

474
00:19:27,050 --> 00:19:31,030
And it's correct that JavaScript
blocks DOM tree construction.

475
00:19:31,030 --> 00:19:33,380
JavaScript blocks the parser.

476
00:19:33,380 --> 00:19:36,640
But style sheets block
render tree construction.

477
00:19:36,640 --> 00:19:39,320
So ultimately, in order
to lay out in paint,

478
00:19:39,320 --> 00:19:41,590
we need the style sheet
to have finished loading.

479
00:19:41,590 --> 00:19:43,850
And what your users
care about is content

480
00:19:43,850 --> 00:19:44,850
painted to the screen.

481
00:19:44,850 --> 00:19:47,880
So for them, JavaScript
is &mdash; I'm sorry,

482
00:19:47,880 --> 00:19:49,340
style sheets are
render-blocking.

483
00:19:49,340 --> 00:19:51,816
So it's important to
keep this in mind.

484
00:19:51,816 --> 00:19:53,940
If you load a large style
sheet in the head, that's

485
00:19:53,940 --> 00:19:58,760
going to delay the time it takes
to paint content to the screen.

486
00:19:58,760 --> 00:20:04,510
So CSS is render-blocking.

487
00:20:04,510 --> 00:20:05,830
So what's critical CSS?

488
00:20:05,830 --> 00:20:06,669
What is this?

489
00:20:06,669 --> 00:20:08,460
We talk about this
concept of critical CSS.

490
00:20:08,460 --> 00:20:10,168
You may have heard,
it sort of goes along

491
00:20:10,168 --> 00:20:12,160
with the critical
rendering path.

492
00:20:12,160 --> 00:20:15,110
And how do I identify
my critical CSS?

493
00:20:15,110 --> 00:20:19,040
So critical CSS you can
think of as the minimal CSS

494
00:20:19,040 --> 00:20:21,550
you need to actually
position and style content

495
00:20:21,550 --> 00:20:23,620
in the initial view of your app.

496
00:20:23,620 --> 00:20:25,420
So everything you
need to present

497
00:20:25,420 --> 00:20:29,050
that flash of unstyled style
content for the content

498
00:20:29,050 --> 00:20:30,940
that you display
initially to the user.

499
00:20:30,940 --> 00:20:33,430
And the idea here
is that because we

500
00:20:33,430 --> 00:20:35,620
know CSS is
render-blocking, we want

501
00:20:35,620 --> 00:20:38,730
to minimize the amount of CSS
that we serve up to the user,

502
00:20:38,730 --> 00:20:41,180
in order to minimize the
size of the critical path

503
00:20:41,180 --> 00:20:44,184
and get the content to display
as quickly as possible.

504
00:20:44,184 --> 00:20:46,350
So identifying critical
CSS &mdash; we'll talk about this.

505
00:20:46,350 --> 00:20:48,867

506
00:20:48,867 --> 00:20:51,200
People often ask the question,
well I have all this CSS.

507
00:20:51,200 --> 00:20:52,270
I need all of it.

508
00:20:52,270 --> 00:20:54,210
What do you mean critical?

509
00:20:54,210 --> 00:20:56,770
How do I know what's
critical and what's not?

510
00:20:56,770 --> 00:20:59,870
So again, critical CSS is that
needed to position and style

511
00:20:59,870 --> 00:21:01,920
content in the initial view.

512
00:21:01,920 --> 00:21:04,990
So imagine we have
this alert CSS rule,

513
00:21:04,990 --> 00:21:07,740
and then we've got this markup
served up in the initial HTML.

514
00:21:07,740 --> 00:21:10,340
So it's going to be
visible in the initial view

515
00:21:10,340 --> 00:21:13,030
that references that rule.

516
00:21:13,030 --> 00:21:16,810
We expect it to look like
this on the page initially.

517
00:21:16,810 --> 00:21:19,290
We expect it to have
their proper stylings.

518
00:21:19,290 --> 00:21:21,870
A good way to ask yourself,
is this critical CSS or not,

519
00:21:21,870 --> 00:21:24,420
is to ask well, if I took
this rule out of the payload,

520
00:21:24,420 --> 00:21:27,050
would my initial view with the
content I serve to the user

521
00:21:27,050 --> 00:21:29,540
initially look correctly?

522
00:21:29,540 --> 00:21:32,910
And in this case obviously,
if we took that rule out,

523
00:21:32,910 --> 00:21:34,480
it would get the
default stylings

524
00:21:34,480 --> 00:21:35,800
and look totally wrong.

525
00:21:35,800 --> 00:21:40,990
So clearly, we need this
CSS to style content

526
00:21:40,990 --> 00:21:44,370
in the initial view, and
thus it is critical CSS.

527
00:21:44,370 --> 00:21:45,770
And we want to
serve it up early,

528
00:21:45,770 --> 00:21:47,080
and in a render-blocking way.

529
00:21:47,080 --> 00:21:50,440

530
00:21:50,440 --> 00:21:53,030
So imagine we changed
our HTML markup there.

531
00:21:53,030 --> 00:21:56,330
So you can see before it
was .

532
00:21:56,330 --> 00:21:57,859
Now we decide, OK,
we don't really

533
00:21:57,859 --> 00:21:59,400
want to mark hello
world as an alert.

534
00:21:59,400 --> 00:22:01,910
It's just a normal
snippet of text.

535
00:22:01,910 --> 00:22:05,207
We want it to be styled as such.

536
00:22:05,207 --> 00:22:07,540
So imagine, though, that we
do use the alert class later

537
00:22:07,540 --> 00:22:08,040
in the app.

538
00:22:08,040 --> 00:22:12,110
Like imagine your user is
interacting with the app.

539
00:22:12,110 --> 00:22:13,440
They try to upload a video.

540
00:22:13,440 --> 00:22:14,080
It fails.

541
00:22:14,080 --> 00:22:15,705
You want to show an
alert at that time.

542
00:22:15,705 --> 00:22:17,990
So we do need it, but
we don't need this rule

543
00:22:17,990 --> 00:22:19,840
as part of the initial view.

544
00:22:19,840 --> 00:22:22,770
At that point, it's not
part of the initial view,

545
00:22:22,770 --> 00:22:24,870
and so it's no longer
critical and you

546
00:22:24,870 --> 00:22:27,960
may want to think about loading
that later in the app life

547
00:22:27,960 --> 00:22:32,794
cycle, in a way that doesn't
block the initial view.

548
00:22:32,794 --> 00:22:33,460
So one more bit.

549
00:22:33,460 --> 00:22:34,450
I think this is
actually, probably &mdash;

550
00:22:34,450 --> 00:22:36,783
this is somewhat subtle, but
probably the most important

551
00:22:36,783 --> 00:22:40,044
thing we talk
about critical CSS.

552
00:22:40,044 --> 00:22:42,710
The critical CSS is that the CSS
is needed to position and style

553
00:22:42,710 --> 00:22:44,850
the content in the initial view.

554
00:22:44,850 --> 00:22:49,360
So oftentimes, we inline
data URIs into our CSS,

555
00:22:49,360 --> 00:22:51,850
the goal being OK, let's
reduce the number of requests

556
00:22:51,850 --> 00:22:52,670
that my page makes.

557
00:22:52,670 --> 00:22:54,690
I can serve up the
image separately,

558
00:22:54,690 --> 00:22:57,360
or I can inline
right into my CSS.

559
00:22:57,360 --> 00:23:02,400
And interestingly, what we are
doing when we inline these data

560
00:23:02,400 --> 00:23:04,260
URIs for images,
is we're basically

561
00:23:04,260 --> 00:23:07,290
promoting the image from
being non-render-blocking,

562
00:23:07,290 --> 00:23:09,880
not part of the critical
render path, because images

563
00:23:09,880 --> 00:23:12,480
by default &mdash; they obviously
need to download the image

564
00:23:12,480 --> 00:23:15,640
to render the image itself &mdash;
but images don't block rendering

565
00:23:15,640 --> 00:23:17,880
of other content on the screen.

566
00:23:17,880 --> 00:23:19,900
When we inline it
as a data URI here,

567
00:23:19,900 --> 00:23:22,180
we basically promoted it
to being render-blocking,

568
00:23:22,180 --> 00:23:24,440
to being part of the
critical rendering path,

569
00:23:24,440 --> 00:23:26,731
and we're making that critical
rendering path that much

570
00:23:26,731 --> 00:23:27,290
longer.

571
00:23:27,290 --> 00:23:31,950
And so data URIs too, they
tend to be quite big, right?

572
00:23:31,950 --> 00:23:32,825
So here's our markup.

573
00:23:32,825 --> 00:23:35,400

574
00:23:35,400 --> 00:23:37,140
So if you look at
your CSS, and you're

575
00:23:37,140 --> 00:23:38,520
using this technique
lots of sites do,

576
00:23:38,520 --> 00:23:39,978
you'll notice
probably the majority

577
00:23:39,978 --> 00:23:41,750
of bites in your CSS
files may actually

578
00:23:41,750 --> 00:23:43,167
be from these inline data URIs.

579
00:23:43,167 --> 00:23:45,750
And what you're doing is, you're
increasing that critical path

580
00:23:45,750 --> 00:23:48,860
length pretty significantly,
and actually causing users

581
00:23:48,860 --> 00:23:50,640
to have to wait to
see any content at all

582
00:23:50,640 --> 00:23:52,650
on the screen as a result.

583
00:23:52,650 --> 00:23:57,070
So you'll actually render the
other content on the screen

584
00:23:57,070 --> 00:24:00,516
more quickly if you just
switch back to that CSS sprite

585
00:24:00,516 --> 00:24:01,890
with the external
file reference,

586
00:24:01,890 --> 00:24:04,560
or, if you're using something
like [INAUDIBLE] where spriting

587
00:24:04,560 --> 00:24:06,540
doesn't really bring
you any benefit,

588
00:24:06,540 --> 00:24:09,710
just keeping each
image asset separate,

589
00:24:09,710 --> 00:24:11,880
reducing the size
of the CSS, reducing

590
00:24:11,880 --> 00:24:13,630
the size of your
critical rendering path,

591
00:24:13,630 --> 00:24:17,987
and making the page load
that much more quickly.

592
00:24:17,987 --> 00:24:19,320
This is pretty easy to test out.

593
00:24:19,320 --> 00:24:20,950
Create a simple page.

594
00:24:20,950 --> 00:24:23,300
Inline a bunch of data
URIs and a style sheet.

595
00:24:23,300 --> 00:24:25,952
Create a second
version that page.

596
00:24:25,952 --> 00:24:27,410
Use the technique
here where you've

597
00:24:27,410 --> 00:24:28,900
got a separate image asset.

598
00:24:28,900 --> 00:24:31,260
Make sure there's some
non-image content on the page,

599
00:24:31,260 --> 00:24:33,510
so put some text in
there, whatever it may be.

600
00:24:33,510 --> 00:24:35,260
And then compare the
two in web page test.

601
00:24:35,260 --> 00:24:36,980
Do a video comparison
on a 3G network.

602
00:24:36,980 --> 00:24:39,057
And you'll see that when
you inline data URIs

603
00:24:39,057 --> 00:24:40,640
into your style
sheet, you're blocking

604
00:24:40,640 --> 00:24:42,348
rendering of all the
content on the page.

605
00:24:42,348 --> 00:24:46,390
You're blocking the
text, whatever it may be.

606
00:24:46,390 --> 00:24:49,950
So on mobile, again where
downloading additional content

607
00:24:49,950 --> 00:24:53,000
in the critical rendering
path is expensive,

608
00:24:53,000 --> 00:24:55,910
I encourage people to
not take that approach &mdash;

609
00:24:55,910 --> 00:24:58,620
except for maybe
very small data URIs.

610
00:24:58,620 --> 00:25:02,577
I would say that large data URIs
inlined in render-blocking CSS

611
00:25:02,577 --> 00:25:04,410
are actually harmful
for render performance,

612
00:25:04,410 --> 00:25:11,617
and I would avoid
using that approach.

613
00:25:11,617 --> 00:25:12,950
So then a couple more questions.

614
00:25:12,950 --> 00:25:15,270
OK, so I've identified
my critical CSS.

615
00:25:15,270 --> 00:25:16,520
I've removed my data URIS.

616
00:25:16,520 --> 00:25:17,840
I made it nice and small.

617
00:25:17,840 --> 00:25:20,320
How should I load
that critical CSS?

618
00:25:20,320 --> 00:25:22,740
So there's two ways
to go about this.

619
00:25:22,740 --> 00:25:24,340
In PageSpeed
Insights we actually

620
00:25:24,340 --> 00:25:28,000
in line the critical CSS
as a style block in line,

621
00:25:28,000 --> 00:25:30,450
keeping that critical rendering
path as short as we can.

622
00:25:30,450 --> 00:25:32,120
We don't want to
go back to network

623
00:25:32,120 --> 00:25:34,760
to download an external
style sheet, in our case,

624
00:25:34,760 --> 00:25:37,180
because that incurs additional
network round trips, which

625
00:25:37,180 --> 00:25:40,190
can add anywhere from 500
millis to maybe a second,

626
00:25:40,190 --> 00:25:42,477
depending on how
it's loaded, of time

627
00:25:42,477 --> 00:25:44,060
the user is staring
at a blank screen.

628
00:25:44,060 --> 00:25:47,300
So for us, we felt like the
best approach was to inline.

629
00:25:47,300 --> 00:25:50,390
The CSS needed to style
the initial view directly

630
00:25:50,390 --> 00:25:52,780
in our HTML payload.

631
00:25:52,780 --> 00:25:55,010
But I wouldn't say that's
necessarily a requirement.

632
00:25:55,010 --> 00:25:56,950
I think it's still
perfectly reasonable

633
00:25:56,950 --> 00:26:00,370
to load that critical
CSS resource, as long

634
00:26:00,370 --> 00:26:03,190
as the critical resource
is small, in the head,

635
00:26:03,190 --> 00:26:04,310
as an external resource.

636
00:26:04,310 --> 00:26:05,789
The page will be
slower for people

637
00:26:05,789 --> 00:26:07,330
who don't have the
resource in cache,

638
00:26:07,330 --> 00:26:08,913
because now they
have to go to network

639
00:26:08,913 --> 00:26:12,280
to download that
additional resource.

640
00:26:12,280 --> 00:26:13,810
But you've got some
other benefits.

641
00:26:13,810 --> 00:26:16,169
You're reducing bytes sent
on the wire for repeat views,

642
00:26:16,169 --> 00:26:17,960
because once it's in
cache the user doesn't

643
00:26:17,960 --> 00:26:19,650
have to download it again.

644
00:26:19,650 --> 00:26:22,980
You may introduce a faster
full cache experience

645
00:26:22,980 --> 00:26:23,680
for repeat view.

646
00:26:23,680 --> 00:26:24,460
It really depends.

647
00:26:24,460 --> 00:26:25,580
It's not guaranteed
by any means.

648
00:26:25,580 --> 00:26:27,246
It's sort of a little
counter intuitive.

649
00:26:27,246 --> 00:26:29,810
You would think, well the
HTML payload is smaller,

650
00:26:29,810 --> 00:26:31,860
so the page should load faster.

651
00:26:31,860 --> 00:26:35,164
But it actually depends, it's
not necessarily the case.

652
00:26:35,164 --> 00:26:37,580
But in any case, either of
these approaches is reasonable.

653
00:26:37,580 --> 00:26:38,480
And it really just depends.

654
00:26:38,480 --> 00:26:39,563
You're making a trade off.

655
00:26:39,563 --> 00:26:42,050
Do I want the
fastest performance?

656
00:26:42,050 --> 00:26:43,552
In which case, you
want to inline.

657
00:26:43,552 --> 00:26:45,010
Or do I want a
little bit, perhaps,

658
00:26:45,010 --> 00:26:47,020
more maintainable approach?

659
00:26:47,020 --> 00:26:49,940
In which case you
could keep it external,

660
00:26:49,940 --> 00:26:54,510
and pay a little bit of a
performance penalty for that.

661
00:26:54,510 --> 00:26:58,600
So things get kind of fuzzier
the further along we go here.

662
00:26:58,600 --> 00:27:02,050
So the last bit, once we've
loaded our critical CSS &mdash; now

663
00:27:02,050 --> 00:27:04,470
we've got this other CSS
needed to style other parts

664
00:27:04,470 --> 00:27:06,720
of our app &mdash; how do we
load that in a way that

665
00:27:06,720 --> 00:27:09,370
doesn't block
rendering of the page?

666
00:27:09,370 --> 00:27:15,331
Unfortunately, today there's not
a great simple, straightforward

667
00:27:15,331 --> 00:27:15,830
technique.

668
00:27:15,830 --> 00:27:17,496
Like we have with
script, we have async.

669
00:27:17,496 --> 00:27:20,444
It's a really easy, first
class feature of the platform.

670
00:27:20,444 --> 00:27:22,110
The same does not
exist for style sheet.

671
00:27:22,110 --> 00:27:24,880
Any style sheet found in
the document by the parser

672
00:27:24,880 --> 00:27:28,584
will cause the rendering
engine to say, OK,

673
00:27:28,584 --> 00:27:30,250
I'm going to wait and
not paint anything

674
00:27:30,250 --> 00:27:32,650
until I finished fully
downloading this style sheet.

675
00:27:32,650 --> 00:27:35,600
So you can't just throw link
rel stylesheet href equals

676
00:27:35,600 --> 00:27:38,087
noncritical CSS in the
footer of your HTML.

677
00:27:38,087 --> 00:27:39,170
The parser will find that.

678
00:27:39,170 --> 00:27:41,200
And as soon as it does,
if it hasn't painted

679
00:27:41,200 --> 00:27:42,908
the content above yet,
it will say, whoa,

680
00:27:42,908 --> 00:27:46,337
I'm not going to paint anything,
even the markup above that,

681
00:27:46,337 --> 00:27:47,670
until that finishes downloading.

682
00:27:47,670 --> 00:27:51,020
So you have to be careful here.

683
00:27:51,020 --> 00:27:52,870
So what we want is this
lazy load attribute.

684
00:27:52,870 --> 00:27:54,320
And that's coming soon.

685
00:27:54,320 --> 00:27:56,030
Some Chrome engineers,
IE engineers

686
00:27:56,030 --> 00:27:57,680
are working together on a spec.

687
00:27:57,680 --> 00:28:00,730
And what that says basically &mdash;
it's similar to async &mdash;

688
00:28:00,730 --> 00:28:02,812
and it basically says,
I need this resource.

689
00:28:02,812 --> 00:28:04,020
It shouldn't block rendering.

690
00:28:04,020 --> 00:28:05,430
It shouldn't block onload.

691
00:28:05,430 --> 00:28:08,000
Load it, and when it's
available, I'll make use of it.

692
00:28:08,000 --> 00:28:09,750
In the meantime, we
don't have that today.

693
00:28:09,750 --> 00:28:10,250
It's coming.

694
00:28:10,250 --> 00:28:11,670
It's being speced.

695
00:28:11,670 --> 00:28:13,730
There are a couple ways
you can work around this.

696
00:28:13,730 --> 00:28:17,220

697
00:28:17,220 --> 00:28:19,420
It's listed here.
requestAnimationFrame,

698
00:28:19,420 --> 00:28:21,050
so you wait for the first paint.

699
00:28:21,050 --> 00:28:23,892
You could load the
resource and hidden iframe.

700
00:28:23,892 --> 00:28:25,600
You could actually
load it as JavaScript.

701
00:28:25,600 --> 00:28:26,720
I've seen people do this.

702
00:28:26,720 --> 00:28:29,470
JavaScript has async, so you
could load a CSS resource

703
00:28:29,470 --> 00:28:30,480
to JavaScript.

704
00:28:30,480 --> 00:28:35,240
As I say each of these, part
of me is feeling not great.

705
00:28:35,240 --> 00:28:39,060
This is really not
the kind of APIs

706
00:28:39,060 --> 00:28:41,170
we want for this kind of thing.

707
00:28:41,170 --> 00:28:44,050
But fortunately, the lazy
load attribute is coming,

708
00:28:44,050 --> 00:28:47,230
and that will be the right thing
to use once that's shipped.

709
00:28:47,230 --> 00:28:50,750

710
00:28:50,750 --> 00:28:52,615
So some high level
recommendations

711
00:28:52,615 --> 00:28:55,600
for render-blocking CSS.

712
00:28:55,600 --> 00:28:57,270
How are we doing on time?

713
00:28:57,270 --> 00:28:59,670
A couple minutes.

714
00:28:59,670 --> 00:29:02,309
Avoid inlining data URIs.

715
00:29:02,309 --> 00:29:03,100
Keep them external.

716
00:29:03,100 --> 00:29:06,330
Keep the CSS as
small as possible.

717
00:29:06,330 --> 00:29:08,707
Critical CSS, what that
is, keeping that in mind,

718
00:29:08,707 --> 00:29:11,040
and making sure you're focusing
on only delivering that.

719
00:29:11,040 --> 00:29:12,926
But all this said &mdash;
and if you're

720
00:29:12,926 --> 00:29:14,550
hearing me talk about
this critical CSS

721
00:29:14,550 --> 00:29:16,550
and oh, I have to load
some early and some late,

722
00:29:16,550 --> 00:29:19,240
and that sounds like
a lot of overhead &mdash;

723
00:29:19,240 --> 00:29:22,190
the good news is if your
total CSS is reasonably small,

724
00:29:22,190 --> 00:29:24,270
like if it's under
say 15k compressed,

725
00:29:24,270 --> 00:29:26,730
which might mean
45km compressed,

726
00:29:26,730 --> 00:29:28,859
it's probably small
enough that you can just

727
00:29:28,859 --> 00:29:29,900
treat it all as critical.

728
00:29:29,900 --> 00:29:32,100
Just don't worry about
partitioning out.

729
00:29:32,100 --> 00:29:33,989
It's only when it
becomes really big

730
00:29:33,989 --> 00:29:35,530
that you don't want
to load all of it

731
00:29:35,530 --> 00:29:38,970
in a way that blocks rendering
anything at all to the screen.

732
00:29:38,970 --> 00:29:44,122
So the common case, I hope, is
that your CSS is already small,

733
00:29:44,122 --> 00:29:45,830
and you just load that
up front and don't

734
00:29:45,830 --> 00:29:48,669
worry about this concept
of noncritical CSS.

735
00:29:48,669 --> 00:29:50,210
If you do have a
lot of CSS, you want

736
00:29:50,210 --> 00:29:51,960
to load that in a
render-blocking manner &mdash;

737
00:29:51,960 --> 00:29:53,860
we talked about the two
techniques for that &mdash;

738
00:29:53,860 --> 00:29:56,318
and then load the remaining
CSS in that non-blocking manner

739
00:29:56,318 --> 00:29:59,290
using, for the time being, one
of those requestAnimationFrame

740
00:29:59,290 --> 00:30:01,880
or whatever it may be
techniques, longer term using

741
00:30:01,880 --> 00:30:04,690
that lazy load attribute.

742
00:30:04,690 --> 00:30:08,080
So just to summarize really high
level, the things that we found

743
00:30:08,080 --> 00:30:09,380
were really important.

744
00:30:09,380 --> 00:30:12,060
Eliminate render-block
in JavaScript.

745
00:30:12,060 --> 00:30:13,500
Load JavaScript asynchronously.

746
00:30:13,500 --> 00:30:15,690
Get it out of the
critical rendering path.

747
00:30:15,690 --> 00:30:19,230
So design your apps
with that in mind.

748
00:30:19,230 --> 00:30:21,440
Don't depend JavaScript
having to load synchronously

749
00:30:21,440 --> 00:30:22,970
in order to render your page.

750
00:30:22,970 --> 00:30:25,560
And along those lines,
render the initial view

751
00:30:25,560 --> 00:30:27,440
to HTML on the server.

752
00:30:27,440 --> 00:30:29,840
So don't use JavaScript
client-side to render

753
00:30:29,840 --> 00:30:31,070
the initial view.

754
00:30:31,070 --> 00:30:32,460
It's an inherently slow process.

755
00:30:32,460 --> 00:30:35,670
We saw Twitter had performance
problems with this, Airbnb,

756
00:30:35,670 --> 00:30:37,480
my team had the same issues.

757
00:30:37,480 --> 00:30:40,480
And then finally,
serve up as little CSS

758
00:30:40,480 --> 00:30:42,580
as you need to render
the initial view.

759
00:30:42,580 --> 00:30:46,890
Be mindful of just how
much you're serving.

760
00:30:46,890 --> 00:30:48,500
And largely, you
can accomplish that

761
00:30:48,500 --> 00:30:50,910
by just not inlining large
data URIs in your CSS.

762
00:30:50,910 --> 00:30:52,810
I think if we stop
doing that, I think

763
00:30:52,810 --> 00:30:55,600
our CSS size, for the most
part, will become manageable,

764
00:30:55,600 --> 00:30:59,260
and will be reasonable to
load in a render-blocking way.

765
00:30:59,260 --> 00:31:02,190
So that's everything.

766
00:31:02,190 --> 00:31:11,736

