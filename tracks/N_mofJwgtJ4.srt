1
00:00:00,000 --> 00:00:03,540
IAN BARBER: If any of you worry
there's no space at the

2
00:00:03,540 --> 00:00:04,710
front, there's plenty.

3
00:00:04,710 --> 00:00:06,980
Feel free to move.

4
00:00:06,980 --> 00:00:07,920
So my name's Ian.

5
00:00:07,920 --> 00:00:10,282
I'm a developer advocate
with Google+.

6
00:00:10,282 --> 00:00:14,010
And I'm going to talk today
a little bit about using

7
00:00:14,010 --> 00:00:16,950
authentication systems for
multiple providers in your

8
00:00:16,950 --> 00:00:21,610
code without having it turn into
a giant ball of hay that

9
00:00:21,610 --> 00:00:24,480
you don't want to deal with.

10
00:00:24,480 --> 00:00:29,310
Hopefully over the last day and
a half, you've seen some

11
00:00:29,310 --> 00:00:32,360
things about sign-in in general,
maybe Tim Bray's

12
00:00:32,360 --> 00:00:35,150
identity talk yesterday.

13
00:00:35,150 --> 00:00:38,630
And you'll know that sign-in
is difficult.

14
00:00:38,630 --> 00:00:42,800
It's very easy to make a fragile
implementation of

15
00:00:42,800 --> 00:00:47,440
identity, of passwords, of
dealing with account recovery,

16
00:00:47,440 --> 00:00:48,860
things like two-factor auth.

17
00:00:48,860 --> 00:00:50,430
It's complicated.

18
00:00:50,430 --> 00:00:52,420
And it's nice that you
can defer that.

19
00:00:52,420 --> 00:00:55,190
You can hand that off to some
other party who's got the

20
00:00:55,190 --> 00:00:58,220
engineering, who's got the
privacy and the security teams

21
00:00:58,220 --> 00:00:59,360
to look after it.

22
00:00:59,360 --> 00:01:02,190
So I think social

23
00:01:02,190 --> 00:01:03,330
authentication is a good thing.

24
00:01:03,330 --> 00:01:06,300
I think third party identity
providers are a good thing.

25
00:01:06,300 --> 00:01:08,450
But it doesn't necessarily
follow that it's a good thing

26
00:01:08,450 --> 00:01:12,030
to have multiple providers
on, right?

27
00:01:12,030 --> 00:01:13,640
You can easily get into a
situation where you have

28
00:01:13,640 --> 00:01:16,035
hundreds of buttons, and no
one wants to deal with it.

29
00:01:16,035 --> 00:01:19,710
But I think it is worth
considering adding more than

30
00:01:19,710 --> 00:01:23,120
one identity provider
to your application.

31
00:01:23,120 --> 00:01:25,660
I think there's a reason that
it's good for you, and there's

32
00:01:25,660 --> 00:01:27,000
a reason that it's good
for the users.

33
00:01:27,000 --> 00:01:29,590
For the users, it gives
them choice.

34
00:01:29,590 --> 00:01:31,240
And that choice is valuable.

35
00:01:31,240 --> 00:01:35,390
That choice allows them to
choose the one they're most

36
00:01:35,390 --> 00:01:38,120
familiar with, choose the
one that works for them.

37
00:01:38,120 --> 00:01:41,270
But it also allows them to
express a facet of their

38
00:01:41,270 --> 00:01:42,590
personality.

39
00:01:42,590 --> 00:01:44,870
We don't all use the internet
in the same way.

40
00:01:44,870 --> 00:01:47,720
And we don't all use every
service in the same way.

41
00:01:47,720 --> 00:01:50,320
I have certain friends on
certain sites and certain

42
00:01:50,320 --> 00:01:53,350
networks, and certain interests
that I post there.

43
00:01:53,350 --> 00:01:57,190
If I can sign into your app
with the network that most

44
00:01:57,190 --> 00:02:00,510
closely aligns to my interest,
I can express myself more

45
00:02:00,510 --> 00:02:02,070
accurately.

46
00:02:02,070 --> 00:02:06,990
As a developer, the big gain is
that these days, identity

47
00:02:06,990 --> 00:02:08,370
providers don't just
provide identity.

48
00:02:08,370 --> 00:02:09,520
They provide services.

49
00:02:09,520 --> 00:02:12,940
And you get access to those
APIs for users as well.

50
00:02:12,940 --> 00:02:18,030
So it's valuable even if you
have a user who is connected

51
00:02:18,030 --> 00:02:21,970
to connect an extra network to
have ways of getting into

52
00:02:21,970 --> 00:02:25,050
additional systems so that you
can enhance your application,

53
00:02:25,050 --> 00:02:27,270
so that you can add more
services, so that you can do

54
00:02:27,270 --> 00:02:30,120
things which are a bit
more interesting.

55
00:02:30,120 --> 00:02:31,660
Now adding an identity
provider isn't

56
00:02:31,660 --> 00:02:33,070
actually that hard.

57
00:02:33,070 --> 00:02:36,640
And if you just went out and
tried to implement Google+

58
00:02:36,640 --> 00:02:41,580
Sign-In or Facebook or Twitter
or LinkedIn or whoever, you'd

59
00:02:41,580 --> 00:02:43,260
get it done in a reasonably
short time.

60
00:02:43,260 --> 00:02:46,770
It's somewhere between
days and a few weeks.

61
00:02:46,770 --> 00:02:52,825
But it's very, very easy to
spread knowledge of how a user

62
00:02:52,825 --> 00:02:55,710
is created throughout your
system and end up in a case

63
00:02:55,710 --> 00:02:58,440
where changing it then
becomes tricky.

64
00:02:58,440 --> 00:03:01,660
When there's an API change, when
there is a newer version

65
00:03:01,660 --> 00:03:04,420
of something, it becomes
complicated to do so.

66
00:03:04,420 --> 00:03:07,740
It becomes complicated
to think about it.

67
00:03:07,740 --> 00:03:10,650
So what I think we need to think
about when we're talking

68
00:03:10,650 --> 00:03:15,030
about multiple providers is
roughly these four things.

69
00:03:15,030 --> 00:03:18,220
We have to think about how the
user is authorized and

70
00:03:18,220 --> 00:03:19,490
authenticated.

71
00:03:19,490 --> 00:03:22,530
We have to think about what are
the capabilities of the

72
00:03:22,530 --> 00:03:24,440
various systems we're
integrating with.

73
00:03:24,440 --> 00:03:27,430
What's shared, and what's
different, what's special.

74
00:03:27,430 --> 00:03:29,960
We have to think about the
data model on our side.

75
00:03:29,960 --> 00:03:33,110
And we have to think about the
story for the user side.

76
00:03:33,110 --> 00:03:35,920
I'm not saying the user
interface or the user

77
00:03:35,920 --> 00:03:36,520
experience.

78
00:03:36,520 --> 00:03:40,590
Those are things which have been
covered elsewhere and are

79
00:03:40,590 --> 00:03:42,090
well worth spending time on.

80
00:03:42,090 --> 00:03:44,540
But I mean, why does
the user sign in?

81
00:03:44,540 --> 00:03:46,990
What is the mechanism
they are using?

82
00:03:46,990 --> 00:03:48,960
Why are they going to go
and press this button?

83
00:03:48,960 --> 00:03:49,970
What do they get out of it?

84
00:03:49,970 --> 00:03:52,570
Telling that story is an
important part of it, and

85
00:03:52,570 --> 00:03:57,440
having a feel for what signing
in means in your application.

86
00:03:57,440 --> 00:04:01,110
So when I say authorization,
I mean OAuth.

87
00:04:01,110 --> 00:04:05,340
OAuth is the dominant pattern
for authorizing access to

88
00:04:05,340 --> 00:04:09,730
services online, on
the web at least.

89
00:04:09,730 --> 00:04:11,770
And OAuth is very, very
well established.

90
00:04:11,770 --> 00:04:15,220
OAuth 2.0, standardized, lots
of good implementations.

91
00:04:15,220 --> 00:04:17,610
Most providers now are working
with OAuth 2.0.

92
00:04:17,610 --> 00:04:18,769
There are some with
OAuth 1.0, though.

93
00:04:18,769 --> 00:04:20,440
Twitter, I think, is
a notable example.

94
00:04:20,440 --> 00:04:23,070
But mostly, it's moved
to OAuth 2.0.

95
00:04:23,070 --> 00:04:28,900
But OAuth is like giving the
keys to your house to a real

96
00:04:28,900 --> 00:04:31,650
estate agent to show
people around.

97
00:04:31,650 --> 00:04:33,420
Those people can come
to your house.

98
00:04:33,420 --> 00:04:34,910
They can see what's there.

99
00:04:34,910 --> 00:04:36,720
But they don't know
who you are.

100
00:04:36,720 --> 00:04:38,760
They just have access.

101
00:04:38,760 --> 00:04:41,380
So on top of OAuth,
we need to layer a

102
00:04:41,380 --> 00:04:44,220
service to give us identity.

103
00:04:44,220 --> 00:04:46,920
And in fact, there's
standardization happening in

104
00:04:46,920 --> 00:04:48,250
that area as well.

105
00:04:48,250 --> 00:04:52,410
From the OpenID group, there's
OpenID Connect, which is

106
00:04:52,410 --> 00:04:56,410
adding standardized identity
services which you can call

107
00:04:56,410 --> 00:04:58,920
with OAuth authorization.

108
00:04:58,920 --> 00:05:00,360
And we're involved in it.

109
00:05:00,360 --> 00:05:01,570
Facebook are involved in it.

110
00:05:01,570 --> 00:05:03,770
A lot of the big systems
are moving that way.

111
00:05:03,770 --> 00:05:06,030
And I think that combination
of OAuth 2.0 and OpenID

112
00:05:06,030 --> 00:05:07,970
Connect is very, very
interesting.

113
00:05:07,970 --> 00:05:09,990
There's a lot of very valuable
and powerful concepts that

114
00:05:09,990 --> 00:05:10,820
come out of it.

115
00:05:10,820 --> 00:05:13,670
And you'll see those spread
through more of the more

116
00:05:13,670 --> 00:05:17,075
recent systems and services.

117
00:05:17,075 --> 00:05:19,820
But if you you've done OAuth 2.0
before, you might think of

118
00:05:19,820 --> 00:05:21,630
a flow something like this.

119
00:05:21,630 --> 00:05:22,280
There's an app.

120
00:05:22,280 --> 00:05:24,250
It generates a URL.

121
00:05:24,250 --> 00:05:26,340
User clicks on the URL,
goes to the provider,

122
00:05:26,340 --> 00:05:28,750
authenticates, comes back.

123
00:05:28,750 --> 00:05:31,280
Sends a code to the
application.

124
00:05:31,280 --> 00:05:33,560
The application then exchanges
it with an identity provider.

125
00:05:33,560 --> 00:05:34,470
Straightforward, right?

126
00:05:34,470 --> 00:05:35,870
And this is well covered
by libraries.

127
00:05:35,870 --> 00:05:37,750
There's tons of libraries out
here who will do OAuth

128
00:05:37,750 --> 00:05:39,340
exchange for you.

129
00:05:39,340 --> 00:05:42,410
But even on the web, it's
not that simple.

130
00:05:42,410 --> 00:05:44,590
If you look at more modern
implementations, like Google+

131
00:05:44,590 --> 00:05:47,220
Sign-In, like Facebook's
client-side sign-in, you'll

132
00:05:47,220 --> 00:05:49,570
see they don't actually
redirect the user.

133
00:05:49,570 --> 00:05:51,840
They spin up an iframe.

134
00:05:51,840 --> 00:05:55,230
And in the iframe, the user
communicates directly with the

135
00:05:55,230 --> 00:05:56,930
identity provider.

136
00:05:56,930 --> 00:06:00,530
And then they communicate with
that iframe via the HTML5 post

137
00:06:00,530 --> 00:06:01,670
message API.

138
00:06:01,670 --> 00:06:02,450
That's really cool.

139
00:06:02,450 --> 00:06:03,330
It's faster.

140
00:06:03,330 --> 00:06:06,080
You get bi-directional
origin verification.

141
00:06:06,080 --> 00:06:09,640
You get an ability to do things
like seamlessly sign

142
00:06:09,640 --> 00:06:11,405
the user in when they
visit a site.

143
00:06:11,405 --> 00:06:12,530
You like those things.

144
00:06:12,530 --> 00:06:14,750
But it means this flow
isn't quite right.

145
00:06:14,750 --> 00:06:16,460
On mobile, it's even worse.

146
00:06:16,460 --> 00:06:19,750
On mobile, we have the
same flow, maybe.

147
00:06:19,750 --> 00:06:22,310
But how we actually deal
with that varies.

148
00:06:22,310 --> 00:06:25,310
Perhaps we'd want to bring a
browser up in the application.

149
00:06:25,310 --> 00:06:29,600
That could be a WebView in
Android or a UIWebView in iOS.

150
00:06:29,600 --> 00:06:31,450
We'll have that flow,
and that will work.

151
00:06:31,450 --> 00:06:33,440
But that's a terrible experience
for the users.

152
00:06:33,440 --> 00:06:34,830
They definitely don't
have a cookie.

153
00:06:34,830 --> 00:06:36,230
So they're going to have
to type in their

154
00:06:36,230 --> 00:06:37,600
username and password.

155
00:06:37,600 --> 00:06:39,310
And when they do that,
they can't see where

156
00:06:39,310 --> 00:06:40,020
they're typing it into.

157
00:06:40,020 --> 00:06:41,680
They can't see the URL bar.

158
00:06:41,680 --> 00:06:43,850
They can't check the
certificate.

159
00:06:43,850 --> 00:06:47,400
So maybe it's better to send
them to the system browser.

160
00:06:47,400 --> 00:06:48,380
They may have cookies there.

161
00:06:48,380 --> 00:06:49,160
That's great.

162
00:06:49,160 --> 00:06:51,290
And they can check
the certificate.

163
00:06:51,290 --> 00:06:52,980
They can see where they are.

164
00:06:52,980 --> 00:06:54,320
And that helps.

165
00:06:54,320 --> 00:06:55,020
It's a better experience.

166
00:06:55,020 --> 00:06:57,720
But the user can still kind
of decide to go and

167
00:06:57,720 --> 00:06:59,530
do something else.

168
00:06:59,530 --> 00:07:02,700
So in a lot of cases, it's
actually nicer to authenticate

169
00:07:02,700 --> 00:07:04,380
via another application.

170
00:07:04,380 --> 00:07:08,450
If you try and sign in on iOS
with Google+, we'll actually

171
00:07:08,450 --> 00:07:11,180
take you to the Google+
iOS app.

172
00:07:11,180 --> 00:07:12,260
And you'll sign in there.

173
00:07:12,260 --> 00:07:14,120
And that's great because when
you have a nice, fast consent

174
00:07:14,120 --> 00:07:17,110
screen, you're pretty much
guaranteed to be signed in to

175
00:07:17,110 --> 00:07:18,410
the actual application.

176
00:07:18,410 --> 00:07:20,330
And there's no other
navigation.

177
00:07:20,330 --> 00:07:22,110
You're not going to go off and
look at a bookmark bar or

178
00:07:22,110 --> 00:07:23,910
something like that.

179
00:07:23,910 --> 00:07:26,430
And of course, you could have
the actual authentication in

180
00:07:26,430 --> 00:07:28,360
the device itself.

181
00:07:28,360 --> 00:07:31,360
And that's something like the
account manager on Android or

182
00:07:31,360 --> 00:07:34,760
the Social Framework on iOS,
where the accounts live with

183
00:07:34,760 --> 00:07:36,340
the device.

184
00:07:36,340 --> 00:07:39,520
And all of these complicate
how we implement even a

185
00:07:39,520 --> 00:07:41,890
straightforward flow.

186
00:07:41,890 --> 00:07:45,950
So what we're trying to get
to is something like this.

187
00:07:45,950 --> 00:07:49,240
People don't use your
app to sign in.

188
00:07:49,240 --> 00:07:50,560
They sign in to use your app.

189
00:07:50,560 --> 00:07:52,920
They sign in to get value
out of your app.

190
00:07:52,920 --> 00:07:55,960
And that's all happening up in
the controllers, in a standard

191
00:07:55,960 --> 00:07:56,630
sort of MVC pattern.

192
00:07:56,630 --> 00:07:58,070
The controllers and the users.

193
00:07:58,070 --> 00:08:00,920
The UI, it's the UX, it's the
logic of what it's doing.

194
00:08:00,920 --> 00:08:04,360
You don't want to be thinking
in there about how your user

195
00:08:04,360 --> 00:08:07,270
came to be, about the process
of identification.

196
00:08:07,270 --> 00:08:10,960
You just want to think about
what you can do with the user.

197
00:08:10,960 --> 00:08:14,770
So what we want is for that
user to be generic--

198
00:08:14,770 --> 00:08:17,980
well, specific to your app, but
generic to the provider--

199
00:08:17,980 --> 00:08:20,000
and useful.

200
00:08:20,000 --> 00:08:23,745
Down here, though, is where the
actual user is generated.

201
00:08:23,745 --> 00:08:25,720
That happens in the identity
providers.

202
00:08:25,720 --> 00:08:28,290
You know they're going to have
to actually sign in there.

203
00:08:28,290 --> 00:08:30,400
And we don't want that leaking
all the way into the

204
00:08:30,400 --> 00:08:30,910
controller.

205
00:08:30,910 --> 00:08:33,539
So we need to put some
layer in between.

206
00:08:33,539 --> 00:08:36,409
And that's the idea that really
underpins everything

207
00:08:36,409 --> 00:08:37,090
I'm going to talk about.

208
00:08:37,090 --> 00:08:39,299
If you take one thing away,
just take that away.

209
00:08:39,299 --> 00:08:42,289
Try and separate the
provisioning of identity from

210
00:08:42,289 --> 00:08:46,860
the usage of the user that
has been identified.

211
00:08:46,860 --> 00:08:48,820
So I've got some code
examples in here.

212
00:08:48,820 --> 00:08:52,680
And don't worry if you wonder--
you know, you want to

213
00:08:52,680 --> 00:08:54,270
note some things
or take photos.

214
00:08:54,270 --> 00:08:56,430
All of the slides will
be online afterwards.

215
00:08:56,430 --> 00:08:58,670
The video for this talk
will be on YouTube.

216
00:08:58,670 --> 00:08:59,940
And there is code in here.

217
00:08:59,940 --> 00:09:02,810
I've got a bit of PHP for the
web, a bit of Java for Android

218
00:09:02,810 --> 00:09:04,540
and a bit of Objective-C
for iOS.

219
00:09:04,540 --> 00:09:06,790
But little sample apps will
all be up on GitHub

220
00:09:06,790 --> 00:09:07,220
afterwards.

221
00:09:07,220 --> 00:09:11,060
So don't feel like you have
to follow every line.

222
00:09:11,060 --> 00:09:13,430
But this is kind of what we
want to be able to do.

223
00:09:13,430 --> 00:09:15,600
We want to be able to
just get a user.

224
00:09:15,600 --> 00:09:16,360
If I got a user?

225
00:09:16,360 --> 00:09:17,540
No.

226
00:09:17,540 --> 00:09:18,960
If I don't, redirect them.

227
00:09:18,960 --> 00:09:20,460
If I do, use them.

228
00:09:20,460 --> 00:09:21,250
I just get the name.

229
00:09:21,250 --> 00:09:22,180
I activate it.

230
00:09:22,180 --> 00:09:25,440
I don't have to think about
how this user came to be.

231
00:09:25,440 --> 00:09:27,630
I just have to use it.

232
00:09:27,630 --> 00:09:29,350
So to do that, we
need to mediate

233
00:09:29,350 --> 00:09:31,230
access to these things.

234
00:09:31,230 --> 00:09:34,290
Down this side is roughly
the user's flow if

235
00:09:34,290 --> 00:09:35,460
they're not logged in.

236
00:09:35,460 --> 00:09:37,560
They'll come to some part of
your application where they

237
00:09:37,560 --> 00:09:38,500
need to be logged in.

238
00:09:38,500 --> 00:09:41,410
They'll be redirected to a login
controller to choose

239
00:09:41,410 --> 00:09:43,000
their sign-in provider.

240
00:09:43,000 --> 00:09:45,760
Then something will happen,
depending on the provider.

241
00:09:45,760 --> 00:09:48,960
And eventually, they'll come
back to the callback, where

242
00:09:48,960 --> 00:09:51,610
they will be given
back that code.

243
00:09:51,610 --> 00:09:53,720
They will be given back
some kind of token.

244
00:09:53,720 --> 00:09:56,680
And we will need to bring that
back into the application and

245
00:09:56,680 --> 00:09:57,970
sign them in.

246
00:09:57,970 --> 00:09:59,235
In between, we have this
authenticator.

247
00:09:59,235 --> 00:10:03,120
And the authenticator is
handling all of the identity

248
00:10:03,120 --> 00:10:05,350
stuff for the vast majority
of our app.

249
00:10:05,350 --> 00:10:08,370
In our sample apps, there's
probably more identity code

250
00:10:08,370 --> 00:10:08,930
than anything else.

251
00:10:08,930 --> 00:10:11,550
But in reality, the vast
majority of your code should

252
00:10:11,550 --> 00:10:14,080
be business code, should be
doing what you want it to do.

253
00:10:14,080 --> 00:10:16,310
So we can get the
user from here.

254
00:10:16,310 --> 00:10:18,990
We can list the providers so
that we can create the sign-in

255
00:10:18,990 --> 00:10:20,160
options for them.

256
00:10:20,160 --> 00:10:23,040
We can take the response from
the outside world and route it

257
00:10:23,040 --> 00:10:24,700
to the appropriate provider.

258
00:10:24,700 --> 00:10:28,250
And in all of these cases, we
don't want to have to know

259
00:10:28,250 --> 00:10:31,850
which each provider is--

260
00:10:31,850 --> 00:10:33,800
what they're doing,
how they work.

261
00:10:33,800 --> 00:10:35,070
We want it to be hidden.

262
00:10:35,070 --> 00:10:36,840
So we need an interface.

263
00:10:36,840 --> 00:10:39,910
We need to separate the generic
parts of going through

264
00:10:39,910 --> 00:10:42,510
a sign-in process, checking
whether the user is

265
00:10:42,510 --> 00:10:45,620
authenticated, signing them in,
verifying that response to

266
00:10:45,620 --> 00:10:47,770
make sure they're the
user we expect.

267
00:10:47,770 --> 00:10:49,350
And we need to provide a user.

268
00:10:49,350 --> 00:10:50,150
That's at the heart of it.

269
00:10:50,150 --> 00:10:51,770
If we can't provide
a user, we're not

270
00:10:51,770 --> 00:10:53,080
doing anything useful.

271
00:10:53,080 --> 00:10:56,390
But then for each individual
provider, we need to implement

272
00:10:56,390 --> 00:11:00,480
a specific strategy of how to
go and do those things for

273
00:11:00,480 --> 00:11:01,580
this provider.

274
00:11:01,580 --> 00:11:04,140
So we have an interface.

275
00:11:04,140 --> 00:11:07,000
It's how we decompose things
in an OO system.

276
00:11:07,000 --> 00:11:09,760
We have an interface which
defines exactly that thing.

277
00:11:09,760 --> 00:11:10,730
These are the functions.

278
00:11:10,730 --> 00:11:14,330
Now this is PHP, and it's the
web, and it's a slightly noddy

279
00:11:14,330 --> 00:11:17,120
demo example, so I'm just
getting a markup and getting

280
00:11:17,120 --> 00:11:18,920
script to actually
do the request.

281
00:11:18,920 --> 00:11:22,510
You might prefer to get a URL
or to return an object or to

282
00:11:22,510 --> 00:11:25,370
return a reference
to a template.

283
00:11:25,370 --> 00:11:26,950
There's 100 different
ways of doing it.

284
00:11:26,950 --> 00:11:29,070
But the general idea is, you're
going to need something

285
00:11:29,070 --> 00:11:31,360
that will initiate
the process.

286
00:11:31,360 --> 00:11:34,730
And that's what that does
in this example.

287
00:11:34,730 --> 00:11:38,100
So even for a nice,
standards-compliant, OAuth 2.0

288
00:11:38,100 --> 00:11:40,080
implementation like
GitHub, there's

289
00:11:40,080 --> 00:11:42,520
things that are specific.

290
00:11:42,520 --> 00:11:45,430
GitHub have a certain way of
dealing with redirect URIs

291
00:11:45,430 --> 00:11:47,310
that's not necessarily
the same way every

292
00:11:47,310 --> 00:11:48,360
other provider does.

293
00:11:48,360 --> 00:11:50,400
So we need to take that
into consideration.

294
00:11:50,400 --> 00:11:53,620
They also have their own URLs
for getting a token in the

295
00:11:53,620 --> 00:11:54,350
OAuth flow.

296
00:11:54,350 --> 00:11:57,530
They have their own URLs
for exchanging--

297
00:11:57,530 --> 00:11:59,590
for sending the user
to so that they can

298
00:11:59,590 --> 00:12:00,830
actually sign in.

299
00:12:00,830 --> 00:12:02,440
And we want to encapsulate
all that.

300
00:12:02,440 --> 00:12:03,820
So we have logic like this.

301
00:12:03,820 --> 00:12:09,610
This is just going to create a
token to avoid CSRF attacks.

302
00:12:09,610 --> 00:12:13,445
Put that into a URL along with
our client ID, our identifier

303
00:12:13,445 --> 00:12:17,800
of which application we are with
GitHub, our state value

304
00:12:17,800 --> 00:12:20,840
there, and the URL we'd like
users to be redirected to

305
00:12:20,840 --> 00:12:21,690
afterwards.

306
00:12:21,690 --> 00:12:22,770
All of this is private.

307
00:12:22,770 --> 00:12:25,350
All of this stays inside
our GitHub class.

308
00:12:25,350 --> 00:12:27,770
The external surface area
is getting markup.

309
00:12:27,770 --> 00:12:29,760
And in this case, we're just
going to return a button.

310
00:12:29,760 --> 00:12:31,515
It's a thing someone
can click.

311
00:12:31,515 --> 00:12:32,760
It's not complex.

312
00:12:32,760 --> 00:12:35,500
We just get that URL, whack
it into some HTML,

313
00:12:35,500 --> 00:12:37,440
someone clicks it, fine.

314
00:12:37,440 --> 00:12:38,500
When they've done that,
they're going

315
00:12:38,500 --> 00:12:39,650
to go away to GitHub.

316
00:12:39,650 --> 00:12:42,670
They'll approve this
access, hopefully.

317
00:12:42,670 --> 00:12:45,410
And when they come back, they're
going to come back

318
00:12:45,410 --> 00:12:46,240
with a code.

319
00:12:46,240 --> 00:12:48,200
That code is going to be sent
to our authenticator.

320
00:12:48,200 --> 00:12:50,215
Our authenticator is going to
work out which provider it

321
00:12:50,215 --> 00:12:52,080
needs to go to and
send it to that.

322
00:12:52,080 --> 00:12:55,350
And at that point, we
need to verify it.

323
00:12:55,350 --> 00:12:57,345
So in this case, we're going
to do a token exchange.

324
00:12:57,345 --> 00:13:00,840
And we're going to look at the
results of the token that

325
00:13:00,840 --> 00:13:01,310
comes back.

326
00:13:01,310 --> 00:13:03,390
So we take the short-lived
code we're given.

327
00:13:03,390 --> 00:13:04,590
We send it off to GitHub.

328
00:13:04,590 --> 00:13:05,990
We get back an access token.

329
00:13:05,990 --> 00:13:07,910
And we can look at that and see
what we can do with it.

330
00:13:07,910 --> 00:13:10,920
For example, we can go and get
the user's profile so we know

331
00:13:10,920 --> 00:13:11,570
their name.

332
00:13:11,570 --> 00:13:13,275
We know they are.

333
00:13:13,275 --> 00:13:16,040
Now if we do this with Google+,
we probably want to

334
00:13:16,040 --> 00:13:17,080
do it a little bit
differently.

335
00:13:17,080 --> 00:13:20,540
In Google+, we'd like to use
this nice JavaScript

336
00:13:20,540 --> 00:13:21,380
postMessage flow.

337
00:13:21,380 --> 00:13:23,180
So the markup isn't a link.

338
00:13:23,180 --> 00:13:26,440
It's this tag, which has the
g-signing class on it.

339
00:13:26,440 --> 00:13:29,420
And that's going to generate a
button that's going to trigger

340
00:13:29,420 --> 00:13:31,700
a JavaScript callback
once they click it.

341
00:13:31,700 --> 00:13:34,250
And then we can send the
response of that callback back

342
00:13:34,250 --> 00:13:35,210
to our server.

343
00:13:35,210 --> 00:13:37,170
So in this case, the user isn't
getting redirected.

344
00:13:37,170 --> 00:13:39,030
We're handling that through
JavaScript.

345
00:13:39,030 --> 00:13:41,810
But the same end result
kind of happens.

346
00:13:41,810 --> 00:13:44,740
Some information comes back to
our server, and we need to

347
00:13:44,740 --> 00:13:46,300
validate it.

348
00:13:46,300 --> 00:13:49,030
So we can send it through to our
validate function, which

349
00:13:49,030 --> 00:13:50,570
looks a bit like this.

350
00:13:50,570 --> 00:13:51,850
Same idea.

351
00:13:51,850 --> 00:13:54,000
Exchange token, get the
user's profile.

352
00:13:54,000 --> 00:13:58,750
In this case, we can use the
Google PHP API client library

353
00:13:58,750 --> 00:14:00,170
to do that for us.

354
00:14:00,170 --> 00:14:02,690
But in either case, we
don't have to care.

355
00:14:02,690 --> 00:14:03,540
We've done that.

356
00:14:03,540 --> 00:14:04,600
We've got that information.

357
00:14:04,600 --> 00:14:06,970
We can generate a user and
return it, and our controller

358
00:14:06,970 --> 00:14:08,580
code just deals with the user.

359
00:14:08,580 --> 00:14:12,080
Doesn't have to think about
how that user came to be.

360
00:14:12,080 --> 00:14:15,610
But in our little example, I
was just getting the name.

361
00:14:15,610 --> 00:14:17,890
And the name's not
very interesting.

362
00:14:17,890 --> 00:14:20,970
We want to do more interesting
things with the APIs we've

363
00:14:20,970 --> 00:14:23,630
exposed by signing in
with a provider.

364
00:14:23,630 --> 00:14:27,200
And that's tricky because when
we're doing that, we need to

365
00:14:27,200 --> 00:14:29,650
think about what specific
functionality

366
00:14:29,650 --> 00:14:32,240
each provider provides.

367
00:14:32,240 --> 00:14:34,270
There's very little that is
shared between everyone you

368
00:14:34,270 --> 00:14:36,240
could sign in with.

369
00:14:36,240 --> 00:14:38,390
All we need to do, though, is
to think about what we're

370
00:14:38,390 --> 00:14:42,240
trying to do rather than how
we're actually doing it.

371
00:14:42,240 --> 00:14:44,010
If you imagine you had a section
on a site that had a

372
00:14:44,010 --> 00:14:47,490
kind of "Recommended For You,"
and there was a provider that

373
00:14:47,490 --> 00:14:51,690
returned an interest list, and
that was a list of entries in

374
00:14:51,690 --> 00:14:54,360
a database in some graph
database somewhere that said

375
00:14:54,360 --> 00:14:57,100
what you were interested in or
a list of entities that you

376
00:14:57,100 --> 00:14:59,855
were interested in, and you were
extracting tags out of

377
00:14:59,855 --> 00:15:01,230
that and using those
tags to look up

378
00:15:01,230 --> 00:15:03,200
content in your database.

379
00:15:03,200 --> 00:15:06,750
If you model it mentally as,
I get that information from

380
00:15:06,750 --> 00:15:08,200
there, you're limited.

381
00:15:08,200 --> 00:15:09,340
You can only do it with them.

382
00:15:09,340 --> 00:15:12,060
If you think about, I just need
a list of tags, then you

383
00:15:12,060 --> 00:15:14,430
can do it a number of
different ways.

384
00:15:14,430 --> 00:15:16,480
You could get those tags
by looking at a social

385
00:15:16,480 --> 00:15:17,530
bookmarking site.

386
00:15:17,530 --> 00:15:19,610
You could get it from posts
or hashtags on a social

387
00:15:19,610 --> 00:15:20,530
networking site.

388
00:15:20,530 --> 00:15:21,530
You could go and look
at someone's

389
00:15:21,530 --> 00:15:23,280
YouTube watch history.

390
00:15:23,280 --> 00:15:25,190
Once you think about it in terms
of the feature you're

391
00:15:25,190 --> 00:15:28,260
actually trying to provide, you
then have the flexibility

392
00:15:28,260 --> 00:15:31,010
to implement it different ways
with different providers.

393
00:15:31,010 --> 00:15:33,825
It's the same idea of separating
and abstraction

394
00:15:33,825 --> 00:15:37,340
there and not leaking the
details of that provider

395
00:15:37,340 --> 00:15:39,640
through to your application.

396
00:15:39,640 --> 00:15:41,750
So that means we need to
represent the user.

397
00:15:41,750 --> 00:15:44,680
And we do that, again, with an
interface because each of

398
00:15:44,680 --> 00:15:47,230
these providers is going to
return their own concrete user

399
00:15:47,230 --> 00:15:50,590
object which provides
this interface.

400
00:15:50,590 --> 00:15:51,700
So we've got the name.

401
00:15:51,700 --> 00:15:53,610
We've got the provider ID.

402
00:15:53,610 --> 00:15:55,870
We've got whether they can
do a certain feature.

403
00:15:55,870 --> 00:15:58,430
And we've got signOut and
disconnect so we can obey the

404
00:15:58,430 --> 00:16:00,790
various rules for various
networks on what options

405
00:16:00,790 --> 00:16:02,235
should be given to users.

406
00:16:02,235 --> 00:16:05,570
But you'll note that we've made
a decision here which is

407
00:16:05,570 --> 00:16:10,350
a little bit subtle in that this
user has a provider and a

408
00:16:10,350 --> 00:16:13,160
ID, just the one.

409
00:16:13,160 --> 00:16:15,335
We've made the decision that
what's happening here is you

410
00:16:15,335 --> 00:16:19,300
are signing in, not
signing up.

411
00:16:19,300 --> 00:16:21,530
And both models are common.

412
00:16:21,530 --> 00:16:24,450
When you sign in, there is a
one-to-one mapping between an

413
00:16:24,450 --> 00:16:28,080
identity provider account and
an application account.

414
00:16:28,080 --> 00:16:32,230
When you sign up, there is a
many-to-one mapping between

415
00:16:32,230 --> 00:16:36,270
identity providers and
a single app account.

416
00:16:36,270 --> 00:16:38,980
So each case is valid.

417
00:16:38,980 --> 00:16:40,260
Each case is a reasonable
thing.

418
00:16:40,260 --> 00:16:44,380
I can sign in with GitHub and
be me and sign in as Google+

419
00:16:44,380 --> 00:16:47,970
and be me, or I can sign in with
those two networks and be

420
00:16:47,970 --> 00:16:49,785
two different users
on the system.

421
00:16:49,785 --> 00:16:51,460
It depends on what
you're doing.

422
00:16:51,460 --> 00:16:54,820
And communicating this is part
of what the user story is,

423
00:16:54,820 --> 00:16:58,460
making them understand what's
valuable for them.

424
00:16:58,460 --> 00:17:00,230
But who is the user, anyway?

425
00:17:00,230 --> 00:17:02,550
What are we actually storing?

426
00:17:02,550 --> 00:17:04,910
What are we actually
working with?

427
00:17:04,910 --> 00:17:08,069
A lot of the time when people
implement a provider, they

428
00:17:08,069 --> 00:17:10,700
take the ID, and they stick it
in the database column, and

429
00:17:10,700 --> 00:17:11,819
they're done.

430
00:17:11,819 --> 00:17:13,290
And that's bad.

431
00:17:13,290 --> 00:17:15,140
Because when you do that, you've
coupled yourself to

432
00:17:15,140 --> 00:17:15,660
that provider.

433
00:17:15,660 --> 00:17:19,119
As soon as you add another
one, that ID is no longer

434
00:17:19,119 --> 00:17:20,630
enough information.

435
00:17:20,630 --> 00:17:25,260
You need to always store a
tuple, a pair of the provider

436
00:17:25,260 --> 00:17:27,619
and the provider user ID.

437
00:17:27,619 --> 00:17:29,980
So in this case, this is Google
and my Google ID,

438
00:17:29,980 --> 00:17:33,110
Facebook and my Facebook ID,
LinkedIn and my LinkedIn ID.

439
00:17:33,110 --> 00:17:34,880
Those are all identifiers.

440
00:17:34,880 --> 00:17:38,350
And I can have multiple of those
referring to the same

441
00:17:38,350 --> 00:17:41,620
app user if I want to.

442
00:17:41,620 --> 00:17:45,260
And this is why things like
upgrade are not a problem.

443
00:17:45,260 --> 00:17:47,780
If you already had an OAuth 2.0
login, and you wanted to

444
00:17:47,780 --> 00:17:50,820
go to Google+ Sign-In, it's
not a problem because the

445
00:17:50,820 --> 00:17:52,630
provider is still Google.

446
00:17:52,630 --> 00:17:54,790
The user ID is still
that user ID.

447
00:17:54,790 --> 00:17:56,630
It's just a different way
of getting there.

448
00:17:56,630 --> 00:17:59,260
And thinking about it that way
means that you don't have to

449
00:17:59,260 --> 00:18:02,490
worry about the exact strategy
being used to sign a user in.

450
00:18:02,490 --> 00:18:04,930
If you use a completely
different system on mobile

451
00:18:04,930 --> 00:18:07,780
than you do on the web, as long
as it results in that

452
00:18:07,780 --> 00:18:09,970
pair, you know it's
the same user.

453
00:18:09,970 --> 00:18:11,350
And that's great.

454
00:18:11,350 --> 00:18:14,300
Now the other thing people
look at is email.

455
00:18:14,300 --> 00:18:17,650
And email is often used to
combine accounts, which feels

456
00:18:17,650 --> 00:18:18,910
like a good thing.

457
00:18:18,910 --> 00:18:21,360
But it's tricky.

458
00:18:21,360 --> 00:18:25,080
When you have an email address,
you have some

459
00:18:25,080 --> 00:18:26,070
knowledge about that user.

460
00:18:26,070 --> 00:18:28,010
That user probably had
that email address.

461
00:18:28,010 --> 00:18:30,530
Most providers will do
some verification.

462
00:18:30,530 --> 00:18:33,690
But the verification is likely
to be point in time.

463
00:18:33,690 --> 00:18:37,800
So at some point, the identity
provider sent an

464
00:18:37,800 --> 00:18:38,730
email to that address.

465
00:18:38,730 --> 00:18:39,900
The user clicked the email.

466
00:18:39,900 --> 00:18:41,280
They had that address then.

467
00:18:41,280 --> 00:18:44,230
But particularly with corporate
email, with email on

468
00:18:44,230 --> 00:18:47,900
free providers, sometimes
things get reused.

469
00:18:47,900 --> 00:18:51,580
Sometimes email belongs
to a different person.

470
00:18:51,580 --> 00:18:54,270
But it doesn't mean that all the
other identities that have

471
00:18:54,270 --> 00:18:56,960
been associated with that
email get invalidated.

472
00:18:56,960 --> 00:19:03,530
So it can be a little risky
at times to rely on email.

473
00:19:03,530 --> 00:19:07,660
The OpenID Connect spec actually
says, do not assume

474
00:19:07,660 --> 00:19:09,305
email to be a unique
identifier.

475
00:19:09,305 --> 00:19:13,150
It is totally fine for an
identity provider to return an

476
00:19:13,150 --> 00:19:14,500
email address--

477
00:19:14,500 --> 00:19:16,990
the same email address-- for
two different accounts.

478
00:19:16,990 --> 00:19:19,560
You should always look for
that ID and that provider

479
00:19:19,560 --> 00:19:20,600
identification.

480
00:19:20,600 --> 00:19:23,220
That's the most reliable way
of dealing with them.

481
00:19:23,220 --> 00:19:26,330
But the way of having multiple
accounts is nice.

482
00:19:26,330 --> 00:19:30,050
So the Android code is in the
GitHub repo, the sort of

483
00:19:30,050 --> 00:19:31,700
sample we're working with.

484
00:19:31,700 --> 00:19:33,840
That has this basic idea.

485
00:19:33,840 --> 00:19:36,500
You can sign in, and there's a
bunch of features, pretty much

486
00:19:36,500 --> 00:19:38,040
the same as PHP.

487
00:19:38,040 --> 00:19:40,710
And when you sign in, we enable
the features that go

488
00:19:40,710 --> 00:19:42,400
with that network.

489
00:19:42,400 --> 00:19:45,410
But at this point,
we've created an

490
00:19:45,410 --> 00:19:46,620
app account as well.

491
00:19:46,620 --> 00:19:48,810
That's why it can say, thank
you for using our app.

492
00:19:48,810 --> 00:19:50,610
Because it knows I'm new.

493
00:19:50,610 --> 00:19:54,260
I have local state to go with
my identity provider state.

494
00:19:54,260 --> 00:19:57,630
And that means I can attach
other identity

495
00:19:57,630 --> 00:19:59,250
providers as well.

496
00:19:59,250 --> 00:20:02,390
And then I get more features
available to me because those

497
00:20:02,390 --> 00:20:04,740
providers provide additional
features.

498
00:20:04,740 --> 00:20:07,140
And this pattern is very, very
common in the real world.

499
00:20:07,140 --> 00:20:10,700
This is TuneIn Radio, The Fancy,
and Banjo, all who

500
00:20:10,700 --> 00:20:12,610
implement pretty much
this structure.

501
00:20:12,610 --> 00:20:15,230
And you'll see it in
many, many apps.

502
00:20:15,230 --> 00:20:17,970
All of them allowing you to
map multiple identity

503
00:20:17,970 --> 00:20:20,440
providers to a single
user account.

504
00:20:20,440 --> 00:20:22,590
And that means you need to think
about how the data is

505
00:20:22,590 --> 00:20:24,560
structured differently.

506
00:20:24,560 --> 00:20:27,150
You can't think about
one table of a user.

507
00:20:27,150 --> 00:20:30,280
You have to have a separation
between the identity provider

508
00:20:30,280 --> 00:20:31,610
and the user.

509
00:20:31,610 --> 00:20:33,760
And it's many-to-one.

510
00:20:33,760 --> 00:20:35,970
This is good, though, because
once you have this second

511
00:20:35,970 --> 00:20:39,800
table that has the provider user
ID, you can then key data

512
00:20:39,800 --> 00:20:40,740
against it.

513
00:20:40,740 --> 00:20:43,300
So if you retrieve some
information, you can put it

514
00:20:43,300 --> 00:20:46,850
into another table keyed against
the provider user ID.

515
00:20:46,850 --> 00:20:49,470
Which means if you need to
disconnect a user, and you

516
00:20:49,470 --> 00:20:52,140
have to follow data deletion
rules, it's easy.

517
00:20:52,140 --> 00:20:54,440
You just look up everything
attached to that ID.

518
00:20:54,440 --> 00:20:58,610
If you have to expire a cache
after a certain amount of

519
00:20:58,610 --> 00:21:00,110
time, then it's easy.

520
00:21:00,110 --> 00:21:03,180
You just look up everything
connected to that ID.

521
00:21:03,180 --> 00:21:05,910
So having this separation makes
it easier to structure

522
00:21:05,910 --> 00:21:08,040
your applications and structure
the data retrieved

523
00:21:08,040 --> 00:21:13,050
from your applications and the
provenance of that data.

524
00:21:13,050 --> 00:21:15,020
So to do this, we're going
to do things a little bit

525
00:21:15,020 --> 00:21:15,540
differently.

526
00:21:15,540 --> 00:21:16,810
We've still got the
same basic model.

527
00:21:16,810 --> 00:21:18,760
We've got our authenticator
layer in the middle.

528
00:21:18,760 --> 00:21:20,460
Though in this case, it's
going to be a fragment.

529
00:21:20,460 --> 00:21:24,030
We've got our providers, which
are going to be fairly dumb.

530
00:21:24,030 --> 00:21:26,230
And we've got our activity.

531
00:21:26,230 --> 00:21:30,730
But we know that our providers
are going to want to hold a

532
00:21:30,730 --> 00:21:32,010
little bit more state.

533
00:21:32,010 --> 00:21:35,050
We'd like our providers to be
able to be signed in, so that

534
00:21:35,050 --> 00:21:37,700
when you go in and attach
them, if you've already

535
00:21:37,700 --> 00:21:40,900
authenticated with that app in
that device, it's quick.

536
00:21:40,900 --> 00:21:42,160
It's a quick thing to do.

537
00:21:42,160 --> 00:21:45,740
So it speeds the process
for the user.

538
00:21:45,740 --> 00:21:47,590
And we know we're going to
have to pass around some

539
00:21:47,590 --> 00:21:48,120
information.

540
00:21:48,120 --> 00:21:50,540
Activity results are going to
have to flow all the way back

541
00:21:50,540 --> 00:21:53,570
from the outside world, if it's
going out to the system

542
00:21:53,570 --> 00:21:55,620
browser, back in to
our provider.

543
00:21:55,620 --> 00:21:56,930
But it's roughly
the same idea.

544
00:21:56,930 --> 00:21:59,130
We're sending information
back to be verified.

545
00:21:59,130 --> 00:22:02,380
And when we're done, we
send the user back.

546
00:22:02,380 --> 00:22:04,650
But there's an extra
complication in it.

547
00:22:04,650 --> 00:22:07,340
In this middle layer, we
don't just send the

548
00:22:07,340 --> 00:22:08,950
user straight back.

549
00:22:08,950 --> 00:22:10,240
It's the same as in PHP.

550
00:22:10,240 --> 00:22:12,660
We have a user created
in our provider.

551
00:22:12,660 --> 00:22:14,670
But we don't just send
it straight back

552
00:22:14,670 --> 00:22:16,950
out to our main activity.

553
00:22:16,950 --> 00:22:20,510
Instead, we have this account
user concept, because we need

554
00:22:20,510 --> 00:22:24,110
to be able to deal
with those cases.

555
00:22:24,110 --> 00:22:28,000
We need to be able to go, does
this identity provider user

556
00:22:28,000 --> 00:22:29,760
map to an account user?

557
00:22:29,760 --> 00:22:33,800
Does it map to an account user
when one is already signed in?

558
00:22:33,800 --> 00:22:34,860
Is it the same user?

559
00:22:34,860 --> 00:22:38,140
We need to consider that state
before we return anything.

560
00:22:38,140 --> 00:22:40,970
And we won't return anything
until we've resolved it into a

561
00:22:40,970 --> 00:22:45,180
central reliable application
user.

562
00:22:45,180 --> 00:22:47,040
So it's pretty straightforward
for our activities.

563
00:22:47,040 --> 00:22:48,180
They get to do things
like this.

564
00:22:48,180 --> 00:22:49,290
They get a callback.

565
00:22:49,290 --> 00:22:50,115
They can get the name.

566
00:22:50,115 --> 00:22:51,140
They can test the features.

567
00:22:51,140 --> 00:22:53,500
They can see if the
user's new.

568
00:22:53,500 --> 00:22:54,390
Simple.

569
00:22:54,390 --> 00:22:57,030
They don't have to
do much at all.

570
00:22:57,030 --> 00:23:00,180
Our sign-in user, however, has
to do a lot more work.

571
00:23:00,180 --> 00:23:03,690
Rather than just being an
interface, it's now a concrete

572
00:23:03,690 --> 00:23:06,800
object because it needs to carry
with it information.

573
00:23:06,800 --> 00:23:10,030
It needs to carry with it the
provider data for all of the

574
00:23:10,030 --> 00:23:11,640
providers that are attached.

575
00:23:11,640 --> 00:23:13,595
Previously, that was
kind of built in.

576
00:23:13,595 --> 00:23:15,680
If you had a Google user,
that Google user

577
00:23:15,680 --> 00:23:16,730
came with that data.

578
00:23:16,730 --> 00:23:19,350
In this case, we want to attach
Google data or LinkedIn

579
00:23:19,350 --> 00:23:21,980
data or Facebook data into
the same object.

580
00:23:21,980 --> 00:23:23,640
And we need access
to a database.

581
00:23:23,640 --> 00:23:26,760
Now in this case, this is
just a local SQLite.

582
00:23:26,760 --> 00:23:31,620
In reality you'd probably be
using Cinque to sync down to a

583
00:23:31,620 --> 00:23:34,950
web service somewhere or other
kind of communication.

584
00:23:34,950 --> 00:23:37,150
And your user store would
be on a server.

585
00:23:37,150 --> 00:23:39,990
But the basic concept
is similar.

586
00:23:39,990 --> 00:23:43,330
You're going to have this
representation of a user

587
00:23:43,330 --> 00:23:45,280
stored away in a database.

588
00:23:45,280 --> 00:23:48,560
So to add a provider, all we
need to do is put their

589
00:23:48,560 --> 00:23:51,920
information into that hash we
defined earlier, and then, if

590
00:23:51,920 --> 00:23:56,700
the user ID is null-- and that
ID, that mId, is the account

591
00:23:56,700 --> 00:23:58,590
user ID, is the app user ID.

592
00:23:58,590 --> 00:23:59,690
It's not a provider one.

593
00:23:59,690 --> 00:24:02,660
That's why there's just an
ID no matching provider.

594
00:24:02,660 --> 00:24:04,830
If it's null, we're going
to then go and

595
00:24:04,830 --> 00:24:06,080
retrieve a user ID.

596
00:24:06,080 --> 00:24:09,060
Say, has this user signed
in with this provider?

597
00:24:09,060 --> 00:24:10,990
If they have, great.

598
00:24:10,990 --> 00:24:11,940
We know who this is.

599
00:24:11,940 --> 00:24:12,900
We can go with it.

600
00:24:12,900 --> 00:24:15,210
If they haven't, we
can create a user.

601
00:24:15,210 --> 00:24:17,080
And that's when we can
set the IsNew flag.

602
00:24:17,080 --> 00:24:19,375
We know we've had to build
a user for this.

603
00:24:19,375 --> 00:24:22,230
And all that's doing is just
insert some reads on those

604
00:24:22,230 --> 00:24:24,610
database tables.

605
00:24:24,610 --> 00:24:26,100
And then it's easy.

606
00:24:26,100 --> 00:24:28,720
Dealing with things like
features, all the features are

607
00:24:28,720 --> 00:24:30,980
is just a set of features
provided by

608
00:24:30,980 --> 00:24:32,240
each connected provider.

609
00:24:32,240 --> 00:24:34,440
So we just loop over the
providers we have in our

610
00:24:34,440 --> 00:24:36,980
object, and we can test
them to see, do you

611
00:24:36,980 --> 00:24:37,940
provide this feature?

612
00:24:37,940 --> 00:24:39,590
If you do, I'm good to go.

613
00:24:39,590 --> 00:24:40,660
Very simple for our object.

614
00:24:40,660 --> 00:24:43,710
And note, it doesn't have to
know anything about who these

615
00:24:43,710 --> 00:24:44,120
providers are.

616
00:24:44,120 --> 00:24:47,790
The user never has to care about
who the providers are.

617
00:24:47,790 --> 00:24:50,440
They just follow
the interface.

618
00:24:50,440 --> 00:24:53,540
So you don't have to leak that
provider-specific code into

619
00:24:53,540 --> 00:24:56,510
anywhere else in your
application.

620
00:24:56,510 --> 00:24:58,880
But the provider-specific code
gets to be relatively

621
00:24:58,880 --> 00:24:59,930
straightforward as well.

622
00:24:59,930 --> 00:25:02,800
You don't have to do too much
with it because it doesn't

623
00:25:02,800 --> 00:25:06,950
have to carry much more than
just its general state.

624
00:25:06,950 --> 00:25:10,040
So when we want to attempt to
sign in, to see if we've got a

625
00:25:10,040 --> 00:25:12,360
connection using Facebook,
we can just use the

626
00:25:12,360 --> 00:25:15,350
openActiveSession call with
allowLoginUI set to false.

627
00:25:15,350 --> 00:25:17,050
So that's that middle
parameter there.

628
00:25:17,050 --> 00:25:19,640
And that means, we'll try and
see whether we have a valid

629
00:25:19,640 --> 00:25:20,810
Facebook session running.

630
00:25:20,810 --> 00:25:23,270
If we do, cool.

631
00:25:23,270 --> 00:25:24,960
We've gotten a user account
ready to go.

632
00:25:24,960 --> 00:25:27,680
So if the user taps on us, we
can immediately serve it.

633
00:25:27,680 --> 00:25:29,110
If not, fine.

634
00:25:29,110 --> 00:25:30,360
We'll just leave it.

635
00:25:30,360 --> 00:25:33,030
In the sign-in, though, where
a user action has been

636
00:25:33,030 --> 00:25:35,310
requested, we make the same
call but with that

637
00:25:35,310 --> 00:25:37,160
allowLoginUI set to true.

638
00:25:37,160 --> 00:25:39,120
So we'll actively go
and make a call.

639
00:25:39,120 --> 00:25:42,890
We'll actively present dialogue
to the users for them

640
00:25:42,890 --> 00:25:44,300
to sign in with.

641
00:25:44,300 --> 00:25:46,210
It's precisely the same
with Google+.

642
00:25:46,210 --> 00:25:48,970
When we go in, we have
a connect call.

643
00:25:48,970 --> 00:25:50,960
That's going to connect to
Google Play services.

644
00:25:50,960 --> 00:25:52,580
That's where our authentication
has

645
00:25:52,580 --> 00:25:53,740
kind of been held.

646
00:25:53,740 --> 00:25:55,480
We go to Google Play services.

647
00:25:55,480 --> 00:25:56,910
We see whether we're
signed in.

648
00:25:56,910 --> 00:25:59,850
If we're not, we're going to get
a call back with an error.

649
00:25:59,850 --> 00:26:02,990
And that error can be resolved
into an intent which will

650
00:26:02,990 --> 00:26:04,690
display some dialogue
to the user.

651
00:26:04,690 --> 00:26:06,050
So we just won't do that.

652
00:26:06,050 --> 00:26:08,900
When the user signs in, we know
they've taken an action.

653
00:26:08,900 --> 00:26:11,840
So we can display that dialogue
to them and let them

654
00:26:11,840 --> 00:26:14,780
sign in and let them
authenticate with us.

655
00:26:14,780 --> 00:26:15,750
So that's fine.

656
00:26:15,750 --> 00:26:18,930
And most of the time, we're
in a really easy state.

657
00:26:18,930 --> 00:26:22,190
The user goes to the choose
a page, taps a sign-in, an

658
00:26:22,190 --> 00:26:24,880
account is created or looked
up, and there we are.

659
00:26:24,880 --> 00:26:27,900
We have an identity provider
and an app account.

660
00:26:27,900 --> 00:26:31,310
You come back another day,
or another user comes in,

661
00:26:31,310 --> 00:26:33,680
identity provider account,
app account, great.

662
00:26:33,680 --> 00:26:37,660
But sometimes you've
got this situation.

663
00:26:37,660 --> 00:26:40,730
And then the top user signs
in with the same identity

664
00:26:40,730 --> 00:26:44,880
provider, the same identity
provider account, which now

665
00:26:44,880 --> 00:26:46,520
maps to a second account.

666
00:26:46,520 --> 00:26:48,400
We've now got a conflict.

667
00:26:48,400 --> 00:26:51,550
And what we do with that depends
on the application and

668
00:26:51,550 --> 00:26:53,190
what you want to do with it.

669
00:26:53,190 --> 00:26:55,940
Most of the time,
you can go, ah,

670
00:26:55,940 --> 00:26:57,850
these users don't conflict.

671
00:26:57,850 --> 00:26:59,320
We can just merge them.

672
00:26:59,320 --> 00:27:01,620
Whether that's something the
user would be involved with or

673
00:27:01,620 --> 00:27:02,715
not, that's up to you.

674
00:27:02,715 --> 00:27:03,760
But you know they've
signed in.

675
00:27:03,760 --> 00:27:04,940
You know they have
authenticated

676
00:27:04,940 --> 00:27:06,240
on both these systems.

677
00:27:06,240 --> 00:27:07,300
So they have access.

678
00:27:07,300 --> 00:27:09,880
So you can choose to merge
it if you want.

679
00:27:09,880 --> 00:27:12,470
And that's roughly
what we do here.

680
00:27:12,470 --> 00:27:14,090
We just present a dialogue
to the user.

681
00:27:14,090 --> 00:27:16,040
Hey, this user already exists.

682
00:27:16,040 --> 00:27:19,000
But we can have those
map to the same app

683
00:27:19,000 --> 00:27:20,110
account if you want.

684
00:27:20,110 --> 00:27:22,270
Do you want to merge, or
do you want to switch?

685
00:27:22,270 --> 00:27:23,660
Because maybe you'd just
like to be this

686
00:27:23,660 --> 00:27:25,250
other user right now.

687
00:27:25,250 --> 00:27:26,870
We can give them that option.

688
00:27:26,870 --> 00:27:28,720
But sometimes we can't.

689
00:27:28,720 --> 00:27:31,350
It's easy to think of cases, but
there's likely to be more

690
00:27:31,350 --> 00:27:34,710
app-specific cases in your
application, where there are

691
00:27:34,710 --> 00:27:36,720
things between accounts
that don't allow them

692
00:27:36,720 --> 00:27:37,960
to be merged well.

693
00:27:37,960 --> 00:27:41,260
In this case, imagine there was
a third identity provider

694
00:27:41,260 --> 00:27:44,800
connected, and on that third
identity provider, two

695
00:27:44,800 --> 00:27:47,440
different users were
signed in.

696
00:27:47,440 --> 00:27:49,820
In that case, we couldn't
combine them.

697
00:27:49,820 --> 00:27:52,080
We can't merge those accounts
automatically.

698
00:27:52,080 --> 00:27:53,720
But we can still prompt
the user.

699
00:27:53,720 --> 00:27:56,000
They've done a legitimate action
by signing in with

700
00:27:56,000 --> 00:27:56,770
another provider.

701
00:27:56,770 --> 00:27:58,580
They genuinely have
access to that.

702
00:27:58,580 --> 00:28:00,640
We just can't fix the
situation for them.

703
00:28:00,640 --> 00:28:02,760
So we can just say to them, hey,
do you want to switch?

704
00:28:02,760 --> 00:28:05,610
Or just cancel, stay
where you are.

705
00:28:05,610 --> 00:28:09,250
And all of that is mediated
by this authenticator.

706
00:28:09,250 --> 00:28:12,160
All of that is mediated in the
fragment, in this middle

707
00:28:12,160 --> 00:28:15,780
layer, without needing to
know about the provider.

708
00:28:15,780 --> 00:28:16,790
We can go in.

709
00:28:16,790 --> 00:28:19,380
We can see, is the
user ID null?

710
00:28:19,380 --> 00:28:21,760
If it is, we just take that
user, whatever's been given to

711
00:28:21,760 --> 00:28:23,430
us by a provider.

712
00:28:23,430 --> 00:28:26,850
If it isn't null, then
is it the same as the

713
00:28:26,850 --> 00:28:27,800
user that's come in?

714
00:28:27,800 --> 00:28:30,350
So I've signed in
with Google+.

715
00:28:30,350 --> 00:28:31,670
I've signed in with Facebook.

716
00:28:31,670 --> 00:28:33,530
Both look up to the
same app user.

717
00:28:33,530 --> 00:28:34,520
It just connects the accounts.

718
00:28:34,520 --> 00:28:35,946
It doesn't have to
do anything.

719
00:28:35,946 --> 00:28:39,570
If that's not true, then
can I merge the users?

720
00:28:39,570 --> 00:28:41,530
What logic is required
to test that?

721
00:28:41,530 --> 00:28:44,180
That logic doesn't have to
involve knowing anything about

722
00:28:44,180 --> 00:28:45,140
who the providers are.

723
00:28:45,140 --> 00:28:47,770
It can just be testing, is there
a conflict between these

724
00:28:47,770 --> 00:28:49,120
two sets of providers?

725
00:28:49,120 --> 00:28:51,020
And it can be doing
application-specific

726
00:28:51,020 --> 00:28:51,870
information.

727
00:28:51,870 --> 00:28:54,700
But again, we don't have to look
into the provider to see

728
00:28:54,700 --> 00:28:57,450
how to do this.

729
00:28:57,450 --> 00:29:01,870
So I wanted to give you one
other way of looking at this

730
00:29:01,870 --> 00:29:04,730
kind of problem.

731
00:29:04,730 --> 00:29:08,900
Which is the idea that having
state for the identity

732
00:29:08,900 --> 00:29:13,820
provider user separate than
having application state is

733
00:29:13,820 --> 00:29:15,370
kind of beneficial.

734
00:29:15,370 --> 00:29:19,200
And you can use that to handle a
whole bunch of applications.

735
00:29:19,200 --> 00:29:21,850
So you might think of
a TV Guide that

736
00:29:21,850 --> 00:29:23,310
lives on a tablet app.

737
00:29:23,310 --> 00:29:26,740
TV Guide, different family
members want to see their

738
00:29:26,740 --> 00:29:28,280
chosen shows.

739
00:29:28,280 --> 00:29:29,950
But they don't-- it's
not secret, right?

740
00:29:29,950 --> 00:29:31,660
They just don't want to see
the other person's.

741
00:29:31,660 --> 00:29:32,890
They want be able to switch.

742
00:29:32,890 --> 00:29:34,160
So that means it's an
identity problem.

743
00:29:34,160 --> 00:29:35,710
You need to know who they are.

744
00:29:35,710 --> 00:29:39,240
But you don't really care
about separating

745
00:29:39,240 --> 00:29:40,080
that data too much.

746
00:29:40,080 --> 00:29:42,080
You just want to make sure they
only see the stuff they

747
00:29:42,080 --> 00:29:43,260
want to see.

748
00:29:43,260 --> 00:29:45,265
So you can build something
like this.

749
00:29:45,265 --> 00:29:46,910
And this is in iOS.

750
00:29:46,910 --> 00:29:47,830
And we've just got our screen.

751
00:29:47,830 --> 00:29:48,310
It's anonymous.

752
00:29:48,310 --> 00:29:50,110
You can tap Choose Account.

753
00:29:50,110 --> 00:29:51,510
When you choose account,
you get a

754
00:29:51,510 --> 00:29:53,810
list of attached accounts.

755
00:29:53,810 --> 00:29:55,570
In this case, there's
my Facebook account

756
00:29:55,570 --> 00:29:56,220
and a Twitter account.

757
00:29:56,220 --> 00:29:57,790
And Google+ isn't signed in.

758
00:29:57,790 --> 00:29:58,645
So I tap Google+.

759
00:29:58,645 --> 00:29:59,890
And then I sign in.

760
00:29:59,890 --> 00:30:01,550
I go through the regular flow.

761
00:30:01,550 --> 00:30:03,940
So even though these two
providers were signed in, that

762
00:30:03,940 --> 00:30:05,720
doesn't automatically sign
me in to the app.

763
00:30:05,720 --> 00:30:06,600
I have to choose.

764
00:30:06,600 --> 00:30:10,130
I have to go through
an account chooser.

765
00:30:10,130 --> 00:30:12,080
Once I do it, I'm signed
in, and I can use the

766
00:30:12,080 --> 00:30:13,000
application as me.

767
00:30:13,000 --> 00:30:15,317
But if I want to change, I just
hit Choose Account and

768
00:30:15,317 --> 00:30:16,210
can switch again.

769
00:30:16,210 --> 00:30:17,760
This is very much like
the fast account

770
00:30:17,760 --> 00:30:19,160
switching in Gmail--

771
00:30:19,160 --> 00:30:21,120
in the Gmail app, where
you can choose what

772
00:30:21,120 --> 00:30:22,280
you're using it is.

773
00:30:22,280 --> 00:30:24,030
That's a really valuable
model.

774
00:30:24,030 --> 00:30:27,530
And it brings home the point
that identity doesn't have to

775
00:30:27,530 --> 00:30:31,670
be like this huge lock and key
way of getting into systems.

776
00:30:31,670 --> 00:30:35,440
It can be anything that helps
the user use your application,

777
00:30:35,440 --> 00:30:38,020
helps them get what they
need out of it.

778
00:30:38,020 --> 00:30:41,230
So in this case, to keep it
lightweight, rather than have

779
00:30:41,230 --> 00:30:43,280
the view controller know
anything about our

780
00:30:43,280 --> 00:30:46,630
authentication layer in the
middle, I thought, why not use

781
00:30:46,630 --> 00:30:47,340
a message bus?

782
00:30:47,340 --> 00:30:50,990
And in iOS, NSNotification
Center is the sort of standard

783
00:30:50,990 --> 00:30:51,550
way of doing it.

784
00:30:51,550 --> 00:30:54,840
On Android, you could use any
EventBus type library.

785
00:30:54,840 --> 00:30:56,750
Otto Square is a good one.

786
00:30:56,750 --> 00:30:59,820
And in this case, the
user might go

787
00:30:59,820 --> 00:31:00,790
to the account chooser.

788
00:31:00,790 --> 00:31:01,600
The account chooser will

789
00:31:01,600 --> 00:31:03,140
communicate with the providers.

790
00:31:03,140 --> 00:31:06,260
If the user taps on one of them,
they just signal the

791
00:31:06,260 --> 00:31:08,470
authenticator which puts
a message onto the bus.

792
00:31:08,470 --> 00:31:10,340
And anyone that happens to be
listening that wants to know

793
00:31:10,340 --> 00:31:11,540
about it, knows.

794
00:31:11,540 --> 00:31:13,820
Very cheap, very
easy switching.

795
00:31:13,820 --> 00:31:17,980
Subscribing is as simple as
registering an observer of

796
00:31:17,980 --> 00:31:20,850
yourself with
kUserStatusNotification.

797
00:31:20,850 --> 00:31:22,960
That's just the message type
you want to listen for.

798
00:31:22,960 --> 00:31:25,030
And checkUser is the function
that should be called when the

799
00:31:25,030 --> 00:31:26,750
message comes in.

800
00:31:26,750 --> 00:31:29,230
And publishing is pretty
much the same.

801
00:31:29,230 --> 00:31:32,370
So we don't have to know
about what's going on

802
00:31:32,370 --> 00:31:35,430
between those two.

803
00:31:35,430 --> 00:31:37,340
And in this case, we
need the identity

804
00:31:37,340 --> 00:31:38,940
provider to hold state.

805
00:31:38,940 --> 00:31:42,540
It has to know whether it's
signed in because that doesn't

806
00:31:42,540 --> 00:31:44,380
mean that we're signed into
the app with that user.

807
00:31:44,380 --> 00:31:46,670
It just means they're
available.

808
00:31:46,670 --> 00:31:49,500
So each of our identity
providers, when you sign in,

809
00:31:49,500 --> 00:31:50,870
may already have a user.

810
00:31:50,870 --> 00:31:52,810
They can return it right away.

811
00:31:52,810 --> 00:31:55,050
You want to track
that separately.

812
00:31:55,050 --> 00:31:58,100
And then if the user
signed in, we can

813
00:31:58,100 --> 00:31:59,490
actually prompt some UI.

814
00:31:59,490 --> 00:32:00,550
We can bring something up.

815
00:32:00,550 --> 00:32:03,280
And in fact, this is from
an example with Twitter.

816
00:32:03,280 --> 00:32:07,480
So with Twitter, we're using the
built-in integration into

817
00:32:07,480 --> 00:32:11,260
the OS with the Social Framework
in iOS 5 and 6.

818
00:32:11,260 --> 00:32:12,340
So we can go in.

819
00:32:12,340 --> 00:32:15,190
We can request from the account
store accounts of type

820
00:32:15,190 --> 00:32:17,410
Twitter, see if we're
granted access.

821
00:32:17,410 --> 00:32:19,910
If we are, we can retrieve
that user.

822
00:32:19,910 --> 00:32:21,640
Now we'll do that either way.

823
00:32:21,640 --> 00:32:25,290
We'll do that if we've started
the app right away, and we'll

824
00:32:25,290 --> 00:32:27,020
do it when the user
taps Sign In.

825
00:32:27,020 --> 00:32:29,760
If we've started the app right
away, and the user has

826
00:32:29,760 --> 00:32:32,810
previously granted access, and
we retrieve a user, we won't

827
00:32:32,810 --> 00:32:33,490
do anything with it.

828
00:32:33,490 --> 00:32:35,620
We'll just keep it locally.

829
00:32:35,620 --> 00:32:37,670
And then when they sign
in, we return it.

830
00:32:37,670 --> 00:32:40,790
If this is happening once
they've already--

831
00:32:40,790 --> 00:32:42,110
once they've tapped
the button, we

832
00:32:42,110 --> 00:32:43,310
know it's a user action.

833
00:32:43,310 --> 00:32:45,950
So down here, we'll actually
take that user and return it

834
00:32:45,950 --> 00:32:47,270
back to our object.

835
00:32:47,270 --> 00:32:49,520
But again, wrapped in an
interface, wrapped in a way

836
00:32:49,520 --> 00:32:52,390
that means the actual view
controller doesn't have to

837
00:32:52,390 --> 00:32:55,450
understand how that identity
was provisioned.

838
00:32:55,450 --> 00:32:57,090
They just have to use it.

839
00:32:57,090 --> 00:32:59,130
Google+, pretty much
the same thing.

840
00:32:59,130 --> 00:33:01,230
We return the user if we
have it available.

841
00:33:01,230 --> 00:33:04,480
Otherwise, we just call the
authenticate method on the

842
00:33:04,480 --> 00:33:06,810
shared instance of the
GPPSignIn object.

843
00:33:06,810 --> 00:33:07,480
Very straightforward.

844
00:33:07,480 --> 00:33:12,360
And that will kick off
the process for us.

845
00:33:12,360 --> 00:33:19,500
So I kind hope that's given you
some ideas about ways you

846
00:33:19,500 --> 00:33:22,510
can think about combining
different providers.

847
00:33:22,510 --> 00:33:27,500
It doesn't have to be all or
nothing incredibly complex

848
00:33:27,500 --> 00:33:27,780
integration.

849
00:33:27,780 --> 00:33:30,250
It can be simple and
lightweight, and you can just

850
00:33:30,250 --> 00:33:31,270
let users choose.

851
00:33:31,270 --> 00:33:34,310
And I hope it gives you some
ideas about benefits.

852
00:33:34,310 --> 00:33:36,270
I appreciate it is difficult.

853
00:33:36,270 --> 00:33:39,980
If you are doing a situation
where you're merging multiple

854
00:33:39,980 --> 00:33:42,400
identity provider accounts onto
a single app account,

855
00:33:42,400 --> 00:33:43,590
there are edge cases.

856
00:33:43,590 --> 00:33:44,370
There are conflicts.

857
00:33:44,370 --> 00:33:45,670
And you'll have to
resolve those.

858
00:33:45,670 --> 00:33:47,270
And that will take time.

859
00:33:47,270 --> 00:33:50,300
But if done right, I do believe
that it will not just

860
00:33:50,300 --> 00:33:51,620
give your users a better
experience.

861
00:33:51,620 --> 00:33:53,230
It will actually help the
structure of your

862
00:33:53,230 --> 00:33:53,940
applications.

863
00:33:53,940 --> 00:33:57,490
It'll help you provide a good
system and a scalable system

864
00:33:57,490 --> 00:33:59,890
that is going to be flexible
when demands come up for you

865
00:33:59,890 --> 00:34:01,870
to change it, for you to change
versions, for you to

866
00:34:01,870 --> 00:34:05,420
upgrade, or to add
new providers.

867
00:34:05,420 --> 00:34:07,680
So that's about it for me.

868
00:34:07,680 --> 00:34:10,810
We'll do-- got a few minutes
for questions.

869
00:34:10,810 --> 00:34:15,550
But I'll be at the Google+
sandbox on the second floor

870
00:34:15,550 --> 00:34:17,310
afterwards if you
have any more.

871
00:34:17,310 --> 00:34:19,940
If you're interested in this
kind of thing, Eric Sachs from

872
00:34:19,940 --> 00:34:22,449
our Identity team wrote a
really good document on

873
00:34:22,449 --> 00:34:24,280
running a login system with
an account chooser.

874
00:34:24,280 --> 00:34:25,909
It's kind of web-centric.

875
00:34:25,909 --> 00:34:28,800
But the concepts and ideas
are fantastic.

876
00:34:28,800 --> 00:34:30,630
And it's really, really helpful
if you want to think

877
00:34:30,630 --> 00:34:32,460
about this in more detail.

878
00:34:32,460 --> 00:34:34,800
If you're interested in Google+
Sign-In, all of the

879
00:34:34,800 --> 00:34:38,610
documentation is on
developers.google.com/+, and

880
00:34:38,610 --> 00:34:39,780
there's sessions on it today.

881
00:34:39,780 --> 00:34:41,969
We had Android earlier.

882
00:34:41,969 --> 00:34:45,540
IOS at the end of the day
with XT and Silvano.

883
00:34:45,540 --> 00:34:48,710
We've got web with Ade up
next in here, I think.

884
00:34:48,710 --> 00:34:51,260
And then there's a few other
sessions on things like best

885
00:34:51,260 --> 00:34:55,620
practices and how to integrate
throughout the day.

886
00:34:55,620 --> 00:34:57,700
All of the code for this talk,
if you are interested in it,

887
00:34:57,700 --> 00:34:58,690
is on GitHub.

888
00:34:58,690 --> 00:35:01,950
Or it will be as soon as I go
and make the repo public.

889
00:35:01,950 --> 00:35:03,960
And that is at that URL.

890
00:35:03,960 --> 00:35:04,960
And that's about it for me.

891
00:35:04,960 --> 00:35:05,739
Thank you.

892
00:35:05,739 --> 00:35:11,370
[APPLAUSE]

893
00:35:11,370 --> 00:35:12,070
IAN BARBER: Yeah,
so questions.

894
00:35:12,070 --> 00:35:14,850
And as this gentleman has, if
you could come to the mic if

895
00:35:14,850 --> 00:35:16,850
you have questions, just so that
they're on the recording,

896
00:35:16,850 --> 00:35:17,700
that'd be great.

897
00:35:17,700 --> 00:35:18,080
AUDIENCE: Thanks, Ian.

898
00:35:18,080 --> 00:35:19,780
It was a very practical
discussion.

899
00:35:19,780 --> 00:35:21,180
I really appreciate it.

900
00:35:21,180 --> 00:35:22,910
Yesterday, in Tim Bray's talk
in the morning, I saw

901
00:35:22,910 --> 00:35:24,730
something really interesting,
something I didn't really

902
00:35:24,730 --> 00:35:26,470
think you could do.

903
00:35:26,470 --> 00:35:29,380
He logged in to a demo
app that he'd written

904
00:35:29,380 --> 00:35:31,420
in Ruby with Google+.

905
00:35:31,420 --> 00:35:36,305
Then he set a preference, logged
out, and then logged in

906
00:35:36,305 --> 00:35:38,730
to it again with Facebook, and
it recognized that he was the

907
00:35:38,730 --> 00:35:40,500
same person both ways.

908
00:35:40,500 --> 00:35:43,440
And I'm kind of curious can you
give some practical advice

909
00:35:43,440 --> 00:35:45,690
on how to do stuff like that?

910
00:35:45,690 --> 00:35:49,270
IAN BARBER: Tim's actually
just over there.

911
00:35:49,270 --> 00:35:53,440
So I don't know-- how did you
do it in your example?

912
00:35:53,440 --> 00:35:54,634
TIM BRAY: Well, exactly
what you said.

913
00:35:54,634 --> 00:35:58,550
There's a layer of abstraction
in there that auto-merges

914
00:35:58,550 --> 00:36:01,450
these people if it detects
they're the same person.

915
00:36:01,450 --> 00:36:04,631
Now I confess that because this
was a cheap demo app, I

916
00:36:04,631 --> 00:36:05,770
used email.

917
00:36:05,770 --> 00:36:07,570
Which is bad.

918
00:36:07,570 --> 00:36:07,890
IAN BARBER: Yeah.

919
00:36:07,890 --> 00:36:10,490
So yeah, Tim was just saying
that it's exactly

920
00:36:10,490 --> 00:36:11,020
that kind of thing.

921
00:36:11,020 --> 00:36:12,160
He auto-merged people.

922
00:36:12,160 --> 00:36:14,550
And in that case, he used the
email address as the key.

923
00:36:14,550 --> 00:36:17,290
But it's finding an identifier
and using that

924
00:36:17,290 --> 00:36:18,160
to go back and forth.

925
00:36:18,160 --> 00:36:20,830
I think there's a lot of
different ways you can do it.

926
00:36:20,830 --> 00:36:24,030
And though I might say email
address is a problem in some

927
00:36:24,030 --> 00:36:26,540
cases, there are some cases
where you don't actually care

928
00:36:26,540 --> 00:36:28,010
that much, right?

929
00:36:28,010 --> 00:36:31,920
If you just want a lightweight
way, and you're not that

930
00:36:31,920 --> 00:36:33,820
bothered if some other
user gets access to

931
00:36:33,820 --> 00:36:36,020
it, it might be fine.

932
00:36:36,020 --> 00:36:37,990
And there's loads of legitimate
cases for that,

933
00:36:37,990 --> 00:36:39,760
where you do want something
a bit lighter.

934
00:36:39,760 --> 00:36:42,320
So there's always tradeoffs.

935
00:36:42,320 --> 00:36:44,210
There's always what do you want
to do, and what the level

936
00:36:44,210 --> 00:36:46,595
of confidentiality and security
and functionality you

937
00:36:46,595 --> 00:36:47,845
need to provide is.

938
00:36:47,845 --> 00:36:57,770

939
00:36:57,770 --> 00:37:00,130
TIM BRAY: Whereas it's a bad
practice to rely on the email

940
00:37:00,130 --> 00:37:03,670
address, it's also probably not
a good practice to ignore

941
00:37:03,670 --> 00:37:05,800
the case when you happen to
get two that are the same.

942
00:37:05,800 --> 00:37:07,920
A very reasonable course of
action might be something you

943
00:37:07,920 --> 00:37:10,040
suggested to us, which is to pop
up a dialogue, saying, oh,

944
00:37:10,040 --> 00:37:13,500
hey, you're just signing in
as Tim Bray on Facebook.

945
00:37:13,500 --> 00:37:15,490
And I noticed you've been
signing in as Tim Bray as

946
00:37:15,490 --> 00:37:17,260
Google for the last
three weeks.

947
00:37:17,260 --> 00:37:19,400
Would you like to merge these?

948
00:37:19,400 --> 00:37:20,850
That's a very reasonable
course of action.

949
00:37:20,850 --> 00:37:22,500
IAN BARBER: Yeah, absolutely.

950
00:37:22,500 --> 00:37:23,610
That's a really good point.

951
00:37:23,610 --> 00:37:27,660
I think one of the subtleties
that tends to come into it

952
00:37:27,660 --> 00:37:31,770
which when you've got things
like multiple sign-in, is what

953
00:37:31,770 --> 00:37:33,210
do you do when users
kind of forget what

954
00:37:33,210 --> 00:37:34,040
they signed in with?

955
00:37:34,040 --> 00:37:35,540
And so that kind of
case really helps,

956
00:37:35,540 --> 00:37:36,770
if you can go, hmm.

957
00:37:36,770 --> 00:37:38,830
You're a new user, but you
look like this user.

958
00:37:38,830 --> 00:37:39,890
Are you really them?

959
00:37:39,890 --> 00:37:41,830
And then give them the
option to merge.

960
00:37:41,830 --> 00:37:44,900
Luke Wroblewski actually had a
really interesting model he

961
00:37:44,900 --> 00:37:47,750
did where you could start typing
in your email address,

962
00:37:47,750 --> 00:37:50,160
and it would show you which
providers you've signed in

963
00:37:50,160 --> 00:37:52,950
with, which obviously could
be a privacy leak.

964
00:37:52,950 --> 00:37:54,790
So it's something you have to
think about whether that fits

965
00:37:54,790 --> 00:37:55,140
for your app.

966
00:37:55,140 --> 00:37:57,720
But it was a really nice idea
where you could start typing

967
00:37:57,720 --> 00:37:59,630
things in and go, oh
yeah, that's me.

968
00:37:59,630 --> 00:38:02,650
So that they hint which the user
should use if you do have

969
00:38:02,650 --> 00:38:03,900
that situation.

970
00:38:03,900 --> 00:38:06,280

971
00:38:06,280 --> 00:38:07,260
Cool.

972
00:38:07,260 --> 00:38:08,740
Is there any other questions?

973
00:38:08,740 --> 00:38:11,650
Otherwise, I think
that's about it.

974
00:38:11,650 --> 00:38:12,630
OK, thank you very much.

975
00:38:12,630 --> 00:38:14,130
[APPLAUSE]

976
00:38:14,130 --> 00:38:18,728

