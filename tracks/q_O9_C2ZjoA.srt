1
00:00:00,000 --> 00:00:00,445

2
00:00:00,445 --> 00:00:01,870
PAUL IRISH: Well, hello.

3
00:00:01,870 --> 00:00:04,290
My name is Paul Irish, and I
wanted to share some things

4
00:00:04,290 --> 00:00:08,803
with you about performance,
specifically HTML5, CSS3,

5
00:00:08,803 --> 00:00:12,370
DOM-type stuff about
performance, things happening

6
00:00:12,370 --> 00:00:15,900
in the front end, the browser,
things that could be slow and

7
00:00:15,900 --> 00:00:16,920
could be faster.

8
00:00:16,920 --> 00:00:20,595
And so we're going to talk about
these kind of things.

9
00:00:20,595 --> 00:00:23,310
First we're going to talk
about reflows, hardware

10
00:00:23,310 --> 00:00:27,040
accelerated CSS, animation, web
workers, benchmarking, and

11
00:00:27,040 --> 00:00:28,490
a little bit about
build scripts.

12
00:00:28,490 --> 00:00:29,864
Sound good?

13
00:00:29,864 --> 00:00:30,780
Great.

14
00:00:30,780 --> 00:00:38,120
OK reflows, let's just
look at this diagram.

15
00:00:38,120 --> 00:00:40,200
This is a diagram put together
by Stoyan Stefanov.

16
00:00:40,200 --> 00:00:42,970

17
00:00:42,970 --> 00:00:44,490
When we're talking about
reflows, we're talking about

18
00:00:44,490 --> 00:00:45,560
the render tree.

19
00:00:45,560 --> 00:00:46,680
That's the really
important part.

20
00:00:46,680 --> 00:00:49,960
And the render tree
is made from &mdash;

21
00:00:49,960 --> 00:00:51,530
well, it comes from two
different things.

22
00:00:51,530 --> 00:00:53,660
So we have the DOM tree.

23
00:00:53,660 --> 00:00:58,290
The DOM tree is the result after
you tokenize and parse

24
00:00:58,290 --> 00:00:59,950
your HTML markup.

25
00:00:59,950 --> 00:01:00,920
It gets parsed into the DOM.

26
00:01:00,920 --> 00:01:03,340
And that's what you see in
Chrome Developer Tools or

27
00:01:03,340 --> 00:01:05,310
Firebug, all the elements,
right?

28
00:01:05,310 --> 00:01:06,070
Of course.

29
00:01:06,070 --> 00:01:08,050
At the same time, we have
styles coming in.

30
00:01:08,050 --> 00:01:09,660
And so we have styles coming
in from the style

31
00:01:09,660 --> 00:01:10,920
sheets and so on.

32
00:01:10,920 --> 00:01:14,490
And when those two combine,
we get the render tree.

33
00:01:14,490 --> 00:01:17,010
And the difference between the
DOM tree and the render tree

34
00:01:17,010 --> 00:01:20,370
is that the render tree &mdash;

35
00:01:20,370 --> 00:01:23,190
let's say that we have an
element that is display:none.

36
00:01:23,190 --> 00:01:24,880
Not present in the
render tree.

37
00:01:24,880 --> 00:01:26,680
So it's in the DOM tree, but
it's not in the render tree

38
00:01:26,680 --> 00:01:28,130
because we don't see it.

39
00:01:28,130 --> 00:01:29,300
It's just not even there.

40
00:01:29,300 --> 00:01:34,670
Or if we manipulate the window
size or change the font size,

41
00:01:34,670 --> 00:01:38,155
the full-page zoom, that, of
course, changes the render

42
00:01:38,155 --> 00:01:41,885
tree most of the time, whereas
the DOM probably is staying

43
00:01:41,885 --> 00:01:43,280
the exact same.

44
00:01:43,280 --> 00:01:45,435
So the render tree is what
you see, and the DOM

45
00:01:45,435 --> 00:01:48,050
is underneath it.

46
00:01:48,050 --> 00:01:54,070
A reflow is a change that
necessitates a recalculation

47
00:01:54,070 --> 00:01:55,510
of the render tree.

48
00:01:55,510 --> 00:01:58,720
And it might recalculate just
the very bottom of it.

49
00:01:58,720 --> 00:02:01,651
But it might recalculate
the entire thing.

50
00:02:01,651 --> 00:02:04,880
And reflows can be cheap.

51
00:02:04,880 --> 00:02:06,870
But at the same time, they
can be expensive.

52
00:02:06,870 --> 00:02:11,790
Specifically on mobile devices
or old IE, they can be quite

53
00:02:11,790 --> 00:02:14,780
expensive, and you don't
want to do a reflow if

54
00:02:14,780 --> 00:02:15,530
you don't have to.

55
00:02:15,530 --> 00:02:17,100
And there's ways
to avoid them.

56
00:02:17,100 --> 00:02:20,598
So first, well, let
me show you this.

57
00:02:20,598 --> 00:02:23,810

58
00:02:23,810 --> 00:02:25,195
This right here &mdash;

59
00:02:25,195 --> 00:02:26,760
ah, this is so cool.

60
00:02:26,760 --> 00:02:33,420
This is a debug version
of Firefox, I believe.

61
00:02:33,420 --> 00:02:38,180
And it's actually laying out
the mozilla.org homepage,

62
00:02:38,180 --> 00:02:40,310
calculating the layout and the
position of absolutely

63
00:02:40,310 --> 00:02:42,220
everything.

64
00:02:42,220 --> 00:02:44,740
This is awesome.

65
00:02:44,740 --> 00:02:46,560
It figured out where
it all goes.

66
00:02:46,560 --> 00:02:48,680
And then once it's all done and
the browser's figured out

67
00:02:48,680 --> 00:02:50,660
it, there we go.

68
00:02:50,660 --> 00:02:51,525
Pretty cool.

69
00:02:51,525 --> 00:02:54,390
But let me show you this
one part in here.

70
00:02:54,390 --> 00:02:57,320
It's right about here &mdash;

71
00:02:57,320 --> 00:02:58,410
finish off the footer.

72
00:02:58,410 --> 00:03:01,530
And then all of a sudden,
something happens.

73
00:03:01,530 --> 00:03:03,220
And then it has to recalculate
the whole

74
00:03:03,220 --> 00:03:04,750
thing all over again.

75
00:03:04,750 --> 00:03:08,060
And I don't know why
that happened, but

76
00:03:08,060 --> 00:03:09,540
it didn't need to.

77
00:03:09,540 --> 00:03:12,420
And we were basically
done at this point.

78
00:03:12,420 --> 00:03:15,260
And now we have to wait another
30% of our time so

79
00:03:15,260 --> 00:03:17,860
that it can recalculate the
layout of absolutely

80
00:03:17,860 --> 00:03:20,270
everything when it should
have been done.

81
00:03:20,270 --> 00:03:23,280
And so this is the kind of thing
that we want to avoid.

82
00:03:23,280 --> 00:03:27,520
We don't want to have a full
page reflow that invalidates

83
00:03:27,520 --> 00:03:29,380
the entire render tree.

84
00:03:29,380 --> 00:03:33,070
We want to get that finalized
render tree out to the user as

85
00:03:33,070 --> 00:03:38,670
fast as possible so that they
can interact with your DOM.

86
00:03:38,670 --> 00:03:41,980
So what causes reflows?

87
00:03:41,980 --> 00:03:42,900
A lot of people have wondered.

88
00:03:42,900 --> 00:03:46,470
And a lot of people have
thought, well, checking the

89
00:03:46,470 --> 00:03:50,540
element.offsetWidth is
normally the trick.

90
00:03:50,540 --> 00:03:54,490
But Tony G. On the Chrome
team dug into this and

91
00:03:54,490 --> 00:03:55,710
tried to answer it.

92
00:03:55,710 --> 00:04:02,320
So Tony dug in, just opened up
Google Code Search and looked

93
00:04:02,320 --> 00:04:06,780
for Update Layout, Ignore
Pending Style Sheets &mdash;

94
00:04:06,780 --> 00:04:12,800
and this is essentially what
does a reflow in WebKit &mdash;

95
00:04:12,800 --> 00:04:17,800
and found all these items, and
then just listed them out.

96
00:04:17,800 --> 00:04:19,690
So what we get is this.

97
00:04:19,690 --> 00:04:22,770
These are all the properties
and methods that

98
00:04:22,770 --> 00:04:24,990
will cause a reflow.

99
00:04:24,990 --> 00:04:28,780
And so the offsetWidth, which
is kind of the one that most

100
00:04:28,780 --> 00:04:32,350
people know, that's
certainly here.

101
00:04:32,350 --> 00:04:34,110
But there's a lot
of other ones.

102
00:04:34,110 --> 00:04:37,780
And interestingly, innerText
appears to cause a reflow

103
00:04:37,780 --> 00:04:39,966
whereas innerHTML does not.

104
00:04:39,966 --> 00:04:43,060
I'm not exactly sure
about that.

105
00:04:43,060 --> 00:04:47,070
scrollTo on the window does.

106
00:04:47,070 --> 00:04:50,830
So these are all the things
that by calling, you would

107
00:04:50,830 --> 00:04:52,210
trigger a reflow.

108
00:04:52,210 --> 00:04:54,220
But what are the kind of
typical operations

109
00:04:54,220 --> 00:04:56,000
that would do it?

110
00:04:56,000 --> 00:04:59,500
Of course, manipulating the DOM
tree is definitely going

111
00:04:59,500 --> 00:05:01,945
to cause a reflow.

112
00:05:01,945 --> 00:05:04,070
Yeah, definitely.

113
00:05:04,070 --> 00:05:09,250
If you hide a DOM node with
display:none, that will

114
00:05:09,250 --> 00:05:09,830
manipulate the render tree.

115
00:05:09,830 --> 00:05:11,140
It will cause a reflow.

116
00:05:11,140 --> 00:05:14,790
But then any changes to
that element once it's

117
00:05:14,790 --> 00:05:17,180
display:noned won't.

118
00:05:17,180 --> 00:05:22,830
Whereas over with
visibility:hidden, if you just

119
00:05:22,830 --> 00:05:25,850
take an element,
visibility:hidden it, there's

120
00:05:25,850 --> 00:05:28,200
no recalculation of the page.

121
00:05:28,200 --> 00:05:30,200
The geometry of the page
stays the same.

122
00:05:30,200 --> 00:05:31,410
So actually there's no reflow.

123
00:05:31,410 --> 00:05:36,102
We just repaint that one little
box and keep going.

124
00:05:36,102 --> 00:05:38,210
If we're animating anything
across the page, of course

125
00:05:38,210 --> 00:05:39,540
we're doing reflows.

126
00:05:39,540 --> 00:05:44,260
It depends on maybe you could
overflow:hidden it, a

127
00:05:44,260 --> 00:05:48,070
container, so that it's kind of
encapsulated a little bit.

128
00:05:48,070 --> 00:05:51,400
Adding new styles, and then any
sort of user interaction

129
00:05:51,400 --> 00:05:54,460
like resizing the window,
changing the font size, even

130
00:05:54,460 --> 00:05:58,720
scrolling causes reflows.

131
00:05:58,720 --> 00:06:02,940
So here's a little example about
a small optimization

132
00:06:02,940 --> 00:06:06,970
that you could do to avoid
causing excess reflows.

133
00:06:06,970 --> 00:06:10,270
So what we're doing, this is
just some simple little jQuery

134
00:06:10,270 --> 00:06:11,280
code, right?

135
00:06:11,280 --> 00:06:13,220
We are grabbing an element, and
we're just grabbing the

136
00:06:13,220 --> 00:06:15,320
left style property off of it.

137
00:06:15,320 --> 00:06:17,270
And then we're going to take
that left and apply it to

138
00:06:17,270 --> 00:06:18,220
something else.

139
00:06:18,220 --> 00:06:20,760
And then we have to do that
to another one as well.

140
00:06:20,760 --> 00:06:25,750
So we get it here, set it,
get it here, and set it.

141
00:06:25,750 --> 00:06:28,810
The problem here is that
actually checking our style

142
00:06:28,810 --> 00:06:32,197
property is going to trigger
a recalculation of

143
00:06:32,197 --> 00:06:34,450
the styles in a reflow.

144
00:06:34,450 --> 00:06:37,420
And because we set something
here, it has to

145
00:06:37,420 --> 00:06:38,700
do it all over again.

146
00:06:38,700 --> 00:06:43,240
So a way to avoid this is we
can just bunch our gets

147
00:06:43,240 --> 00:06:46,960
together and then our
sets together.

148
00:06:46,960 --> 00:06:47,440
I'll show you.

149
00:06:47,440 --> 00:06:52,000
This is kind of what it looks
like over in the Chrome Dev

150
00:06:52,000 --> 00:06:55,550
Tools Timeline view.

151
00:06:55,550 --> 00:06:56,780
So here we are.

152
00:06:56,780 --> 00:06:57,940
We have Recalculate
Style and Layout.

153
00:06:57,940 --> 00:06:59,570
And these kind of go together.

154
00:06:59,570 --> 00:07:02,090
Recalculate Style is essentially
the prerequisite

155
00:07:02,090 --> 00:07:03,990
for a reflow.

156
00:07:03,990 --> 00:07:05,970
In WebKit and in other
browsers, a

157
00:07:05,970 --> 00:07:08,090
reflow is called a layout.

158
00:07:08,090 --> 00:07:10,740
Mozilla uses the term
"reflow." It's just

159
00:07:10,740 --> 00:07:12,890
terminology really.

160
00:07:12,890 --> 00:07:16,710
What you'll see here is that in
that first example, we kind

161
00:07:16,710 --> 00:07:19,550
of do this thing twice before
we're able to paint out what

162
00:07:19,550 --> 00:07:20,720
the changes are.

163
00:07:20,720 --> 00:07:23,420
Whereas in the second one when
we bunch them together, we can

164
00:07:23,420 --> 00:07:26,270
get away with just doing
a single reflow

165
00:07:26,270 --> 00:07:27,670
before we're all set.

166
00:07:27,670 --> 00:07:29,030
And then we can paint it out.

167
00:07:29,030 --> 00:07:31,830
And I will point out the scale
looks a little weird here.

168
00:07:31,830 --> 00:07:35,060
But we finished the second time
at about 3 milliseconds.

169
00:07:35,060 --> 00:07:39,770
Whereas the first time we
finished maybe about 4 to 4

170
00:07:39,770 --> 00:07:41,520
and a 1/2 milliseconds.

171
00:07:41,520 --> 00:07:45,340
So the third one, in addition
to having less reflows, is

172
00:07:45,340 --> 00:07:46,590
actually indeed faster.

173
00:07:46,590 --> 00:07:49,900

174
00:07:49,900 --> 00:07:53,020
So there's a few strategies
for avoiding reflows.

175
00:07:53,020 --> 00:07:55,020
The first is batching your
DOM changes together

176
00:07:55,020 --> 00:07:57,700
like we just did.

177
00:07:57,700 --> 00:08:00,520
Other ways we can do it is you
can clone the existing

178
00:08:00,520 --> 00:08:06,490
element, work off DOM with
that element, and then &mdash;

179
00:08:06,490 --> 00:08:09,130
because any manipulations while
it's off DOM are not

180
00:08:09,130 --> 00:08:10,260
going to cause a reflow.

181
00:08:10,260 --> 00:08:12,360
And then once you're done
manipulating it, you can

182
00:08:12,360 --> 00:08:14,850
replace that one that was
already there and check the

183
00:08:14,850 --> 00:08:17,110
new one in.

184
00:08:17,110 --> 00:08:19,930
If you hide anything with
display:none, it

185
00:08:19,930 --> 00:08:21,770
will cause a reflow.

186
00:08:21,770 --> 00:08:24,620
But if you then manipulate it,
all those manipulations while

187
00:08:24,620 --> 00:08:29,595
it's display:none will not cause
reflows, except in IE.

188
00:08:29,595 --> 00:08:37,460

189
00:08:37,460 --> 00:08:40,830
However, you can take
an element.

190
00:08:40,830 --> 00:08:42,940
Instead of doing display:none,
you can just take it off DOM,

191
00:08:42,940 --> 00:08:45,530
hold it in documentFragment,
do your manipulations in

192
00:08:45,530 --> 00:08:51,060
documentFragment, and then put
it back in when you're done.

193
00:08:51,060 --> 00:08:56,710
You only get the reflow when
you are manipulating the

194
00:08:56,710 --> 00:08:57,285
actual DOM.

195
00:08:57,285 --> 00:08:58,620
And when things are off
DOM, you're fine.

196
00:08:58,620 --> 00:09:02,970
So that one you're fine in
IE and everywhere else.

197
00:09:02,970 --> 00:09:03,400
Cool?

198
00:09:03,400 --> 00:09:07,460
OK, there's a few more resources
I would like you to

199
00:09:07,460 --> 00:09:09,350
just check out if you're
into this stuff.

200
00:09:09,350 --> 00:09:11,400
Stoyan Stefanov has done
a lot of research

201
00:09:11,400 --> 00:09:13,770
on reflows and repaints.

202
00:09:13,770 --> 00:09:16,140
and so he's got some
great stuff here.

203
00:09:16,140 --> 00:09:21,420
BrowserScope has a few tests to
see what triggers reflows.

204
00:09:21,420 --> 00:09:23,600
Like we were just seeing,
there's a lot of small details

205
00:09:23,600 --> 00:09:25,910
that are different
across browsers.

206
00:09:25,910 --> 00:09:30,030
David Baron had a really great
Google Tech Talk about browser

207
00:09:30,030 --> 00:09:34,320
internals and specifically
aiming that talk at web

208
00:09:34,320 --> 00:09:35,620
developers.

209
00:09:35,620 --> 00:09:38,166
And so this is, I think, an
hour-long talk that you

210
00:09:38,166 --> 00:09:39,070
should check out.

211
00:09:39,070 --> 00:09:44,195
And WebKit, about five years
ago, did a five-part series

212
00:09:44,195 --> 00:09:45,730
about how rendering works.

213
00:09:45,730 --> 00:09:47,020
And it's so cool.

214
00:09:47,020 --> 00:09:48,210
It's from five years ago.

215
00:09:48,210 --> 00:09:49,970
But it's totally
relevant today.

216
00:09:49,970 --> 00:09:53,160
I definitely recommend
checking that out.

217
00:09:53,160 --> 00:09:54,980
OK, I think we're done
with reflow.

218
00:09:54,980 --> 00:09:56,950
Let's move on.

219
00:09:56,950 --> 00:10:00,140
Hardware accelerated
CSS, yeah.

220
00:10:00,140 --> 00:10:02,410
All right, getting into
some sexy here.

221
00:10:02,410 --> 00:10:06,890
So we're just going to skip
right into the demo.

222
00:10:06,890 --> 00:10:11,130
This is Isotope by
David DeSandro.

223
00:10:11,130 --> 00:10:15,530
Let's see, I'm going to change
the sort a little bit.

224
00:10:15,530 --> 00:10:17,560
And then I'm going to insert
some new elements.

225
00:10:17,560 --> 00:10:20,820

226
00:10:20,820 --> 00:10:22,010
Click around here.

227
00:10:22,010 --> 00:10:22,735
Yeah, like this.

228
00:10:22,735 --> 00:10:25,000
This is good.

229
00:10:25,000 --> 00:10:29,490
Even resize the window, and that
responds really nicely.

230
00:10:29,490 --> 00:10:35,420
So what's actually happening
here is that we're actually

231
00:10:35,420 --> 00:10:37,940
using CSS transitions and CSS

232
00:10:37,940 --> 00:10:40,440
transforms to do these changes.

233
00:10:40,440 --> 00:10:42,830
Now, normally you might think
you're going to manipulate the

234
00:10:42,830 --> 00:10:44,380
position of where things go.

235
00:10:44,380 --> 00:10:46,280
And you'll probably be like,
oh, it'll be absolutely

236
00:10:46,280 --> 00:10:47,330
positioned.

237
00:10:47,330 --> 00:10:49,730
And then I'll just manipulate
left and top and tell it where

238
00:10:49,730 --> 00:10:51,160
it's going to go now.

239
00:10:51,160 --> 00:10:53,560
The trick here is that
we're actually using

240
00:10:53,560 --> 00:10:55,610
2D transforms translate.

241
00:10:55,610 --> 00:10:57,760
So we're using
webkit-transform:translate,

242
00:10:57,760 --> 00:11:02,050
and then we're just changing
the x and y of translate.

243
00:11:02,050 --> 00:11:08,380
Then we're also using
a CSS transition.

244
00:11:08,380 --> 00:11:14,300
And as a result, we're able to
get all these operations

245
00:11:14,300 --> 00:11:18,630
hardware accelerated, which
means super-high frame rates,

246
00:11:18,630 --> 00:11:20,780
really high-fidelity animations,
and they look

247
00:11:20,780 --> 00:11:22,070
basically as good as they can.

248
00:11:22,070 --> 00:11:24,910
You're writing it in a
declarative way so that the

249
00:11:24,910 --> 00:11:27,340
browser can be like, oh,
yeah, I got this.

250
00:11:27,340 --> 00:11:27,920
Let me take this.

251
00:11:27,920 --> 00:11:30,625
I'm going to take this down to
my friend the GPU and optimize

252
00:11:30,625 --> 00:11:31,480
this for you.

253
00:11:31,480 --> 00:11:34,880
And so it's going to
look really good.

254
00:11:34,880 --> 00:11:37,990
The cool thing here in Isotope
is that David wrote it in a

255
00:11:37,990 --> 00:11:41,420
way that it can detect support
for transforms and

256
00:11:41,420 --> 00:11:42,190
transitions.

257
00:11:42,190 --> 00:11:44,280
And if there's not support,
then it'll go back to a

258
00:11:44,280 --> 00:11:47,240
jQuery-based animation style.

259
00:11:47,240 --> 00:11:49,700
So if your browser is new and
good, we're going to do the

260
00:11:49,700 --> 00:11:50,570
right thing.

261
00:11:50,570 --> 00:11:55,230
And if it's a bit older, it'll
still look OK, but not as high

262
00:11:55,230 --> 00:11:57,920
fidelity as possible.

263
00:11:57,920 --> 00:12:02,190
So this is kind of the power
of animations of

264
00:12:02,190 --> 00:12:03,440
hardware-accelerated CSS.

265
00:12:03,440 --> 00:12:06,270

266
00:12:06,270 --> 00:12:11,620
Now, those were 2D transforms,
and everything was just moving

267
00:12:11,620 --> 00:12:13,260
around on a 2D plane.

268
00:12:13,260 --> 00:12:18,700
And normally, 2D transforms and
operations on the 2D plane

269
00:12:18,700 --> 00:12:22,070
don't get hardware-accelerated
by browsers and by WebKit

270
00:12:22,070 --> 00:12:24,450
specifically.

271
00:12:24,450 --> 00:12:25,690
But there's a trick.

272
00:12:25,690 --> 00:12:28,380
And there's a trick to make
the browser do it.

273
00:12:28,380 --> 00:12:32,012
Let me show this clip
from Remy Sharp.

274
00:12:32,012 --> 00:12:32,350
[VIDEO PLAYBACK]

275
00:12:32,350 --> 00:12:37,350
-OK what I'm about to show
you is a CSS animation.

276
00:12:37,350 --> 00:12:41,360
And it's engaged using
JavaScript and just the normal

277
00:12:41,360 --> 00:12:42,850
touch gestures.

278
00:12:42,850 --> 00:12:46,940
But the first effect I'm going
to show you now is one without

279
00:12:46,940 --> 00:12:48,950
a 3D transform.

280
00:12:48,950 --> 00:12:53,010
So this is just doing a scale
and nothing else.

281
00:12:53,010 --> 00:12:54,445
And you see it's just
a little bit jumpy.

282
00:12:54,445 --> 00:12:57,870
That's the actual animation
jumping.

283
00:12:57,870 --> 00:13:01,550
And if I show you the same
version but just with the

284
00:13:01,550 --> 00:13:05,060
translate3d set on the element
that I'm zooming, you can see

285
00:13:05,060 --> 00:13:06,750
it's completely smooth.

286
00:13:06,750 --> 00:13:09,070
And all I've done is
said the image &mdash;

287
00:13:09,070 --> 00:13:12,000
so the image element that I'm
pinching and zooming on, I've

288
00:13:12,000 --> 00:13:14,725
just added a CSS property
to say translate 3D.

289
00:13:14,725 --> 00:13:15,410
[END VIDEO PLAYBACK]

290
00:13:15,410 --> 00:13:19,410
Yeah, so that's it.

291
00:13:19,410 --> 00:13:21,440
It's kind of a total hack.

292
00:13:21,440 --> 00:13:26,220
You can use either WebKit
transform, translateZ(0) or do

293
00:13:26,220 --> 00:13:27,160
translate3d.

294
00:13:27,160 --> 00:13:29,930
Depending on your use case, one
will probably make more

295
00:13:29,930 --> 00:13:31,180
sense for you.

296
00:13:31,180 --> 00:13:33,170

297
00:13:33,170 --> 00:13:36,450
And all of a sudden, the
browser's like, oh, cool.

298
00:13:36,450 --> 00:13:39,990
Let's throw this on the GPU.

299
00:13:39,990 --> 00:13:43,280
And as a result, we can get
much higher-fidelity

300
00:13:43,280 --> 00:13:46,535
manipulation on the 2D
plane, just like

301
00:13:46,535 --> 00:13:47,265
we saw in this video.

302
00:13:47,265 --> 00:13:49,860
It's pretty cool.

303
00:13:49,860 --> 00:13:53,460
There's a few really good ways
when you're working with this

304
00:13:53,460 --> 00:13:55,530
kind of stuff to debug it
a little bit better.

305
00:13:55,530 --> 00:14:01,360
Over in Safari, there's a
development flag to turn on

306
00:14:01,360 --> 00:14:02,010
some colors.

307
00:14:02,010 --> 00:14:04,450
This actually stands
for core animation.

308
00:14:04,450 --> 00:14:09,956
I'm going to load this up over
the iPhone simulator.

309
00:14:09,956 --> 00:14:12,090
And I'm actually going
to load this page.

310
00:14:12,090 --> 00:14:16,950
This is a tutorial on HTML5Rocks
by Malte Ubl.

311
00:14:16,950 --> 00:14:19,520
And we're going to show
this little demo here.

312
00:14:19,520 --> 00:14:22,220
And what we're actually doing is
we're detecting support for

313
00:14:22,220 --> 00:14:23,630
CSS transitions and
transforms.

314
00:14:23,630 --> 00:14:27,810
And if we have support, we're
just going to use a transform

315
00:14:27,810 --> 00:14:28,670
along with the transition.

316
00:14:28,670 --> 00:14:30,200
Otherwise, we use
jQuery animate.

317
00:14:30,200 --> 00:14:34,210
So here in Chrome, we're using
a transition transform.

318
00:14:34,210 --> 00:14:37,250
And you see that moves
across the screen.

319
00:14:37,250 --> 00:14:42,050
I'm going to show this in
the iPhone simulator.

320
00:14:42,050 --> 00:14:46,090
You can see the OS
is accelerated.

321
00:14:46,090 --> 00:14:48,730

322
00:14:48,730 --> 00:14:51,160
Scroll down, here we go.

323
00:14:51,160 --> 00:14:52,455
So I'm just going to click.

324
00:14:52,455 --> 00:14:53,760
And you'll see &mdash; yeah.

325
00:14:53,760 --> 00:14:58,275

326
00:14:58,275 --> 00:15:02,320
And the trick here is that
we actually use that

327
00:15:02,320 --> 00:15:04,210
translateZ(0) &mdash;

328
00:15:04,210 --> 00:15:07,400
we call it the silver
bullet here &mdash;

329
00:15:07,400 --> 00:15:13,288
trick to make that hardware
acceleration happen.

330
00:15:13,288 --> 00:15:15,980

331
00:15:15,980 --> 00:15:19,990
Over in Chrome, we have a
somewhat similar thing.

332
00:15:19,990 --> 00:15:22,480
Over in about:flags, we
have this setting.

333
00:15:22,480 --> 00:15:24,340
And let me bring this up.

334
00:15:24,340 --> 00:15:27,550
In about:flags, there's a bunch
of really crazy stuff.

335
00:15:27,550 --> 00:15:29,775
I recommend you dig into
this some time.

336
00:15:29,775 --> 00:15:32,760
We have composited render
layer borders.

337
00:15:32,760 --> 00:15:36,100
And well, let me just show
you what it does.

338
00:15:36,100 --> 00:15:39,980
Here's this presentation that
we've been looking at but with

339
00:15:39,980 --> 00:15:43,370
this setting turned on.

340
00:15:43,370 --> 00:15:47,030
And you can see we get borders
around of all the layers that

341
00:15:47,030 --> 00:15:49,580
are composited.

342
00:15:49,580 --> 00:15:52,450
Pretty cool.

343
00:15:52,450 --> 00:15:55,430
So this helps a lot to just
verify that yes, this actually

344
00:15:55,430 --> 00:15:58,690
is being composited
on the GPU.

345
00:15:58,690 --> 00:16:02,360
And then also in this 3D case,
we have a nice little debug

346
00:16:02,360 --> 00:16:04,750
view of what's going on.

347
00:16:04,750 --> 00:16:08,320
I will point out that this
used to happen as a

348
00:16:08,320 --> 00:16:10,000
command line flag.

349
00:16:10,000 --> 00:16:12,300
So it didn't used to be nice and
handy in this about:flags.

350
00:16:12,300 --> 00:16:16,040
But yes, it used to have to run
the Chrome executable with

351
00:16:16,040 --> 00:16:17,060
a command line flag.

352
00:16:17,060 --> 00:16:20,670
And this page over on Peter
Beverloo's site maintains a

353
00:16:20,670 --> 00:16:25,440
list of all the active command
line switches or flags.

354
00:16:25,440 --> 00:16:27,700
And so I recommend you
checking this out.

355
00:16:27,700 --> 00:16:31,190
One of the ones in here
is a show-paint-rects.

356
00:16:31,190 --> 00:16:34,590
And so this actually draws
little borders whenever a

357
00:16:34,590 --> 00:16:38,840
section of the DOM
gets repainted.

358
00:16:38,840 --> 00:16:40,980
Why that's interesting is
because you want to know &mdash;

359
00:16:40,980 --> 00:16:42,790
kind of when we were talking
about reflows, you want to

360
00:16:42,790 --> 00:16:46,100
know exactly how much of the
DOM is being invalidated or

361
00:16:46,100 --> 00:16:48,040
the render tree is
being invalidated

362
00:16:48,040 --> 00:16:49,140
when there's a change.

363
00:16:49,140 --> 00:16:52,030
And so with show-paint-rects,
you can see that when you make

364
00:16:52,030 --> 00:16:55,730
a change, only the part that
needs to be recalculated and

365
00:16:55,730 --> 00:16:58,580
repainted is being changed
rather than a much larger

366
00:16:58,580 --> 00:17:00,670
chunk, which would be
kind of unexpected.

367
00:17:00,670 --> 00:17:05,950
So show-paint-rects is another
very helpful flag to use when

368
00:17:05,950 --> 00:17:08,690
you're debugging some of this
advanced rendering stuff.

369
00:17:08,690 --> 00:17:19,220

370
00:17:19,220 --> 00:17:24,990
This tutorial has a number of
other recommendations around

371
00:17:24,990 --> 00:17:29,450
graphics optimizations that
you can make and also digs

372
00:17:29,450 --> 00:17:30,850
into JavaScript profiling.

373
00:17:30,850 --> 00:17:33,800
So dig into that a little bit
more if you're looking to eek

374
00:17:33,800 --> 00:17:36,410
out some better performance of
your HTML5 app and these

375
00:17:36,410 --> 00:17:39,850
recommendations are not
good enough for you.

376
00:17:39,850 --> 00:17:42,780
But next we're going to dig into
requestAnimationFrame.

377
00:17:42,780 --> 00:17:48,510
So requestAnimationFrame
basically came about because

378
00:17:48,510 --> 00:17:53,080
browsers were like, hey, we
know that you're doing

379
00:17:53,080 --> 00:17:54,650
animation in the browser.

380
00:17:54,650 --> 00:17:57,580
And we know that you're just
abusing setTimeout and

381
00:17:57,580 --> 00:18:00,100
setInterval loops to do it.

382
00:18:00,100 --> 00:18:03,882
And that's not cool.

383
00:18:03,882 --> 00:18:05,380
It's not really cool.

384
00:18:05,380 --> 00:18:05,930
Because you know what?

385
00:18:05,930 --> 00:18:10,160
A browser can optimize animation
better than you

386
00:18:10,160 --> 00:18:14,080
writing a setInterval loop, just
trying to peg the CPU as

387
00:18:14,080 --> 00:18:15,980
fast as it will go.

388
00:18:15,980 --> 00:18:17,490
Browser is smarter.

389
00:18:17,490 --> 00:18:22,120
So one of the things that it can
do is it can batch things

390
00:18:22,120 --> 00:18:24,450
into a single reflow
and repaint cycle.

391
00:18:24,450 --> 00:18:29,215
So let's say that you had a
JavaScript-based animation.

392
00:18:29,215 --> 00:18:31,180
You had an absolute position
element, and you're updating

393
00:18:31,180 --> 00:18:34,450
the left and top or something
like that.

394
00:18:34,450 --> 00:18:36,750
The browser can now synchronize
that along with

395
00:18:36,750 --> 00:18:38,950
the concurrently running
CSS transition.

396
00:18:38,950 --> 00:18:42,060
Or if you had some SVG SMIL
animation running at the same

397
00:18:42,060 --> 00:18:44,575
time, it can kind of make sure
that those are all going at

398
00:18:44,575 --> 00:18:47,130
the same time.

399
00:18:47,130 --> 00:18:51,430
It's going to optimize it for 60
frames per second, which is

400
00:18:51,430 --> 00:18:54,160
the refresh rate of
most displays.

401
00:18:54,160 --> 00:18:56,130
And so you're going to get the
best frame rate possible.

402
00:18:56,130 --> 00:19:01,470
60 Hertz is kind of the perfect
target for everything

403
00:19:01,470 --> 00:19:03,340
that you want going
on in the browser.

404
00:19:03,340 --> 00:19:07,470
And the really cool thing is
that you're really friendly to

405
00:19:07,470 --> 00:19:11,280
your users' batteries.

406
00:19:11,280 --> 00:19:17,280
Because what happens is that if
the tab is not visible, it

407
00:19:17,280 --> 00:19:18,530
gets skipped.

408
00:19:18,530 --> 00:19:21,280
So let me load this
up right here.

409
00:19:21,280 --> 00:19:23,610
This is a &mdash;

410
00:19:23,610 --> 00:19:24,860
whoa!

411
00:19:24,860 --> 00:19:31,765

412
00:19:31,765 --> 00:19:33,140
Yeah, OK, here we go.

413
00:19:33,140 --> 00:19:36,540
So we got this WebGL demo.

414
00:19:36,540 --> 00:19:41,380
And you see here we got a lot
of action over on the GPU.

415
00:19:41,380 --> 00:19:44,890
And this is the JavaScript
running inside this page.

416
00:19:44,890 --> 00:19:48,150
It's pretty heavy.

417
00:19:48,150 --> 00:19:49,790
Gonna move this around.

418
00:19:49,790 --> 00:19:51,420
Now I'm just going to switch
to another tab.

419
00:19:51,420 --> 00:19:54,030

420
00:19:54,030 --> 00:19:55,280
You see that instantly
dropped.

421
00:19:55,280 --> 00:20:00,360

422
00:20:00,360 --> 00:20:01,890
Because the
requestAnimationFrame is being

423
00:20:01,890 --> 00:20:05,155
used, the browser is like,
hey, you're not even

424
00:20:05,155 --> 00:20:06,060
viewing this tab.

425
00:20:06,060 --> 00:20:10,140
We don't need to be wasting the
browser, the CPU, the GPU

426
00:20:10,140 --> 00:20:13,330
in order to make this happen
because we know that they're

427
00:20:13,330 --> 00:20:13,960
not looking at it.

428
00:20:13,960 --> 00:20:19,870
Whereas if this field demo had
been using a timer loop, it'd

429
00:20:19,870 --> 00:20:20,260
still be going.

430
00:20:20,260 --> 00:20:23,310
It would still be eating
down my battery here.

431
00:20:23,310 --> 00:20:26,780
So I bring that back up.

432
00:20:26,780 --> 00:20:36,740
And our use of the
CPU returns.

433
00:20:36,740 --> 00:20:39,690
So if you're doing any
sort of animation,

434
00:20:39,690 --> 00:20:40,810
use this if you can.

435
00:20:40,810 --> 00:20:43,000
This actually just
landed in jQuery.

436
00:20:43,000 --> 00:20:45,050
So this is going to
be in jQuery 1.6.

437
00:20:45,050 --> 00:20:46,800
And it's also in Grit.

438
00:20:46,800 --> 00:20:51,610
And it's in a few other
libraries at this point.

439
00:20:51,610 --> 00:20:53,010
So I definitely recommend it.

440
00:20:53,010 --> 00:20:56,380
This is available in both
Chrome and also in

441
00:20:56,380 --> 00:20:59,380
Firefox, Firefox 4.

442
00:20:59,380 --> 00:21:06,450
Over on my blog, we have a
nice little shim layer to

443
00:21:06,450 --> 00:21:07,010
handle this.

444
00:21:07,010 --> 00:21:09,690
We basically feature detect
to see if the

445
00:21:09,690 --> 00:21:10,900
native support is present.

446
00:21:10,900 --> 00:21:14,280
And if not, we're going to use
a setTimeout loop that

447
00:21:14,280 --> 00:21:16,510
optimizes for 60 frames
per second.

448
00:21:16,510 --> 00:21:19,400
And that's how you use it.

449
00:21:19,400 --> 00:21:22,170

450
00:21:22,170 --> 00:21:23,380
Cool.

451
00:21:23,380 --> 00:21:26,360
Web Workers, the idea here &mdash;

452
00:21:26,360 --> 00:21:28,090
and I don't want to cover
this too much.

453
00:21:28,090 --> 00:21:30,560
The idea with Web Workers that
you're probably familiar with

454
00:21:30,560 --> 00:21:35,190
is we want to move heavy
computation, expensive tasks

455
00:21:35,190 --> 00:21:37,110
outside of the UI thread.

456
00:21:37,110 --> 00:21:39,180
Pretty much all JavaScript
runs in the UI thread.

457
00:21:39,180 --> 00:21:42,390
And if something is taking a
long time, the user can't

458
00:21:42,390 --> 00:21:43,180
interact with the page.

459
00:21:43,180 --> 00:21:44,780
The page becomes
non-responsive.

460
00:21:44,780 --> 00:21:49,080
And in the case of Chrome, we
get a sad, freezing cold tab.

461
00:21:49,080 --> 00:21:50,940
He's so cold.

462
00:21:50,940 --> 00:21:51,910
And we don't want that.

463
00:21:51,910 --> 00:21:54,105
No, that's bad.

464
00:21:54,105 --> 00:21:55,030
And we want to avoid that.

465
00:21:55,030 --> 00:21:57,020
And without Web Workers,
we can.

466
00:21:57,020 --> 00:22:00,290

467
00:22:00,290 --> 00:22:00,800
I'm going to show this.

468
00:22:00,800 --> 00:22:02,960
This is a little bit more
advanced use of Web Worker.

469
00:22:02,960 --> 00:22:05,780
But I think it's really cool.

470
00:22:05,780 --> 00:22:09,970
First, normally the way that
you instantiate a brand-new

471
00:22:09,970 --> 00:22:12,950
Web Worker is you would
be like, new Worker,

472
00:22:12,950 --> 00:22:16,980
myworker.js, there.

473
00:22:16,980 --> 00:22:19,750
This is where the code
is going now.

474
00:22:19,750 --> 00:22:21,340
You pass it a file name.

475
00:22:21,340 --> 00:22:23,020
And then it goes and
gets that file.

476
00:22:23,020 --> 00:22:24,310
And then it uses that file.

477
00:22:24,310 --> 00:22:26,380
And that's your worker.

478
00:22:26,380 --> 00:22:28,710
It has its limitations.

479
00:22:28,710 --> 00:22:32,050
This here is an example
of creating a

480
00:22:32,050 --> 00:22:34,300
worker on the fly, basically.

481
00:22:34,300 --> 00:22:36,550
So here we have &mdash; oops &mdash;

482
00:22:36,550 --> 00:22:39,210
our worker code, and it's
a script of type worker.

483
00:22:39,210 --> 00:22:41,950
So this is going to get skipped
by the browser.

484
00:22:41,950 --> 00:22:45,130
So we're just kind of using it
to hold some text right now.

485
00:22:45,130 --> 00:22:47,650
And then down here on our
script, we're going to

486
00:22:47,650 --> 00:22:48,860
use the file API.

487
00:22:48,860 --> 00:22:51,190
And we're going to use
BlobBuilder, create a new

488
00:22:51,190 --> 00:22:52,230
BlobBuilder.

489
00:22:52,230 --> 00:22:55,820
Then we're going to grab the
text of this script node,

490
00:22:55,820 --> 00:22:57,490
throw that into the blob.

491
00:22:57,490 --> 00:23:00,220
And then when we create our
worker, we're going to use

492
00:23:00,220 --> 00:23:04,940
URL.createobject URL with the
blob, and check that in.

493
00:23:04,940 --> 00:23:07,870
Essentially, we create a file
on the fly and then

494
00:23:07,870 --> 00:23:09,500
instantiate the worker
with that.

495
00:23:09,500 --> 00:23:11,840
And so now we have the advantage
of having a little

496
00:23:11,840 --> 00:23:14,490
bit more control over the worker
in case we want to

497
00:23:14,490 --> 00:23:16,780
change it or something
like that.

498
00:23:16,780 --> 00:23:19,260
And then also we avoid
an HTTP run trip.

499
00:23:19,260 --> 00:23:24,600
So from a network layer,
we're a little bit more

500
00:23:24,600 --> 00:23:25,850
optimized as well.

501
00:23:25,850 --> 00:23:29,020
So that is just kind of a cool
example of where you can go

502
00:23:29,020 --> 00:23:32,470
with workers combined
with the file API.

503
00:23:32,470 --> 00:23:35,480
Some places where you might
want to use workers, text

504
00:23:35,480 --> 00:23:38,460
formatting of a long document,
syntax highlighting maybe,

505
00:23:38,460 --> 00:23:42,460
maybe not, depends
on your use case.

506
00:23:42,460 --> 00:23:46,600
If you're doing heavy image
processing or dealing with

507
00:23:46,600 --> 00:23:50,520
large arrays, also the audio
API, for instance, the WebKit

508
00:23:50,520 --> 00:23:55,630
Web Audio API or the Mozilla
Audio Data API, depending on

509
00:23:55,630 --> 00:23:57,540
kind of the analysis that you're
running, a worker might

510
00:23:57,540 --> 00:23:58,640
make sense.

511
00:23:58,640 --> 00:24:01,100
Also, the FileSystem API, which
is available in Chrome,

512
00:24:01,100 --> 00:24:04,390
has had support for workers
for a while now.

513
00:24:04,390 --> 00:24:05,180
And this is really good.

514
00:24:05,180 --> 00:24:07,450
You might be dealing with large
binary data, and you

515
00:24:07,450 --> 00:24:09,170
don't want that holding up
the UI thread at all.

516
00:24:09,170 --> 00:24:12,300
You want to just let that
happen as it does.

517
00:24:12,300 --> 00:24:15,130
And so letting Web Workers
handle the interaction with

518
00:24:15,130 --> 00:24:18,440
the file system is the right
way to go there.

519
00:24:18,440 --> 00:24:20,760
Cool.

520
00:24:20,760 --> 00:24:24,282
Want to touch on JSPERF
real quick.

521
00:24:24,282 --> 00:24:25,245
Yeah, this is real cool.

522
00:24:25,245 --> 00:24:30,100
So JSPERF, if you don't
know, is a site

523
00:24:30,100 --> 00:24:31,900
for performance tests.

524
00:24:31,900 --> 00:24:33,620
And so we have a few things
going on here.

525
00:24:33,620 --> 00:24:36,580
We have a nice human
readable URL.

526
00:24:36,580 --> 00:24:41,030
And oftentimes, with a URL like
join-concat, this is now

527
00:24:41,030 --> 00:24:44,930
the definitive join versus
concat string

528
00:24:44,930 --> 00:24:46,400
concatenation test.

529
00:24:46,400 --> 00:24:48,670
And there's revisions as well.

530
00:24:48,670 --> 00:24:52,000
So within the page we have our
variations of the code that we

531
00:24:52,000 --> 00:24:52,870
want to test.

532
00:24:52,870 --> 00:24:56,840
So this is the age-old
concatenation with plus equals

533
00:24:56,840 --> 00:24:59,340
or array.join, which
is faster.

534
00:24:59,340 --> 00:25:03,440
And I believe it's IE 6 and 7
are faster with the array

535
00:25:03,440 --> 00:25:06,330
join, and absolutely everyone
else is faster with a

536
00:25:06,330 --> 00:25:10,140
straight-up concatenation
augmented in a string.

537
00:25:10,140 --> 00:25:15,170
So don't use a array.join
anymore.

538
00:25:15,170 --> 00:25:19,340
But the nice thing here is that
we can run the test and

539
00:25:19,340 --> 00:25:21,890
get our results and figure
out kind of what it is.

540
00:25:21,890 --> 00:25:25,340
And so the site is used
by a lot of people.

541
00:25:25,340 --> 00:25:27,950
In fact, jQuery has been
using it for the

542
00:25:27,950 --> 00:25:30,540
library development recently.

543
00:25:30,540 --> 00:25:32,200
So let's say there's
a few different

544
00:25:32,200 --> 00:25:34,510
variations of DOM traversal.

545
00:25:34,510 --> 00:25:37,570
The nice thing here is that we
can do our tests with a few

546
00:25:37,570 --> 00:25:40,760
variations, kind of see what's
going on, and then the results

547
00:25:40,760 --> 00:25:44,490
get reported to BrowserScope,
which kind of handles what

548
00:25:44,490 --> 00:25:47,330
user agent it's coming from,
what are the numbers, and kind

549
00:25:47,330 --> 00:25:50,890
of give us a really
comprehensive table of what

550
00:25:50,890 --> 00:25:53,760
the story is across all browsers
and where is each

551
00:25:53,760 --> 00:25:56,400
thing faster.

552
00:25:56,400 --> 00:25:58,390
And so I'm running it here.

553
00:25:58,390 --> 00:26:00,440
This is WebKit Nightly.

554
00:26:00,440 --> 00:26:03,590
And we see, well, in this case,
we have these traversal,

555
00:26:03,590 --> 00:26:06,090
and we have some different
results.

556
00:26:06,090 --> 00:26:09,200

557
00:26:09,200 --> 00:26:11,690
So JSPERF is really good.

558
00:26:11,690 --> 00:26:15,700
I like it a lot because it's
kind of like the clearinghouse

559
00:26:15,700 --> 00:26:18,870
of performance best practices.

560
00:26:18,870 --> 00:26:22,200
People will say, oh, well, you
should use triple equals

561
00:26:22,200 --> 00:26:26,040
instead of double equals
because it's faster.

562
00:26:26,040 --> 00:26:28,280
And now we can actually find
out, hey, are they right?

563
00:26:28,280 --> 00:26:31,220
And are they right across
all browsers or not?

564
00:26:31,220 --> 00:26:35,760
It's powered by benchmark.js,
which is a very finely tuned

565
00:26:35,760 --> 00:26:39,145
and calibrated benchmarking
script that works not only in

566
00:26:39,145 --> 00:26:43,300
the browser but in Node and
Narwhal and Ringo and all

567
00:26:43,300 --> 00:26:45,830
these different environments
and is definitely the right

568
00:26:45,830 --> 00:26:49,000
way to be benchmarking different
variations of code.

569
00:26:49,000 --> 00:26:52,360

570
00:26:52,360 --> 00:26:55,720
So a quick touch on the
HTML5 Boilerplate.

571
00:26:55,720 --> 00:26:59,040
It's a project that
I work with.

572
00:26:59,040 --> 00:27:03,090
And recently, we put
out a build tool.

573
00:27:03,090 --> 00:27:05,515
The build script is just
an Ant script.

574
00:27:05,515 --> 00:27:08,290
But the cool thing is that when
you use it alongside one

575
00:27:08,290 --> 00:27:10,160
of the web server
configurations, like for

576
00:27:10,160 --> 00:27:15,830
Apache or Nginx, you're
basically going to get a 90%

577
00:27:15,830 --> 00:27:21,840
on your score for Google
PageSpeed or YSlow.

578
00:27:21,840 --> 00:27:23,860
There's all these things
that you've heard.

579
00:27:23,860 --> 00:27:25,470
And you're supposed to be
doing like combining and

580
00:27:25,470 --> 00:27:27,270
minifying your JavaScript,
your CSS, your image

581
00:27:27,270 --> 00:27:29,430
optimization.

582
00:27:29,430 --> 00:27:30,620
And the script does
all these things.

583
00:27:30,620 --> 00:27:33,050
It also does HTML
minification.

584
00:27:33,050 --> 00:27:36,220
It revs your file names so that
we can cachebust when

585
00:27:36,220 --> 00:27:37,350
there's a new version.

586
00:27:37,350 --> 00:27:40,080
And then we upgrade the web
server configuration to use

587
00:27:40,080 --> 00:27:43,630
far Future and Expires headers
because now we have unique

588
00:27:43,630 --> 00:27:46,060
file names.

589
00:27:46,060 --> 00:27:48,410
So it does all these
things for you.

590
00:27:48,410 --> 00:27:55,360
And we can basically take what
was a C and B grade website

591
00:27:55,360 --> 00:27:59,180
and bring it up to some
much higher scores.

592
00:27:59,180 --> 00:28:04,900
So I definitely recommend you
dig into that if you'd like to

593
00:28:04,900 --> 00:28:08,600
not have to repeat all these
performance optimizations

594
00:28:08,600 --> 00:28:10,060
every time you make a site.

595
00:28:10,060 --> 00:28:14,520
And let a script handle
it for you.

596
00:28:14,520 --> 00:28:17,216
All right, I guess
that's it for me.

597
00:28:17,216 --> 00:28:21,180
If you have any questions, you
can leave a comment or hit me

598
00:28:21,180 --> 00:28:22,200
up on Twitter.

599
00:28:22,200 --> 00:28:26,500
I'd also recommend to check
out html5rocks.com.

600
00:28:26,500 --> 00:28:29,190
We have a lot of tutorials on
there of really good stuff.

601
00:28:29,190 --> 00:28:31,710
And we have a lot that are
focused on performance and a

602
00:28:31,710 --> 00:28:34,340
lot of the things that I've been
talking about here, so

603
00:28:34,340 --> 00:28:36,870
plenty more to read
and learn there.

604
00:28:36,870 --> 00:28:38,130
So I guess that's it.

605
00:28:38,130 --> 00:28:39,380
Thank you very much
for watching.

606
00:28:39,380 --> 00:28:40,050

