1
00:00:00,000 --> 00:00:00,500

2
00:00:00,500 --> 00:00:02,750
JAKE ARCHIBALD: So back
in 1995, JavaScript

3
00:00:02,750 --> 00:00:04,500
was created by Brendan Eich.

4
00:00:04,500 --> 00:00:08,109
And he did it in 10 days, which
is pretty crazy, that it's

5
00:00:08,109 --> 00:00:10,320
what most of the
web is built of now.

6
00:00:10,320 --> 00:00:13,250
JavaScript is 18
years old now, so it's

7
00:00:13,250 --> 00:00:15,740
legal to drink in
some countries.

8
00:00:15,740 --> 00:00:18,670
It's also on Twitter,
saying that they

9
00:00:18,670 --> 00:00:22,050
think they've seen JavaScript
drunk many years ago,

10
00:00:22,050 --> 00:00:25,100
a lot of the time
quite like that.

11
00:00:25,100 --> 00:00:29,010
But in 2010, another team set
about making a new language.

12
00:00:29,010 --> 00:00:31,010
And from what we know
now of the web-- we

13
00:00:31,010 --> 00:00:34,430
know how the whole web is put
together and the kind of tools

14
00:00:34,430 --> 00:00:35,060
we need.

15
00:00:35,060 --> 00:00:36,726
And that team is the
Dart team, and here

16
00:00:36,726 --> 00:00:38,610
to talk about it--
big warm welcome

17
00:00:38,610 --> 00:00:40,300
to Seth Ladd and Kasper Lund.

18
00:00:40,300 --> 00:00:45,090

19
00:00:45,090 --> 00:00:46,050
SETH LADD: Thanks Jake.

20
00:00:46,050 --> 00:00:47,950
So we won't be
playing the Kenny G.

21
00:00:47,950 --> 00:00:49,740
We don't want you
guys to fall asleep.

22
00:00:49,740 --> 00:00:52,095
This is Dart for the
modern web developer.

23
00:00:52,095 --> 00:00:52,970
My name is Seth Ladd.

24
00:00:52,970 --> 00:00:55,262
I'm a developer advocate with
the Chrome and Dart team.

25
00:00:55,262 --> 00:00:56,636
KASPER LUND: And
I'm Kasper Lund.

26
00:00:56,636 --> 00:00:58,080
I'm an engineer here at Google.

27
00:00:58,080 --> 00:01:00,580
I work as a tech lead
on the Dart platform.

28
00:01:00,580 --> 00:01:03,160
And before I ventured
into Dart territory,

29
00:01:03,160 --> 00:01:06,490
I spent a lot of
years on optimizing V8

30
00:01:06,490 --> 00:01:09,067
and the optimizing
compiler in there.

31
00:01:09,067 --> 00:01:09,650
SETH LADD: OK.

32
00:01:09,650 --> 00:01:11,990
So many of you know
Dart as a language.

33
00:01:11,990 --> 00:01:14,879
And sure it's a structured,
scalable, familiar language,

34
00:01:14,879 --> 00:01:17,420
but it's also-- I like to think
of it as a batteries included

35
00:01:17,420 --> 00:01:17,940
platform.

36
00:01:17,940 --> 00:01:20,860
There's a great core set
of libraries-- things

37
00:01:20,860 --> 00:01:23,210
like collections, things like
asynchronous programming,

38
00:01:23,210 --> 00:01:25,580
futures, streams,
things like numbers,

39
00:01:25,580 --> 00:01:27,540
booleans, dates, times.

40
00:01:27,540 --> 00:01:29,710
We also ship a collection
of productive tools--

41
00:01:29,710 --> 00:01:33,730
a Dart Editor, an analyzer to
give you warnings and errors,

42
00:01:33,730 --> 00:01:36,390
a package manager we
affectionately call Pub,

43
00:01:36,390 --> 00:01:38,100
because you play darts in a pub.

44
00:01:38,100 --> 00:01:41,250
We also ship a virtual machine
which runs Dart code natively.

45
00:01:41,250 --> 00:01:44,320
You can run that VM on a
command line or on the server,

46
00:01:44,320 --> 00:01:46,790
and you can also embed
it in client browsers.

47
00:01:46,790 --> 00:01:49,130
But probably most
importantly, we

48
00:01:49,130 --> 00:01:51,000
ship a Compiler to JavaScript.

49
00:01:51,000 --> 00:01:53,100
So the Dart code
you see here today,

50
00:01:53,100 --> 00:01:54,860
and the Dart apps that
you'll be writing,

51
00:01:54,860 --> 00:01:57,250
you can compile that down
to essentially ECMAScript

52
00:01:57,250 --> 00:02:02,734
5, and run it across modern
browsers, desktop and laptop.

53
00:02:02,734 --> 00:02:04,900
You might have heard recently,
we launched Dart 1.0.

54
00:02:04,900 --> 00:02:06,941
It was a big milestone
for us, hopefully exciting

55
00:02:06,941 --> 00:02:07,730
for you guys.

56
00:02:07,730 --> 00:02:09,120
The big point of this, really--

57
00:02:09,120 --> 00:02:09,620
[APPLAUSE]

58
00:02:09,620 --> 00:02:10,495
SETH LADD: Thank you.

59
00:02:10,495 --> 00:02:13,430

60
00:02:13,430 --> 00:02:15,210
The journey starts
here, really, for us.

61
00:02:15,210 --> 00:02:17,400
The big point here,
the big take away,

62
00:02:17,400 --> 00:02:20,110
is it's now stability
you can count on.

63
00:02:20,110 --> 00:02:22,340
We've been open source
since about October 2011,

64
00:02:22,340 --> 00:02:25,190
and gotten tons of feedback
from internal developers,

65
00:02:25,190 --> 00:02:27,730
external developers,
hackathons, code labs.

66
00:02:27,730 --> 00:02:29,750
And we've collected
that all and launched

67
00:02:29,750 --> 00:02:32,730
what is now a stable language,
stable core libraries for you

68
00:02:32,730 --> 00:02:34,520
to build production apps on.

69
00:02:34,520 --> 00:02:36,880
So now is the right
time to try it.

70
00:02:36,880 --> 00:02:37,380
OK.

71
00:02:37,380 --> 00:02:39,850
So when I said you
can use Dart today,

72
00:02:39,850 --> 00:02:42,619
I think I actually mean you can
use Dart like in the next hour.

73
00:02:42,619 --> 00:02:45,160
So we're going to do a lightning
tour of the syntax structure

74
00:02:45,160 --> 00:02:47,480
and semantics to show
you how familiar and easy

75
00:02:47,480 --> 00:02:49,460
it is to get started.

76
00:02:49,460 --> 00:02:52,320
So Dart, by design,
is very easy to learn.

77
00:02:52,320 --> 00:02:53,160
We have semi-colons.

78
00:02:53,160 --> 00:02:54,370
We have curly braces.

79
00:02:54,370 --> 00:02:56,904
In fact, we got a little flak
when we first launched Dart.

80
00:02:56,904 --> 00:02:59,320
People were like, why don't
you make the next big Haskell?

81
00:02:59,320 --> 00:03:01,195
And we're like, we want
more than five users.

82
00:03:01,195 --> 00:03:03,660
And so we wanted to make sure
that you guys can totally

83
00:03:03,660 --> 00:03:04,970
understand this code.

84
00:03:04,970 --> 00:03:06,470
We've run hackathons
and code labs.

85
00:03:06,470 --> 00:03:07,110
People get it.

86
00:03:07,110 --> 00:03:09,432
So familiar, classes.

87
00:03:09,432 --> 00:03:11,140
But just because it's
a familiar language

88
00:03:11,140 --> 00:03:12,640
you can dive into
in about an hour,

89
00:03:12,640 --> 00:03:14,431
doesn't mean we can't
take this opportunity

90
00:03:14,431 --> 00:03:17,099
to introduce new features, for
instance, with constructors.

91
00:03:17,099 --> 00:03:18,640
What do we always
do in constructors?

92
00:03:18,640 --> 00:03:19,760
This dot x equals x.

93
00:03:19,760 --> 00:03:20,830
This dot y equals y.

94
00:03:20,830 --> 00:03:21,910
This is getting boring.

95
00:03:21,910 --> 00:03:23,964
So Dart says, hey, if
the name of the field

96
00:03:23,964 --> 00:03:25,880
is the same as the
constructor parameter, just

97
00:03:25,880 --> 00:03:27,840
say, this.strength in this case.

98
00:03:27,840 --> 00:03:30,134
And that will desugar to
this.strength equals strength.

99
00:03:30,134 --> 00:03:31,800
Just those nice
additions that make this

100
00:03:31,800 --> 00:03:34,970
feel more terse, more scripty.

101
00:03:34,970 --> 00:03:38,310
Speaking of scripty, Dart
has operator overriding.

102
00:03:38,310 --> 00:03:41,450
So plus, minus, et cetera,
that's in this language.

103
00:03:41,450 --> 00:03:43,450
We also named
optional parameters.

104
00:03:43,450 --> 00:03:45,094
Again, it's a
structure language.

105
00:03:45,094 --> 00:03:47,510
It may look like the structure
language you've been using,

106
00:03:47,510 --> 00:03:49,009
but it has those
features that allow

107
00:03:49,009 --> 00:03:51,492
you to have a terse programming
experience that you might

108
00:03:51,492 --> 00:03:53,450
be more familiar with
than scripting languages.

109
00:03:53,450 --> 00:03:55,910
In fact, this case here, hands
is an optional parameter,

110
00:03:55,910 --> 00:03:57,550
but also has a
default value of one.

111
00:03:57,550 --> 00:04:01,000
So say more without typing more.

112
00:04:01,000 --> 00:04:02,550
We also support
one-line functions.

113
00:04:02,550 --> 00:04:02,960
This is critical.

114
00:04:02,960 --> 00:04:05,150
There's a lot of callbacks
going on in web programming,

115
00:04:05,150 --> 00:04:06,524
and a lot of times
you want to do

116
00:04:06,524 --> 00:04:09,900
really small, inline
function literals.

117
00:04:09,900 --> 00:04:12,370
We support that with
the fat arrow syntax.

118
00:04:12,370 --> 00:04:14,050
And we also have
string interpolation,

119
00:04:14,050 --> 00:04:16,630
making it very easy and quick
to create strings, just dollar

120
00:04:16,630 --> 00:04:18,376
sign, variable, or expression.

121
00:04:18,376 --> 00:04:19,250
And it's right there.

122
00:04:19,250 --> 00:04:21,499
It's a lot easier than doing
string builders or string

123
00:04:21,499 --> 00:04:23,870
concatenation.

124
00:04:23,870 --> 00:04:26,070
So Dart is its own language.

125
00:04:26,070 --> 00:04:29,570
It's not just the syntax
that masks another syntax.

126
00:04:29,570 --> 00:04:31,980
We have our own clean semantics.

127
00:04:31,980 --> 00:04:34,986
So we want to turn more of these
"wat" moments, which I'm not

128
00:04:34,986 --> 00:04:37,080
even sure what's going
on here, into the totally

129
00:04:37,080 --> 00:04:38,940
awesome atomic
dinosaur nuclear rocks.

130
00:04:38,940 --> 00:04:43,359
We want you to have more on
the right, less on the left.

131
00:04:43,359 --> 00:04:45,650
Some examples of the cleaned
up semantics that give you

132
00:04:45,650 --> 00:04:48,850
a more logical programming
experience in Dart-- only true

133
00:04:48,850 --> 00:04:49,489
is truthy.

134
00:04:49,489 --> 00:04:50,030
There you go.

135
00:04:50,030 --> 00:04:51,290
Now you know the truthy rules.

136
00:04:51,290 --> 00:04:52,560
Good job.

137
00:04:52,560 --> 00:04:55,920
There is no
undefined, only null.

138
00:04:55,920 --> 00:04:59,550
Yes, totally, cleaned up.

139
00:04:59,550 --> 00:05:02,370
No type coercion with things
like double equals and plus.

140
00:05:02,370 --> 00:05:06,340
So when you try to do something
funky, we're going to tell you.

141
00:05:06,340 --> 00:05:07,910
Pop quiz time.

142
00:05:07,910 --> 00:05:09,970
Here's a string "hello"
we call .missing,

143
00:05:09,970 --> 00:05:11,780
which obviously does
not exist on string.

144
00:05:11,780 --> 00:05:15,220
What would you want to
happen at this point?

145
00:05:15,220 --> 00:05:16,640
Undefined?

146
00:05:16,640 --> 00:05:17,750
I don't want undefined.

147
00:05:17,750 --> 00:05:21,180
I want to be told that there's
no missing method on string.

148
00:05:21,180 --> 00:05:23,580
And sure enough, at runtime,
when you hit code like this,

149
00:05:23,580 --> 00:05:26,090
the program tells you
with a very clean error.

150
00:05:26,090 --> 00:05:28,760
So a much more logical
programming experience.

151
00:05:28,760 --> 00:05:31,400
If you were to compare
'hello', which is a string,

152
00:05:31,400 --> 00:05:32,967
is it greater than one?

153
00:05:32,967 --> 00:05:34,800
I think this returns
false, but actually I'm

154
00:05:34,800 --> 00:05:36,730
not really sure why.

155
00:05:36,730 --> 00:05:40,391
So what would you
want this to happen?

156
00:05:40,391 --> 00:05:41,140
You want an error.

157
00:05:41,140 --> 00:05:42,564
You want to be--
hey, man, string

158
00:05:42,564 --> 00:05:44,480
does not have an instance
method greater than.

159
00:05:44,480 --> 00:05:47,790
You get told at runtime exactly
where the problem happened.

160
00:05:47,790 --> 00:05:50,360
Much more logical
programming experience.

161
00:05:50,360 --> 00:05:51,120
Variable scope.

162
00:05:51,120 --> 00:05:53,411
This one's a little bit
longer, so take a look at this.

163
00:05:53,411 --> 00:05:54,570
We have a main function.

164
00:05:54,570 --> 00:05:56,970
if(true), there's foo,
and then print(foo),

165
00:05:56,970 --> 00:05:58,494
but there's also
a top level foo.

166
00:05:58,494 --> 00:06:00,660
So the question I have for
you is-- when I run this,

167
00:06:00,660 --> 00:06:03,661
what will it print?

168
00:06:03,661 --> 00:06:04,660
KASPER LUND: Any takers?

169
00:06:04,660 --> 00:06:07,050
SETH LADD: It's 50/50 chance.

170
00:06:07,050 --> 00:06:07,880
Top top-level.

171
00:06:07,880 --> 00:06:08,550
Right.

172
00:06:08,550 --> 00:06:11,440
This prints top-level in
Dart, no variable hoisting.

173
00:06:11,440 --> 00:06:14,571
It's a totally logical
lexical scope-- lexical

174
00:06:14,571 --> 00:06:15,820
analysis-- of what's going on.

175
00:06:15,820 --> 00:06:17,980
If you hand most
developers this code,

176
00:06:17,980 --> 00:06:20,970
they'll be able to understand
what's going on here.

177
00:06:20,970 --> 00:06:23,140
Speaking of lexical
scope, even this

178
00:06:23,140 --> 00:06:24,310
is lexically scoped in Dart.

179
00:06:24,310 --> 00:06:26,851
This is one of the things that
totally tripped me up earlier.

180
00:06:26,851 --> 00:06:28,300
Here's a class AwesomeButton.

181
00:06:28,300 --> 00:06:31,000
And in its constructor you
set up a Click Handler.

182
00:06:31,000 --> 00:06:33,856
And when the button is clicked,
call this.atomicDinosaurRock.

183
00:06:33,856 --> 00:06:35,230
Well, what is this
at this point?

184
00:06:35,230 --> 00:06:37,310
The lexically
scoped this that is

185
00:06:37,310 --> 00:06:38,532
an instance of AwesomeButton.

186
00:06:38,532 --> 00:06:40,740
You give most people this
code and they will tell you

187
00:06:40,740 --> 00:06:43,940
what method this is calling
on, which is, I think,

188
00:06:43,940 --> 00:06:46,190
a pretty big improvement.

189
00:06:46,190 --> 00:06:48,040
So that's a little
bit on the semantics,

190
00:06:48,040 --> 00:06:50,650
and a little bit on the syntax.

191
00:06:50,650 --> 00:06:52,380
But Dart is also
designed to scale

192
00:06:52,380 --> 00:06:53,910
from just a couple
lines of code.

193
00:06:53,910 --> 00:06:55,330
You could certainly write
a ten line Dart script

194
00:06:55,330 --> 00:06:56,620
and have it look very scripty.

195
00:06:56,620 --> 00:07:00,380
But you can scale all way up
to millions of lines of code.

196
00:07:00,380 --> 00:07:01,520
Now we saw functions.

197
00:07:01,520 --> 00:07:02,220
We saw classes.

198
00:07:02,220 --> 00:07:03,310
We have mixins.

199
00:07:03,310 --> 00:07:04,120
We have interfaces.

200
00:07:04,120 --> 00:07:06,328
I want to talk about libraries,
which is a nice piece

201
00:07:06,328 --> 00:07:08,000
to help you
modularize your code.

202
00:07:08,000 --> 00:07:09,375
Dart libraries
are very flexible.

203
00:07:09,375 --> 00:07:11,170
You simply define a
file as a library.

204
00:07:11,170 --> 00:07:13,375
You can import libraries
from the core SDK.

205
00:07:13,375 --> 00:07:16,400
You can import libraries from
other people, or other files.

206
00:07:16,400 --> 00:07:19,590
And then you can define any
number of top level constructs

207
00:07:19,590 --> 00:07:20,270
in a library.

208
00:07:20,270 --> 00:07:22,614
So no more one public
class per file thing,

209
00:07:22,614 --> 00:07:23,530
if you come from Java.

210
00:07:23,530 --> 00:07:26,572
So in this case, two classes
and even a top level function.

211
00:07:26,572 --> 00:07:28,780
In Dart, you don't have to
wrap everything in a class

212
00:07:28,780 --> 00:07:29,840
if you don't want to.

213
00:07:29,840 --> 00:07:33,845
So nice, scalable
structure for you to grow.

214
00:07:33,845 --> 00:07:35,220
Hopefully, you
guys saw that this

215
00:07:35,220 --> 00:07:37,100
is a language you can
start using right away.

216
00:07:37,100 --> 00:07:40,190
But of course, we use
Dart to get onto the web.

217
00:07:40,190 --> 00:07:42,820
And to get on the web, you have
to compile Dart to JavaScript.

218
00:07:42,820 --> 00:07:45,020
And to do that and to
show you how it works,

219
00:07:45,020 --> 00:07:47,764
I'll turn it over to Kasper
to tell you all about dart2js.

220
00:07:47,764 --> 00:07:48,930
KASPER LUND: Thank you Seth.

221
00:07:48,930 --> 00:07:50,860
So finally, now I
can say something.

222
00:07:50,860 --> 00:07:51,707
It's wonderful.

223
00:07:51,707 --> 00:07:53,540
I'm going to tell you
a little bit about how

224
00:07:53,540 --> 00:07:55,240
we compile to
efficient JavaScript.

225
00:07:55,240 --> 00:07:58,060
And it's very, very
important to us to make sure

226
00:07:58,060 --> 00:08:00,520
that Dart runs really well
on all modern browsers,

227
00:08:00,520 --> 00:08:03,700
so we put a lot of
effort into that area.

228
00:08:03,700 --> 00:08:05,100
Our goals are fairly simple.

229
00:08:05,100 --> 00:08:07,905
We want to generate small code,
we want to generate fast code,

230
00:08:07,905 --> 00:08:09,530
and we want to make
sure that we retain

231
00:08:09,530 --> 00:08:13,670
the nice, clean proper Dart
semantics while doing so.

232
00:08:13,670 --> 00:08:16,310
So simple goals is a
good starting point.

233
00:08:16,310 --> 00:08:18,150
But to do this, and
to do it efficiently,

234
00:08:18,150 --> 00:08:20,300
we need a real
optimizing compiler,

235
00:08:20,300 --> 00:08:22,900
something that
doesn't just do a one

236
00:08:22,900 --> 00:08:24,390
to one translation
in a simple way.

237
00:08:24,390 --> 00:08:27,610
We actually need a lot of
the neat, modern compiling

238
00:08:27,610 --> 00:08:31,460
techniques we've learned
to love from other more

239
00:08:31,460 --> 00:08:33,929
involved projects, like V8.

240
00:08:33,929 --> 00:08:35,429
So we need function inlining.

241
00:08:35,429 --> 00:08:37,010
We need loop-invariant
code motion.

242
00:08:37,010 --> 00:08:38,419
We need global value numbering.

243
00:08:38,419 --> 00:08:40,770
We need a lot of these
things-- type propagation,

244
00:08:40,770 --> 00:08:43,120
redundant lode elimination,
dead code elimination,

245
00:08:43,120 --> 00:08:44,027
and much, much more.

246
00:08:44,027 --> 00:08:45,860
So we need a lot of
things in this compiler.

247
00:08:45,860 --> 00:08:48,430
We want to do a good job
in optimizing your code,

248
00:08:48,430 --> 00:08:50,490
so you don't have
to worry about it.

249
00:08:50,490 --> 00:08:52,936
So let's take a look at a
very simple Dart method, just

250
00:08:52,936 --> 00:08:54,810
to give you an impression
of what we actually

251
00:08:54,810 --> 00:08:56,090
translate the code to.

252
00:08:56,090 --> 00:08:58,460
Here's a main method that
allocates a few points,

253
00:08:58,460 --> 00:09:00,709
and then we compute the
distance between these points.

254
00:09:00,709 --> 00:09:01,980
Very simple code.

255
00:09:01,980 --> 00:09:03,586
Luckily, a simple
Dart method actually

256
00:09:03,586 --> 00:09:05,460
compiles to relatively
simple JavaScript too.

257
00:09:05,460 --> 00:09:08,420
So you will allocate
points the same way

258
00:09:08,420 --> 00:09:09,710
as you would expect it to.

259
00:09:09,710 --> 00:09:11,490
The only real difference
here is that when

260
00:09:11,490 --> 00:09:13,750
you call the distanceTo
method, we actually

261
00:09:13,750 --> 00:09:17,240
encode the arity, the
number of parameters passed,

262
00:09:17,240 --> 00:09:18,420
in the method name.

263
00:09:18,420 --> 00:09:19,586
Now why do we do that?

264
00:09:19,586 --> 00:09:21,960
The reason why we do that is
because in JavaScript, we're

265
00:09:21,960 --> 00:09:23,910
allowed to pass any
number of arguments.

266
00:09:23,910 --> 00:09:26,510
Too few or too many, it
doesn't really matter.

267
00:09:26,510 --> 00:09:29,309
But usually it leads to
weird and surprising behavior

268
00:09:29,309 --> 00:09:30,850
at runtime if you
do that, so we want

269
00:09:30,850 --> 00:09:32,266
to be a little bit
stricter there.

270
00:09:32,266 --> 00:09:35,129
So to live by Dart's proper
semantics rules there,

271
00:09:35,129 --> 00:09:36,670
we actually have to
check that you're

272
00:09:36,670 --> 00:09:38,030
calling with the right
number of parameters.

273
00:09:38,030 --> 00:09:39,405
And the fastest
way of doing that

274
00:09:39,405 --> 00:09:41,070
is just encoding it
in the method name.

275
00:09:41,070 --> 00:09:42,900
If you call with
too many parameters,

276
00:09:42,900 --> 00:09:46,720
you'll get an error that
that method doesn't exist.

277
00:09:46,720 --> 00:09:49,570
So when you have
large applications,

278
00:09:49,570 --> 00:09:51,470
you need some sort
of tool to make sure

279
00:09:51,470 --> 00:09:52,890
that you're not
actually shipping

280
00:09:52,890 --> 00:09:54,190
too much code to your clients.

281
00:09:54,190 --> 00:09:55,606
In particular, in
the set up where

282
00:09:55,606 --> 00:09:57,517
you have a nice, rich
set of core libraries

283
00:09:57,517 --> 00:09:59,850
and a nice set of third party
libraries you can include,

284
00:09:59,850 --> 00:10:01,180
you want to make
sure that whatever

285
00:10:01,180 --> 00:10:02,990
you ship to your clients
is only the needed

286
00:10:02,990 --> 00:10:04,810
bits, not all the other stuff.

287
00:10:04,810 --> 00:10:06,960
To do that, we have
an implementation

288
00:10:06,960 --> 00:10:09,385
of an algorithm called tree
shaking in the compiler.

289
00:10:09,385 --> 00:10:11,500
It works a little
something like this.

290
00:10:11,500 --> 00:10:14,820
If you have an application that
has a main method, and perhaps

291
00:10:14,820 --> 00:10:17,810
a few other methods
close by, foo and baz,

292
00:10:17,810 --> 00:10:20,420
but it's only calling
the foo method,

293
00:10:20,420 --> 00:10:21,940
and maybe the foo
method in return

294
00:10:21,940 --> 00:10:24,150
calls code pulled in
from another library--

295
00:10:24,150 --> 00:10:26,820
the bar method
down on the right--

296
00:10:26,820 --> 00:10:29,750
the library may actually have
unused parts too like the boo

297
00:10:29,750 --> 00:10:32,990
function here-- we want
the dart2js compiler

298
00:10:32,990 --> 00:10:37,320
to actually take
this set of methods

299
00:10:37,320 --> 00:10:39,150
like the transitive
closure of everything

300
00:10:39,150 --> 00:10:41,649
that you have available to
you, and shake it really good

301
00:10:41,649 --> 00:10:43,440
and get all this stuff
that you're actually

302
00:10:43,440 --> 00:10:44,742
not using out of the system.

303
00:10:44,742 --> 00:10:46,200
It's a process
called tree shaking.

304
00:10:46,200 --> 00:10:49,050
We do that and the
result is a lot smaller.

305
00:10:49,050 --> 00:10:52,040
It only contains main, foo,
and bar, the needed parts.

306
00:10:52,040 --> 00:10:54,540
So to implement this
in the compiler,

307
00:10:54,540 --> 00:10:56,990
we actually go
through a few steps.

308
00:10:56,990 --> 00:10:58,770
First we read all
your Dart sources.

309
00:10:58,770 --> 00:11:01,210
We don't actually
parse them fully.

310
00:11:01,210 --> 00:11:02,750
We don't look into
all the methods.

311
00:11:02,750 --> 00:11:04,810
We just look at the
structure of your code,

312
00:11:04,810 --> 00:11:06,880
find all the imports,
look at the libraries

313
00:11:06,880 --> 00:11:09,622
that you depend on,
and read those in too.

314
00:11:09,622 --> 00:11:11,330
When we have everything
read in that way,

315
00:11:11,330 --> 00:11:12,954
and we know the
structure of your code,

316
00:11:12,954 --> 00:11:17,930
we can actually start doing this
first level of tree shaking.

317
00:11:17,930 --> 00:11:18,864
We have two levels.

318
00:11:18,864 --> 00:11:20,530
This is the first
one, and this actually

319
00:11:20,530 --> 00:11:22,970
is what we call the
resolution tree shaking.

320
00:11:22,970 --> 00:11:25,220
And resolution is the process
of not really compiling

321
00:11:25,220 --> 00:11:27,720
code, but just trying to figure
out what you're referring to

322
00:11:27,720 --> 00:11:29,090
at certain points in the code.

323
00:11:29,090 --> 00:11:31,360
So it actually starts by
looking at the main function,

324
00:11:31,360 --> 00:11:34,030
and look at what kind of classes
or instances of which classes

325
00:11:34,030 --> 00:11:36,702
you allocate in there, and which
other methods you're calling.

326
00:11:36,702 --> 00:11:38,410
All those methods need
to go into a queue

327
00:11:38,410 --> 00:11:41,280
so we can process them, parse
them, get them resolved.

328
00:11:41,280 --> 00:11:43,750
And you just keep doing that
until nothing new is added

329
00:11:43,750 --> 00:11:45,480
to the queue, and
then you're done.

330
00:11:45,480 --> 00:11:47,090
It's relatively
simple to do this,

331
00:11:47,090 --> 00:11:48,790
and it gives us a
good approximation

332
00:11:48,790 --> 00:11:52,040
of cutting down everything,
but only based on method names.

333
00:11:52,040 --> 00:11:53,470
We can do a little bit better.

334
00:11:53,470 --> 00:11:55,178
So once we're done
with that, we actually

335
00:11:55,178 --> 00:11:57,834
start the process all over
again in the compilation queue.

336
00:11:57,834 --> 00:11:59,250
And this is where
we actually will

337
00:11:59,250 --> 00:12:03,640
start looking at what you
really put inside your methods,

338
00:12:03,640 --> 00:12:05,490
and do data-flow
analysis, and we

339
00:12:05,490 --> 00:12:07,454
will track how types
flow through that code.

340
00:12:07,454 --> 00:12:08,870
And that gives us
more information

341
00:12:08,870 --> 00:12:11,350
about what you're
actually needing to emit.

342
00:12:11,350 --> 00:12:14,270
And we do the last level of
the tree shaking at that point.

343
00:12:14,270 --> 00:12:17,357
The end result is that we do a
really good job of making sure

344
00:12:17,357 --> 00:12:18,940
that things that you
really don't need

345
00:12:18,940 --> 00:12:21,290
are not pulled into
your application.

346
00:12:21,290 --> 00:12:25,180
Finally, we actually emit
the code to a single JS file.

347
00:12:25,180 --> 00:12:26,670
So you can run it
in your browser.

348
00:12:26,670 --> 00:12:27,530
Fairly simple stuff.

349
00:12:27,530 --> 00:12:29,710
SETH LADD: I love this because
this is the tools helping me.

350
00:12:29,710 --> 00:12:31,501
I don't need to be
crafting my application.

351
00:12:31,501 --> 00:12:34,242
I just let the tool analyze
my program, take care of it.

352
00:12:34,242 --> 00:12:35,950
KASPER LUND: That's
the way it should be.

353
00:12:35,950 --> 00:12:39,290
So let's take a look at how
this actually works in practice.

354
00:12:39,290 --> 00:12:42,730
Just to give you a feel for
how dart2js does its magic,

355
00:12:42,730 --> 00:12:46,510
I'm going to dive into
a well-known algorithm.

356
00:12:46,510 --> 00:12:48,140
It's a constraint
solving algorithm.

357
00:12:48,140 --> 00:12:49,640
The reason why I'm
choosing this one

358
00:12:49,640 --> 00:12:53,360
is it's a well
understood piece of code.

359
00:12:53,360 --> 00:12:55,896
It's been used to benchmark
lots of different language

360
00:12:55,896 --> 00:12:57,020
limitations over the years.

361
00:12:57,020 --> 00:12:59,710
It's actually part of
the Octane benchmark

362
00:12:59,710 --> 00:13:01,030
Linus mentioned this morning.

363
00:13:01,030 --> 00:13:02,810
So it's a well-known
piece of code.

364
00:13:02,810 --> 00:13:03,710
It is structured.

365
00:13:03,710 --> 00:13:07,520
It has inheritance, and
classes, and everything

366
00:13:07,520 --> 00:13:09,980
we need to actually do a
good job in making your code

367
00:13:09,980 --> 00:13:10,770
run fast.

368
00:13:10,770 --> 00:13:11,970
So let's take a look at it.

369
00:13:11,970 --> 00:13:13,180
DeltaBlue is a
constraint solver.

370
00:13:13,180 --> 00:13:14,070
What does that mean?

371
00:13:14,070 --> 00:13:16,680
Well, basically, it's
a fairly abstract thing

372
00:13:16,680 --> 00:13:20,360
that works on
constraints on variables.

373
00:13:20,360 --> 00:13:23,350
Constraints can be
one way or two way.

374
00:13:23,350 --> 00:13:26,817
There are binary or unary
constraints of different kinds.

375
00:13:26,817 --> 00:13:28,400
And they can be used
to, for instance,

376
00:13:28,400 --> 00:13:31,120
model the constraints
involving laying out something

377
00:13:31,120 --> 00:13:31,751
on your screen.

378
00:13:31,751 --> 00:13:34,250
I'm pretty sure that some of
the things you just heard about

379
00:13:34,250 --> 00:13:36,543
from Eric actually use
this constraint to think

380
00:13:36,543 --> 00:13:38,490
of that internally
when building layouts.

381
00:13:38,490 --> 00:13:41,417
So doesn't lose an
implementation of such a beast.

382
00:13:41,417 --> 00:13:43,750
It uses constraints and there's
a nice hierarchy of them

383
00:13:43,750 --> 00:13:46,960
with unary and binary
constraints and variables.

384
00:13:46,960 --> 00:13:49,250
Let me show you a piece
of code from this thing,

385
00:13:49,250 --> 00:13:51,170
to make it a little
bit more concrete.

386
00:13:51,170 --> 00:13:54,690
This is a function from
the DeltaBlue algorithm.

387
00:13:54,690 --> 00:13:55,770
It's fairly simple.

388
00:13:55,770 --> 00:13:58,590
You don't have to understand
all the details here, but just

389
00:13:58,590 --> 00:14:02,260
note that the way it works here
is that you take a variable v,

390
00:14:02,260 --> 00:14:04,800
and you try to figure out all
the constraints that actually

391
00:14:04,800 --> 00:14:07,310
consume that
variable, and put them

392
00:14:07,310 --> 00:14:10,050
in a list that is also
passed in as a parameter.

393
00:14:10,050 --> 00:14:13,910
Hopefully this code is
reasonably readable to you.

394
00:14:13,910 --> 00:14:16,262
It's Dart code and to me
this looks like what I--

395
00:14:16,262 --> 00:14:18,220
SETH LADD: Kind of
representative of code a lot

396
00:14:18,220 --> 00:14:18,853
of us would write.

397
00:14:18,853 --> 00:14:19,620
KASPER LUND: Yeah.

398
00:14:19,620 --> 00:14:22,815
So in Dart, we have an
optional aesthetic type system.

399
00:14:22,815 --> 00:14:24,940
So you do not have to write
the types if you really

400
00:14:24,940 --> 00:14:25,770
don't want to.

401
00:14:25,770 --> 00:14:27,845
Sometimes it's nice to
have the document what

402
00:14:27,845 --> 00:14:30,530
a parameter means, which
is why I've done it here.

403
00:14:30,530 --> 00:14:32,610
But it's important to
us to make it clear

404
00:14:32,610 --> 00:14:36,110
that the types that you put
in are not actually used

405
00:14:36,110 --> 00:14:38,400
for up optimization purposes,
because we don't really

406
00:14:38,400 --> 00:14:40,921
know if you want
to type them in.

407
00:14:40,921 --> 00:14:43,420
So we don't want to force you
into typing them in the places

408
00:14:43,420 --> 00:14:44,450
where you don't want to.

409
00:14:44,450 --> 00:14:46,050
So I can go ahead
and remove them.

410
00:14:46,050 --> 00:14:47,420
SETH LADD: And they
might also be incorrect.

411
00:14:47,420 --> 00:14:49,214
KASPER LUND: They
could be incorrect.

412
00:14:49,214 --> 00:14:51,130
Anyway, I've gone ahead
and removed the types.

413
00:14:51,130 --> 00:14:54,040
The semantics of this
algorithm is exactly the same,

414
00:14:54,040 --> 00:14:55,149
no differences at all.

415
00:14:55,149 --> 00:14:57,690
It's just a little bit shorter,
and maybe a little bit harder

416
00:14:57,690 --> 00:14:58,330
to understand.

417
00:14:58,330 --> 00:15:00,810
But anyway, the code is
there, it's the same thing,

418
00:15:00,810 --> 00:15:03,080
and this is what we're
going to try to optimize.

419
00:15:03,080 --> 00:15:06,720
So first attempt at
actually compiling this code

420
00:15:06,720 --> 00:15:09,920
to JavaScript is somewhat large.

421
00:15:09,920 --> 00:15:11,350
So this is the
unoptimized version

422
00:15:11,350 --> 00:15:13,550
of the method you just saw.

423
00:15:13,550 --> 00:15:17,440
It compiled to 500 and
something characters.

424
00:15:17,440 --> 00:15:18,780
It's a little bit too long.

425
00:15:18,780 --> 00:15:22,280
I'm not even sure you can read
it in the back of the hall

426
00:15:22,280 --> 00:15:22,900
here.

427
00:15:22,900 --> 00:15:24,510
But it works.

428
00:15:24,510 --> 00:15:25,820
It has the right semantics.

429
00:15:25,820 --> 00:15:27,460
Everything works as specified.

430
00:15:27,460 --> 00:15:30,040
And it runs reasonably well.

431
00:15:30,040 --> 00:15:33,110
But it's-- I hope you agree--
it's simply not good enough.

432
00:15:33,110 --> 00:15:34,990
We want to do a lot better.

433
00:15:34,990 --> 00:15:37,930
So let's try to dive into
how we actually do better

434
00:15:37,930 --> 00:15:39,384
than just this blob of code.

435
00:15:39,384 --> 00:15:41,550
Even though the semantics
is really important to us,

436
00:15:41,550 --> 00:15:44,930
we also really care
about performance.

437
00:15:44,930 --> 00:15:46,090
So what makes this big?

438
00:15:46,090 --> 00:15:49,010
Well, this is just
one of the examples

439
00:15:49,010 --> 00:15:51,500
of why this code is little bit
bigger than what we'd like.

440
00:15:51,500 --> 00:15:54,400
So as Seth mentioned,
we have strict semantics

441
00:15:54,400 --> 00:15:56,670
about what you can compare
to numbers, for instance.

442
00:15:56,670 --> 00:15:59,630
So we don't want to run
into issues when you end up

443
00:15:59,630 --> 00:16:02,300
emitting JavaScript code that
just ends up comparing numbers

444
00:16:02,300 --> 00:16:04,590
and strengths for instance,
because we don't really

445
00:16:04,590 --> 00:16:06,180
want to rely on that behavior.

446
00:16:06,180 --> 00:16:08,834
So in this case
we're reading-- see

447
00:16:08,834 --> 00:16:10,780
if I can get this to
progress, there we

448
00:16:10,780 --> 00:16:13,527
go-- so we're reading the length
of something that probably

449
00:16:13,527 --> 00:16:15,110
is an array, but
we're not quite sure.

450
00:16:15,110 --> 00:16:17,359
So we don't know that the
length is actually a number.

451
00:16:17,359 --> 00:16:20,630
So before we continue
to actually compare

452
00:16:20,630 --> 00:16:22,650
this length against
a real number,

453
00:16:22,650 --> 00:16:25,970
we have to make sure that
it actually is a number.

454
00:16:25,970 --> 00:16:29,170
So we insert an explicit
check in the code that

455
00:16:29,170 --> 00:16:32,804
makes sure that we don't end
up relying on this somewhat

456
00:16:32,804 --> 00:16:34,220
surprising behavior
of JavaScript,

457
00:16:34,220 --> 00:16:36,178
where you can compare
numbers against strengths

458
00:16:36,178 --> 00:16:37,290
and get some result out.

459
00:16:37,290 --> 00:16:40,410
So this adds code-- more checks.

460
00:16:40,410 --> 00:16:42,070
So our challenge
is fairly simple.

461
00:16:42,070 --> 00:16:45,380
We want to have clean semantics,
unsurprising behavior,

462
00:16:45,380 --> 00:16:47,260
but we do not really
want those extra checks

463
00:16:47,260 --> 00:16:48,718
when we're compiling
to JavaScript.

464
00:16:48,718 --> 00:16:51,650
So how can we go
about doing that?

465
00:16:51,650 --> 00:16:54,800
The trick is right behind
me-- global optimizations.

466
00:16:54,800 --> 00:16:58,230
So we really need
to do better, and we

467
00:16:58,230 --> 00:17:00,790
need to do more aggressive
optimizations in the code

468
00:17:00,790 --> 00:17:03,860
to make it end up being
very fast and very good.

469
00:17:03,860 --> 00:17:05,890
So let's look at that.

470
00:17:05,890 --> 00:17:08,220
First up-- Dart is structured.

471
00:17:08,220 --> 00:17:09,530
It has classes.

472
00:17:09,530 --> 00:17:10,510
It has methods.

473
00:17:10,510 --> 00:17:11,960
It has a good structure.

474
00:17:11,960 --> 00:17:14,380
We can actually do
whole program analysis.

475
00:17:14,380 --> 00:17:15,829
So when we compile
the program, we

476
00:17:15,829 --> 00:17:17,369
can look at every
single bit in it,

477
00:17:17,369 --> 00:17:19,329
and we can actually
understand what's going on.

478
00:17:19,329 --> 00:17:20,700
That's a huge win for us.

479
00:17:20,700 --> 00:17:22,789
This allows us to actually
do code navigation

480
00:17:22,789 --> 00:17:24,510
and great refactoring tools.

481
00:17:24,510 --> 00:17:27,329
But maybe even more
dear to my heart

482
00:17:27,329 --> 00:17:30,370
is that we can also do a global
compile-time optimizations.

483
00:17:30,370 --> 00:17:31,989
So we can actually
analyze your code,

484
00:17:31,989 --> 00:17:33,780
understand the dependencies
between things,

485
00:17:33,780 --> 00:17:36,450
maybe, to a certain extent,
better than what you actually

486
00:17:36,450 --> 00:17:38,180
care to do yourself,
as a developer.

487
00:17:38,180 --> 00:17:40,150
And then we can
optimize based on that.

488
00:17:40,150 --> 00:17:41,712
It's pretty powerful.

489
00:17:41,712 --> 00:17:43,670
One of things that we
do, and one of the things

490
00:17:43,670 --> 00:17:45,753
that really work well for
something like DeltaBlue

491
00:17:45,753 --> 00:17:47,480
and for most
applications in general,

492
00:17:47,480 --> 00:17:49,090
is that we infer types.

493
00:17:49,090 --> 00:17:50,930
We compute what
types we actually

494
00:17:50,930 --> 00:17:54,650
will see at runtime at
different points in the code.

495
00:17:54,650 --> 00:17:56,420
And the way that
works is-- Here's

496
00:17:56,420 --> 00:17:58,280
a simple example
of how that works.

497
00:17:58,280 --> 00:18:01,070
Main function calls
foo, that calls bar,

498
00:18:01,070 --> 00:18:02,610
that calls foo again, basically.

499
00:18:02,610 --> 00:18:04,610
So a bunch of functions
calling each other.

500
00:18:04,610 --> 00:18:07,110
So how do we infer types for
the parameters of these things?

501
00:18:07,110 --> 00:18:08,943
How do we get the
compiler more information?

502
00:18:08,943 --> 00:18:10,820
Well, we start by
looking at main.

503
00:18:10,820 --> 00:18:12,102
So it's very simple.

504
00:18:12,102 --> 00:18:14,310
And by analyzing main we
can see that foo is actually

505
00:18:14,310 --> 00:18:15,750
called with an
integer parameter.

506
00:18:15,750 --> 00:18:17,020
OK, so far, so good.

507
00:18:17,020 --> 00:18:19,000
So we analyze foo,
under the assumption

508
00:18:19,000 --> 00:18:20,100
that this called the
integer parameter.

509
00:18:20,100 --> 00:18:21,490
Do we learn something from that?

510
00:18:21,490 --> 00:18:22,270
Sure.

511
00:18:22,270 --> 00:18:24,670
Bar is apparently also called
with an integer parameter.

512
00:18:24,670 --> 00:18:25,409
So far, so good.

513
00:18:25,409 --> 00:18:26,950
We can finish this
game a little bit.

514
00:18:26,950 --> 00:18:28,590
So we end up in bar.

515
00:18:28,590 --> 00:18:31,400
And we realize that if bar
is called with an integer

516
00:18:31,400 --> 00:18:33,430
parameter, then it
ends up calling foo

517
00:18:33,430 --> 00:18:34,970
with a string
interpolated version

518
00:18:34,970 --> 00:18:37,424
of that parameter,
which is a string.

519
00:18:37,424 --> 00:18:38,840
So foo is now
called with a string

520
00:18:38,840 --> 00:18:41,090
too, so we have to
go back and iterate.

521
00:18:41,090 --> 00:18:43,460
So foo is now apparently
also called with a string.

522
00:18:43,460 --> 00:18:45,360
That means bar is called
with a string too.

523
00:18:45,360 --> 00:18:47,010
And finally, inside
the bar method,

524
00:18:47,010 --> 00:18:50,290
we realize that that means that
print is called with a string.

525
00:18:50,290 --> 00:18:51,630
So far so good.

526
00:18:51,630 --> 00:18:53,700
All in all, the
compiler can actually

527
00:18:53,700 --> 00:18:58,900
conclude that x and y are both
either integers or strings.

528
00:18:58,900 --> 00:19:00,511
This is a very,
very simple example,

529
00:19:00,511 --> 00:19:03,010
but it actually works really
well in practice for large apps

530
00:19:03,010 --> 00:19:05,304
too.

531
00:19:05,304 --> 00:19:06,720
So let's look at
DeltaBlue and see

532
00:19:06,720 --> 00:19:07,970
how that actually works there.

533
00:19:07,970 --> 00:19:08,890
It's pretty simple.

534
00:19:08,890 --> 00:19:10,220
So there are a
couple of things here

535
00:19:10,220 --> 00:19:11,344
we want to infer types for.

536
00:19:11,344 --> 00:19:15,510
For instance, the two
parameters, like v and coll.

537
00:19:15,510 --> 00:19:17,710
And the infer actually
does that by looking

538
00:19:17,710 --> 00:19:20,330
at all the coll sites that
call addConstraintsConsumingTo.

539
00:19:20,330 --> 00:19:24,350
And we actually learned that v
is either null or a variable,

540
00:19:24,350 --> 00:19:26,600
and that coll cannot be null.

541
00:19:26,600 --> 00:19:28,700
It always is a JavaScript
array, containing

542
00:19:28,700 --> 00:19:31,250
only subclasses of
the class constraint.

543
00:19:31,250 --> 00:19:32,740
That's pretty powerful.

544
00:19:32,740 --> 00:19:35,370
So that's good to know for us.

545
00:19:35,370 --> 00:19:37,460
The rest of the method
here can also be analyzed,

546
00:19:37,460 --> 00:19:40,084
and we can learn something about
all these constructs in there.

547
00:19:40,084 --> 00:19:41,930
So we can actually get
a pretty full picture

548
00:19:41,930 --> 00:19:43,790
of what the types in here are.

549
00:19:43,790 --> 00:19:45,070
So I just listed them here.

550
00:19:45,070 --> 00:19:46,840
You don't have to look
at all the details,

551
00:19:46,840 --> 00:19:48,420
but this is very good
information for our compiler

552
00:19:48,420 --> 00:19:48,833
to have.

553
00:19:48,833 --> 00:19:50,220
SETH LADD: And it does this
without running a program,

554
00:19:50,220 --> 00:19:52,090
just statically
looking at the program.

555
00:19:52,090 --> 00:19:55,870
KASPER LUND: This is global
analysis at compile time.

556
00:19:55,870 --> 00:19:59,970
So let's make this
play to our advantage.

557
00:19:59,970 --> 00:20:01,860
So here's the code
again without type

558
00:20:01,860 --> 00:20:04,720
inferencing-- 526 characters.

559
00:20:04,720 --> 00:20:07,971
So first thing off, we know v
is either null or a variable.

560
00:20:07,971 --> 00:20:09,720
So we can do a little
bit better than just

561
00:20:09,720 --> 00:20:10,880
calling this getter on it.

562
00:20:10,880 --> 00:20:12,210
So we can actually
see that it always

563
00:20:12,210 --> 00:20:14,280
has a property determined
by, we just fetch it.

564
00:20:14,280 --> 00:20:15,664
Simple stuff.

565
00:20:15,664 --> 00:20:17,080
There are other
things that we can

566
00:20:17,080 --> 00:20:18,590
win even more by recognizing.

567
00:20:18,590 --> 00:20:21,340
For instance, v, the
variable dot constraints.

568
00:20:21,340 --> 00:20:23,340
Since v is a variable,
the constraints in there

569
00:20:23,340 --> 00:20:26,070
is always an array
of the constraints.

570
00:20:26,070 --> 00:20:29,340
So we don't have to go through
this calling a lengths getter

571
00:20:29,340 --> 00:20:30,730
and calling an index operator.

572
00:20:30,730 --> 00:20:33,220
We can just do the
real JavaScript way.

573
00:20:33,220 --> 00:20:35,650
Just fetch the length and
just index into the array.

574
00:20:35,650 --> 00:20:37,720
Simple stuff.

575
00:20:37,720 --> 00:20:40,700
Even better, we know that
v.constraints, that length

576
00:20:40,700 --> 00:20:42,260
is actually an integer.

577
00:20:42,260 --> 00:20:45,440
So this whole notion of checking
whether or not it's a number

578
00:20:45,440 --> 00:20:46,600
goes away.

579
00:20:46,600 --> 00:20:48,510
So that is a helpful thing.

580
00:20:48,510 --> 00:20:51,540
It's starting to improve.

581
00:20:51,540 --> 00:20:54,410
Now the condition that we have
in the loop is turning simpler.

582
00:20:54,410 --> 00:20:56,110
We can change the
y-limit to a for-loop.

583
00:20:56,110 --> 00:20:59,777
And at that point we're
already down to 33%

584
00:20:59,777 --> 00:21:01,610
smaller than the original
code I showed you.

585
00:21:01,610 --> 00:21:04,880
We have more to go, but
it's pretty simple stuff.

586
00:21:04,880 --> 00:21:05,700
coll is an array.

587
00:21:05,700 --> 00:21:08,390
So this calling add
on it, in a weird way,

588
00:21:08,390 --> 00:21:09,407
is not really necessary.

589
00:21:09,407 --> 00:21:10,990
So we can just use
the JavaScript push

590
00:21:10,990 --> 00:21:12,490
method to do that for you.

591
00:21:12,490 --> 00:21:13,790
Looks good.

592
00:21:13,790 --> 00:21:17,070
Even further, the t1 is
initialized in a simple way,

593
00:21:17,070 --> 00:21:18,900
so that can just move
into the for-loop.

594
00:21:18,900 --> 00:21:21,790
And we're down to 41% smaller
than the original JS output.

595
00:21:21,790 --> 00:21:24,030
We're starting to get there.

596
00:21:24,030 --> 00:21:25,860
c is known to be a
subclasses constraint,

597
00:21:25,860 --> 00:21:26,860
and it cannot be nulled.

598
00:21:26,860 --> 00:21:27,770
We've inferred that.

599
00:21:27,770 --> 00:21:30,228
So this whole notion of checking
whether or not c is nulled

600
00:21:30,228 --> 00:21:33,020
before doing a comparison-- this
is necessary because of null

601
00:21:33,020 --> 00:21:35,200
and undefined in
JavaScript by the way--

602
00:21:35,200 --> 00:21:37,710
we don't have to worry about
that because at least c cannot

603
00:21:37,710 --> 00:21:38,420
be null.

604
00:21:38,420 --> 00:21:40,400
So we can simplify the code.

605
00:21:40,400 --> 00:21:41,570
It's a good thing.

606
00:21:41,570 --> 00:21:45,230
Finally, we know that calling is
satisfied on c, actually always

607
00:21:45,230 --> 00:21:46,730
returns a boolean.

608
00:21:46,730 --> 00:21:49,234
And true is the only
truthy value in Dart,

609
00:21:49,234 --> 00:21:51,400
so usually we have to compare
against true before we

610
00:21:51,400 --> 00:21:52,290
branch on it.

611
00:21:52,290 --> 00:21:55,120
But because a boolean is
always either true or false,

612
00:21:55,120 --> 00:21:56,140
it's just fine.

613
00:21:56,140 --> 00:21:57,850
We can get rid of
that last thing.

614
00:21:57,850 --> 00:22:00,970
And there you have it--
an optimized version

615
00:22:00,970 --> 00:22:02,400
of this method that runs fast.

616
00:22:02,400 --> 00:22:05,370
It's much smaller, but it still
has exactly the same semantics.

617
00:22:05,370 --> 00:22:09,940
It's just we've proven we didn't
need some of these checks.

618
00:22:09,940 --> 00:22:11,440
So what's that do
to performance?

619
00:22:11,440 --> 00:22:13,760
Well, here's the graph
of that over time.

620
00:22:13,760 --> 00:22:16,650
So the top line is
the native Dart VM

621
00:22:16,650 --> 00:22:18,780
running the DeltaBlue algorithm.

622
00:22:18,780 --> 00:22:20,947
So you see that that's the
best performance we have.

623
00:22:20,947 --> 00:22:22,321
And it really
comes from the fact

624
00:22:22,321 --> 00:22:23,760
that Dart is
designed from the get

625
00:22:23,760 --> 00:22:25,194
go to be an efficient language.

626
00:22:25,194 --> 00:22:27,110
So we have a very good
implementation of that.

627
00:22:27,110 --> 00:22:29,651
The next two lines might be more
interesting in this context.

628
00:22:29,651 --> 00:22:31,835
The yellowish line
is actually V8

629
00:22:31,835 --> 00:22:34,210
running a handwritten version
of the DeltaBlue benchmark.

630
00:22:34,210 --> 00:22:36,530
This is the Octane version
of the DeltaBlue benchmark

631
00:22:36,530 --> 00:22:39,080
that you might have
seen in other places.

632
00:22:39,080 --> 00:22:41,570
As you can see, V8 improves
on that over time, slowly,

633
00:22:41,570 --> 00:22:44,740
and that's a very good
thing for the entire web.

634
00:22:44,740 --> 00:22:46,430
Maybe more interesting
to me, at least,

635
00:22:46,430 --> 00:22:47,919
is that the dart2js
generated code

636
00:22:47,919 --> 00:22:49,460
has improved a lot
on this benchmark.

637
00:22:49,460 --> 00:22:51,180
It's still the same
V8 that runs it,

638
00:22:51,180 --> 00:22:52,860
it's just that the
code we generate

639
00:22:52,860 --> 00:22:55,450
is actually a little bit faster
than the handwritten version.

640
00:22:55,450 --> 00:22:56,200
How could that be?

641
00:22:56,200 --> 00:22:58,050
Well basically,
we do optimization

642
00:22:58,050 --> 00:23:00,040
that you probably don't
want to do by hand.

643
00:23:00,040 --> 00:23:02,150
Because we know the entire
structure of the app,

644
00:23:02,150 --> 00:23:07,071
we can do some inlining for you,
and some code motion and things

645
00:23:07,071 --> 00:23:08,820
like that for your
loops that you probably

646
00:23:08,820 --> 00:23:10,140
don't care to do by hand.

647
00:23:10,140 --> 00:23:11,354
So it's a little bit faster.

648
00:23:11,354 --> 00:23:12,770
In general, what
we see is that we

649
00:23:12,770 --> 00:23:14,853
were very close to handwritten
dart2js performance

650
00:23:14,853 --> 00:23:16,492
on everything.

651
00:23:16,492 --> 00:23:17,950
There are cases
where we're faster.

652
00:23:17,950 --> 00:23:18,710
And unfortunately,
there are cases

653
00:23:18,710 --> 00:23:20,470
where we're a little bit slower.

654
00:23:20,470 --> 00:23:22,890
So anyway, the performance
looks really promising

655
00:23:22,890 --> 00:23:25,490
and it's nice to be able to
write in a very clean language

656
00:23:25,490 --> 00:23:26,850
and get good performance.

657
00:23:26,850 --> 00:23:29,850
So let's take a look
at how you actually

658
00:23:29,850 --> 00:23:32,600
go about using this Dart
thing in a real setting.

659
00:23:32,600 --> 00:23:34,330
SETH LADD: Yeah, thanks Kasper.

660
00:23:34,330 --> 00:23:35,366
So that's dart2js.

661
00:23:35,366 --> 00:23:36,740
A little bit about
the workflow--

662
00:23:36,740 --> 00:23:38,340
how and when do you apply that?

663
00:23:38,340 --> 00:23:40,050
Compiling JavaScript
of course is great,

664
00:23:40,050 --> 00:23:41,674
but I don't want to
do that every time.

665
00:23:41,674 --> 00:23:46,040
I want those quick iterations
that the web is known for.

666
00:23:46,040 --> 00:23:47,760
So what does it look like?

667
00:23:47,760 --> 00:23:49,227
Well, we have a
build of Chromium

668
00:23:49,227 --> 00:23:51,060
with the Dart virtual
machine embedded in it

669
00:23:51,060 --> 00:23:52,460
we've actually called Dartium.

670
00:23:52,460 --> 00:23:54,335
And that's where you
spend most of your time.

671
00:23:54,335 --> 00:23:56,200
Those are your quick
edit reload cycles.

672
00:23:56,200 --> 00:23:58,640
So let's look at
what that feels like.

673
00:23:58,640 --> 00:24:00,544
Here's a build of Dart Editor.

674
00:24:00,544 --> 00:24:01,960
You don't have to
use Dart Editor,

675
00:24:01,960 --> 00:24:03,376
but it does ship
with the project.

676
00:24:03,376 --> 00:24:05,120
It's a stripped down
version of Eclipse.

677
00:24:05,120 --> 00:24:06,360
In fact, I like to show this.

678
00:24:06,360 --> 00:24:07,920
I showed this screen to
somebody, and they're like,

679
00:24:07,920 --> 00:24:08,540
oh you have a bug?

680
00:24:08,540 --> 00:24:10,710
You're missing like 78
more preferences in there?

681
00:24:10,710 --> 00:24:13,510
Like, no, no actually,
we took those out.

682
00:24:13,510 --> 00:24:15,890
So it's optimized for
writing Dart code.

683
00:24:15,890 --> 00:24:17,500
Probably the best
way to get started

684
00:24:17,500 --> 00:24:19,000
is-- let's just
create a sample app.

685
00:24:19,000 --> 00:24:23,790
So luckily, Eric showed
us Polymer before.

686
00:24:23,790 --> 00:24:25,910
Dart has been porting
Polymer, polymer.dart.

687
00:24:25,910 --> 00:24:28,400
So we're totally in bed with
this web components things.

688
00:24:28,400 --> 00:24:30,130
We think it's the bee's knees.

689
00:24:30,130 --> 00:24:31,606
Here is a sample application.

690
00:24:31,606 --> 00:24:32,980
You get all the
skeleton for you.

691
00:24:32,980 --> 00:24:34,080
You've got the HTML.

692
00:24:34,080 --> 00:24:36,630
You've got the custom
elements, the CSS.

693
00:24:36,630 --> 00:24:38,810
So let's just run this
here to see what it's like.

694
00:24:38,810 --> 00:24:41,864
It's very simple here, but
we're going to run in Dartium.

695
00:24:41,864 --> 00:24:42,780
See, it pops right up.

696
00:24:42,780 --> 00:24:44,840
No compiles time needed.

697
00:24:44,840 --> 00:24:46,127
Click me, OK button.

698
00:24:46,127 --> 00:24:46,710
Click counter.

699
00:24:46,710 --> 00:24:47,220
OK, cool.

700
00:24:47,220 --> 00:24:49,560
So it gives you just the
core to get started with.

701
00:24:49,560 --> 00:24:53,486
Let's look a little bit at how
this application is written.

702
00:24:53,486 --> 00:24:54,610
Hopefully you can see this.

703
00:24:54,610 --> 00:24:57,667
So the polymer
element looks pretty

704
00:24:57,667 --> 00:24:59,500
much like what Eric was
showing you earlier.

705
00:24:59,500 --> 00:25:02,660
So the HTML aspects of building
highly declarative apps

706
00:25:02,660 --> 00:25:05,066
with Dart are very similar
to the JavaScript side.

707
00:25:05,066 --> 00:25:07,440
The difference though, instead
of implementing the custom

708
00:25:07,440 --> 00:25:09,735
element with JavaScript, you
can implement it with Dart.

709
00:25:09,735 --> 00:25:12,360
Dart has classes, so it makes a
ton of sense to be able to say,

710
00:25:12,360 --> 00:25:15,630
one class for one
custom element.

711
00:25:15,630 --> 00:25:16,400
So this is cool.

712
00:25:16,400 --> 00:25:17,920
And I'll show you a couple
other features, because Dart

713
00:25:17,920 --> 00:25:19,586
is structured, and
this editor gives you

714
00:25:19,586 --> 00:25:21,650
some nice productivity benefits.

715
00:25:21,650 --> 00:25:27,250
Let's say I want to add a reset
count, and then a method here.

716
00:25:27,250 --> 00:25:28,540
OK.

717
00:25:28,540 --> 00:25:29,220
Code completion.

718
00:25:29,220 --> 00:25:31,178
Because we can statically
analyze your program,

719
00:25:31,178 --> 00:25:33,190
we know what you
can call right here.

720
00:25:33,190 --> 00:25:34,209
And it's real time.

721
00:25:34,209 --> 00:25:35,250
So that's pretty awesome.

722
00:25:35,250 --> 00:25:38,020
Now I'll also go in and infer
the local stuff as well.

723
00:25:38,020 --> 00:25:39,440
OK, that's pretty cool.

724
00:25:39,440 --> 00:25:42,335
Now, the other neat thing about
statically analyzable language

725
00:25:42,335 --> 00:25:44,490
is it can understand
your program.

726
00:25:44,490 --> 00:25:46,810
So let's look at
this field count.

727
00:25:46,810 --> 00:25:49,310
Notice how it only highlights
the uses of that field.

728
00:25:49,310 --> 00:25:51,897
It's not doing a string
search and replace here.

729
00:25:51,897 --> 00:25:53,730
So it leaves out some
of the other accounts,

730
00:25:53,730 --> 00:25:55,521
even though obviously
it's the same string.

731
00:25:55,521 --> 00:25:57,490
So we can rename.

732
00:25:57,490 --> 00:25:59,300
We can say my account.

733
00:25:59,300 --> 00:26:01,769
And it only renames actual
usages of that field, again

734
00:26:01,769 --> 00:26:03,685
the power of a statically
analyzable language.

735
00:26:03,685 --> 00:26:06,930
I'm going to undo that
because I'm scared of bugs.

736
00:26:06,930 --> 00:26:08,730
OK, cool.

737
00:26:08,730 --> 00:26:10,120
Once you're in an
editor, and you

738
00:26:10,120 --> 00:26:12,650
have an actual virtual machine,
you can set breakpoints.

739
00:26:12,650 --> 00:26:14,030
So let's go back.

740
00:26:14,030 --> 00:26:15,190
We set a breakpoint there.

741
00:26:15,190 --> 00:26:16,600
We're going to re-run the app.

742
00:26:16,600 --> 00:26:19,420
And if I click the button, and
it all works-- yes, OK, great.

743
00:26:19,420 --> 00:26:21,920
So it jumps back to
the editor, and you're

744
00:26:21,920 --> 00:26:23,420
in the familiar
editing environment,

745
00:26:23,420 --> 00:26:25,430
with full breakpoints.

746
00:26:25,430 --> 00:26:26,400
You can inspect.

747
00:26:26,400 --> 00:26:27,290
This is really cool.

748
00:26:27,290 --> 00:26:28,510
I can jump in here.

749
00:26:28,510 --> 00:26:30,030
I want to inspect this instance.

750
00:26:30,030 --> 00:26:32,854
I don't know if you guys
can see this, actually.

751
00:26:32,854 --> 00:26:34,520
Trust me, that says
count and then five,

752
00:26:34,520 --> 00:26:36,850
so it's a live object inspector.

753
00:26:36,850 --> 00:26:39,400
So that's really cool.

754
00:26:39,400 --> 00:26:40,530
Let's move on.

755
00:26:40,530 --> 00:26:43,390
This app was kind of neat,
but it's also kind of boring.

756
00:26:43,390 --> 00:26:45,590
So I think we can do
a little bit better.

757
00:26:45,590 --> 00:26:48,470
In fact, that gray button,
I want to make fancier.

758
00:26:48,470 --> 00:26:51,700
So this is where a package
management system comes in.

759
00:26:51,700 --> 00:26:54,230
Our package management
system, Pub-- and let's

760
00:26:54,230 --> 00:27:00,417
see if we can go here--
has over 500 packages in it

761
00:27:00,417 --> 00:27:02,500
already from our open
source community, everything

762
00:27:02,500 --> 00:27:04,376
from server-side stuff
to client-side stuff,

763
00:27:04,376 --> 00:27:06,672
to game, crypto, you name it.

764
00:27:06,672 --> 00:27:09,120
Ah, here, look at
this-- fancy button.

765
00:27:09,120 --> 00:27:11,100
OK, so our Pub package
management system

766
00:27:11,100 --> 00:27:13,340
also has custom elements in it.

767
00:27:13,340 --> 00:27:16,004
So if you like web components,
you want to reuse them,

768
00:27:16,004 --> 00:27:18,170
package management system
is a great way to do that.

769
00:27:18,170 --> 00:27:20,960
So let's make our
button a little fancy.

770
00:27:20,960 --> 00:27:23,700
Let's load up the
pubspec.yaml file.

771
00:27:23,700 --> 00:27:27,280
This defines my application
and its dependencies.

772
00:27:27,280 --> 00:27:28,730
And certainly I
depend on polymer.

773
00:27:28,730 --> 00:27:32,400
Let's depend on fancy_button.

774
00:27:32,400 --> 00:27:33,010
OK, great.

775
00:27:33,010 --> 00:27:34,600
So now the editor
is kicking off pub.

776
00:27:34,600 --> 00:27:36,680
He's going to go download
it, and install it, and make

777
00:27:36,680 --> 00:27:37,690
sure it all works for my app.

778
00:27:37,690 --> 00:27:39,190
I'm a little
impatient, so I'm going

779
00:27:39,190 --> 00:27:41,860
to go over here and show
you what that looks like.

780
00:27:41,860 --> 00:27:45,280
We're going to go
into click-counter.

781
00:27:45,280 --> 00:27:48,140
And just like regular web
components and HTML imports,

782
00:27:48,140 --> 00:27:50,820
you can import the
definition of fancy button.

783
00:27:50,820 --> 00:27:54,150
You can say that this
button is a fancy button.

784
00:27:54,150 --> 00:27:56,050
Now this is all backed by Dart.

785
00:27:56,050 --> 00:27:58,080
It's a real web component,
and it came to us

786
00:27:58,080 --> 00:28:00,020
from that package
management system.

787
00:28:00,020 --> 00:28:02,300
Let's see if I indeed
made it a little fancier.

788
00:28:02,300 --> 00:28:04,050
So run in Dartium.

789
00:28:04,050 --> 00:28:05,460
And yes, awesome.

790
00:28:05,460 --> 00:28:06,180
OK.

791
00:28:06,180 --> 00:28:07,130
Pink, OK.

792
00:28:07,130 --> 00:28:09,126
So it's a nice
demonstration of how

793
00:28:09,126 --> 00:28:12,670
you can use a package management
system and reuse code.

794
00:28:12,670 --> 00:28:14,840
Finally, we need to get
this out into the wild.

795
00:28:14,840 --> 00:28:17,130
It's one thing to iterate
very quickly in Dartium,

796
00:28:17,130 --> 00:28:19,740
but it's another thing
to be able to-- find

797
00:28:19,740 --> 00:28:25,260
my original slides, boop,
OK-- do your final testing

798
00:28:25,260 --> 00:28:28,850
in production browsers like
Firefox and stable Chrome.

799
00:28:28,850 --> 00:28:30,790
And this is our pub
build system comes in.

800
00:28:30,790 --> 00:28:33,290
So iterate very fast with
Dartium and the editor,

801
00:28:33,290 --> 00:28:34,711
and then run a
nice build process.

802
00:28:34,711 --> 00:28:36,210
Now more and more
web developers are

803
00:28:36,210 --> 00:28:39,430
moving to a build process that
does really nice optimizations.

804
00:28:39,430 --> 00:28:41,012
For one, ours runs dart2js.

805
00:28:41,012 --> 00:28:42,595
You saw some of the
nice optimizations

806
00:28:42,595 --> 00:28:44,100
it can actually
do with your code.

807
00:28:44,100 --> 00:28:45,960
Tree shaking-- it
can minify your app.

808
00:28:45,960 --> 00:28:48,135
If it totally knows
your entire application,

809
00:28:48,135 --> 00:28:50,132
it can do a really smart
job at minification.

810
00:28:50,132 --> 00:28:51,340
It can also do concatenation.

811
00:28:51,340 --> 00:28:53,310
It can take all
your dependencies,

812
00:28:53,310 --> 00:28:55,820
all your custom elements,
and jam them all in together

813
00:28:55,820 --> 00:28:59,540
into one single file, making
the deployment and performance

814
00:28:59,540 --> 00:29:00,310
very, very good.

815
00:29:00,310 --> 00:29:01,949
In fact, in this
particular example,

816
00:29:01,949 --> 00:29:03,990
you saw we had a lot of
dependencies, third party

817
00:29:03,990 --> 00:29:06,210
stuff, custom libraries,
core libraries.

818
00:29:06,210 --> 00:29:07,790
This app compiles
them and gzips down

819
00:29:07,790 --> 00:29:10,000
to smaller than some CSS
frameworks you guys use.

820
00:29:10,000 --> 00:29:11,480
So I think it's kind of cool.

821
00:29:11,480 --> 00:29:14,020
And just to show you
that that all works,

822
00:29:14,020 --> 00:29:17,410
here we have it in Firefox.

823
00:29:17,410 --> 00:29:18,990
This is Dart, compiled
to JavaScript,

824
00:29:18,990 --> 00:29:22,470
using web components deployable
to a production browser today.

825
00:29:22,470 --> 00:29:24,160
This stuff is real
and you can use it.

826
00:29:24,160 --> 00:29:27,141

827
00:29:27,141 --> 00:29:28,890
And then, when you're
finally ready to go,

828
00:29:28,890 --> 00:29:30,700
you have a nice build
directory, which

829
00:29:30,700 --> 00:29:33,510
has just the assets, just
those minified files,

830
00:29:33,510 --> 00:29:36,200
in a very nice directory you can
pick up and put onto the web.

831
00:29:36,200 --> 00:29:39,362
All that concatenation, all
the minification, done for you.

832
00:29:39,362 --> 00:29:40,570
KASPER LUND: Nice and simple.

833
00:29:40,570 --> 00:29:41,694
SETH LADD: Nice and simple.

834
00:29:41,694 --> 00:29:43,030
So, how do you get started?

835
00:29:43,030 --> 00:29:45,290
Well, we relaunched the website,
and we have a really nice code

836
00:29:45,290 --> 00:29:45,790
lab.

837
00:29:45,790 --> 00:29:48,400
It takes under an hour,
walks you through zero to 60.

838
00:29:48,400 --> 00:29:51,220
You get to build a really cool
pirate name badge generator.

839
00:29:51,220 --> 00:29:52,770
A really nice way
to try Dart, built

840
00:29:52,770 --> 00:29:54,855
for if you don't know
anything about Dart.

841
00:29:54,855 --> 00:29:56,480
And I want to leave
you with a reminder

842
00:29:56,480 --> 00:29:59,460
that Dart 1.0 is
for the modern web.

843
00:29:59,460 --> 00:30:02,430
It's a platform
you can use today.

844
00:30:02,430 --> 00:30:03,500
It's easy to get started.

845
00:30:03,500 --> 00:30:04,291
Go to dartlang.org.

846
00:30:04,291 --> 00:30:07,840
We have APIs, code labs,
articles, tutorials.

847
00:30:07,840 --> 00:30:10,730
And everything you saw here,
even the web component stuff,

848
00:30:10,730 --> 00:30:12,259
all compiles to JavaScript.

849
00:30:12,259 --> 00:30:13,800
So you can write
Dart, take advantage

850
00:30:13,800 --> 00:30:15,720
of those great semantics,
language, and tools,

851
00:30:15,720 --> 00:30:18,430
and still deploy
across the modern web.

852
00:30:18,430 --> 00:30:23,607
So I think with that-- I
think we're all ready to go.

853
00:30:23,607 --> 00:30:24,440
Thank you very much.

854
00:30:24,440 --> 00:30:25,990
Appreciate it.

855
00:30:25,990 --> 00:30:27,061

