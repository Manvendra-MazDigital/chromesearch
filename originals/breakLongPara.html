<style>
* {
font-family: Open Sans;
}
p {
margin: 0;
text-indent: 1.5em;
}
p:first-child {
text-indent: 0;
}
</style>

<p><strong class="speakerName">Paul Irish</strong>: Or not. But that's cool. But I'm getting my immediate feedback, so I'm getting my Sass immediately recompiled on the fly and then my CSS is being served back to the browser. Without even the browser refreshing I can change the page, my scroll position is maintained and just the style sheet is being swapped in, which is really nice. All right. So I'm going to show a little bit of the browser dev tools inside Chrome, some features that help especially with building applications that you may not be aware of. The first is sourceURL. And this is a feature that's been in the browser for quite awhile. This is a little demo set up by Ryan Sutton, and so we have a little bit of Coffescript right here in the middle. I'm going to make a small little edit to this Coffescript first. Nice. Cool. I'll bring up the Chrome dev tools. And — that's pretty good. Nice. Now, normally I can take this Coffescript, I can run it through Coffescript.js, compile it into its JavaScript form, and if I run it, it goes through eval. And normally when you take text and run it through eval, it evaluates, but it just kind of disappears into thin air. SourceURL is a way to basically treat that as a file. So if you see down at the bottom I'm adding googleio.js and adding to compile. Now you see it over here in the Chrome dev tools. And if you look over here we have what I just added in the Coffescript, now compiled to JavaScript, and at the side over here is the sourceURL. So this little line is indicating, hey, dev tools. I got this text, I threw it into eval, but can you treat it as a file? Thanks very much, that would be great. So this is really nice, too. So not only is it a file, but I get all the features that I would expect. So let's say break points. First I'll just make sure that my cube function is working all nicely. Yes, good. Cube files 125. At a break point cube of five we break. I can't actually check the value of X right now. We're looking good. Yes, sure, we'll continue. Or I can do a live edit. I can immediately change this file on the fly, we'll return 2 from square so now let me ask for a cube and it should be 5 times 2. Cool. And we get our result, which is 10. So I'm getting live edit and break points on some JavaScript which was compiled down from Coffescript all on the fly. I'm showing up as real files. That's pretty nice. Ember actually uses sourceURL to great effect to — Ember the JavaScript library, to emulate modules, which is really, really cool. Another feature I want to show real quick is source maps. So if I bring back open my local HTML5 Please and view the source, down at the bottom is my original sources for the project. Looks like we had some script tags pulling in a few libraries and then this script.js that I did before, but what really gets served to the browser is script.min.js, which is minified. My Chrome extension is critifying this for me, but I really want you to see that it's minified. Okay, cool. Thank you, Chrome extension. All right. So the browser is actually receiving the minified source, of course, But down at the very bottom of it is a little indication similar to what we saw with sourceURL, only this time it's source mapping URL. And this points over to a map file. And this map file does — basically takes the identifiers in this compiled source and maps it back to my original sources and says these are the files. And so what I can get are the results. I open up my dev tools and instead of seeing script.min.js I see my original sources all in here. And the cool thing is that the same thing works over here. Here's my nice edits that I made. I can apply break points and click on any — and now we're actually broken in my original source even though the browser is interpreting the minified version. So this is great for an environment like production where you're serving up the compiled sources, but you want to be able to debug the original things you typed up. All right. Cool. Lastly, if you noticed, this might look a little different to you. First of all, the dev tools are on the right-hand side. If you open up the settings panel which is down here in the bottom right, we have a few things in there. So doc to right, which moves it over there. Really like it in doc to right mode. We have our step to bugging on the right-hand side and I can get that out of the way. My file's over here and I can get that out of the way and view my scripts in their full glory. I can also jump to different scripts. Instead of using this menu I can kind of hit Command O and see all those scripts that are available. It's kind of get completion there. Or Command Shift O and see all the functions that are defined in this file, and now I'll just bind — yes, the sort function is what I'm looking for. I can jump immediately to that definition. So a lot of nice things to make dealing with a large JavaScript code base a bit easier instead of the dev tools. All right. Now, I wonder about testing for a moment. And this right here is actually a picture from a series that we have up in the bathrooms at the Googleplex in Mountain View, California. The series is called Testing on the Toilet. So each week there's a new sheet that gives you some good tips for writing test against your software. Good reading material, too. But it's important to write unit tests, so I have a few ideas here. First is that you should author your test in whatever you feel most comfortable in, so these days for JavaScript it would probably be Jasmine Q unit or mocha. They all have kind of different assertion styles, and find whichever you like and you feel comfortable writing those assertions in. Build up a large test suite and then it feels so nice as a security blanket when you're doing refactoring. The other thing is you can execute these tests that you've written in a variety of different sessions, so like — settings. The first one is, of course, in the browser, so this is the HTML5 test suite. Run inside Q unit, inside the browser. Pretty common. You can also run the same tests inside a headless browser, on demand, on the command line, so I'll show that right now, I'll use grunt, which is a node-based command line tool and type grunt Q unit. So this is actually going to fire up phantom.js, which is a headless WebKit instance, toss in those Q unit test suite and then check that those indeed five assertions did pass. So I'm able to run the exact same tests just without leaving my command line here. I can also run this — run tests after I push it up to version control, and let something like continuous integration server test these things, so we do this on the modernizer project. So this is Travis. Every time we put up a new commit on GitHub, Travis comes in, pulls down the latest, and actually does a similar thing, it takes our Q unit test, throws it into phantom.js, and then — and then we're looking good. It tells us if we're indeed passing or had a little bit where I made some commits and broke some things. We fixed that. It's good. Another cool one. This is really nice, again, from Ryan Setton. He wrote a tool where we can take tests, not only get results on the command line, but be able to test browsers in the cloud, so I'm going to take this same test suite that's in Q unit, and toss it to bunyup, and bunyup will then take that and call up a browser static, which has a lot of browsers in the cloud and also mobile emulators. I'm not going to wait for this finish, but it just called up some IOS emulators, and it's gonna — and it can check my test suite against those and get the results back. So this is really nice. I can write my tests, be able to execute them, in a number of different devices and browsers on the fly without ever leaving right here. All right. When you have a build system, you wrote all this stuff, you need to get it out to production. A lot of things you need to do with a pretty hefty Web app, and tackling all of these on your own every time — every time you make changes is not going to work out so well, so you're going to need some help. I'm going to get into a little bit of this later. But after you deploy, one of the things that I think that we often forget is keeping track of your errors that clients have. So this is a screen shot from errorception, and it's showing my report from a Web app that I somewhat hastily put up with some friends, and telling me that I actually have — people are hitting some JavaScript errors in I9 and Chrome, and, you know, I didn't hit any of these errors, and none of the other developers did, but — but real users in the field are hitting these, so I can get these reports and make sure that I can fix all these for everyone. Okay. So that was a lot of stuff, and sorry, but — so I was showing a lot of things, and it was kind of like this is here, this is here, and the feeling that I got was that this was kind of like — I mean, there's a lot of tools, and they're all useful, but they kind of didn't have this smooth integration, so me and some people on my team thought about this and we thought maybe there's something that we could do to kind of make this work flow a bit more smooth. And so I'm going to talk to you today about a project that we're going to show off called Yeoman. So the ideas behind Yeoman is that we think you should be able to go from your idea to a rough prototype in ten minutes. I say "rough", but I mean like a prototype that you're actually going to continue developing, like you're using all the tools inside that prototype that you would normally use in a Web app, and you're going to keep going from that. We also want to make sure that we can reduce friction from the things that you should be doing, such as testing. And now, you probably heard that you should not repeat yourself when you're coding; same thing applies to your tools. You shouldn't have to type — you shouldn't have to run build.sh every single time you change a file. So these things should be automatic. So what Yeoman is is it's an open source set of tools, frameworks, libraries, that accelerate building good Web apps. So has some things in it, so authoring abstractions, linting, testing, build tools, these things that I've been talking about, but we've been focusing on providing nice, smooth developer ergonomics so it feels good to use. So there's a few things inside of it. Things — these names you should be familiar with: Compass, sass, CoffeeScript, module support, by the way of AMD, and ecmascript 6. We'll get to that in a minute. Twitter bootstrap, stripped HTML5 boilerplate, some testing things, Jasmine, phantom jas, image compression. All right. So I'm going to do a demo and I'm actually going to skip the first step, the first step is a little shell script that gets your developer environment all set and going, gets you installed with node and NPM and home brew. Get a few of the dependencies out of the way. You're going to want, because, you know, sometimes I'll end up switching to a new machine, and getting your own developer environment going takes awhile. So we wanted to make sure that you could get rid of that — an old set in a few minutes. All right. So I'm going to go to temp. Nice. All right. We're going to kick off a new project. So a lot of what we have in Yeoman is accessible on the command line, and so I can just type Yeoman command, and we have a few things available in here. We have init, build, server, test, and some other stuff we're going to get to later. So what we're going to do here is we're going to start a new project. I'll name this project IO app. And inside our app, we're going to type Yeoman in it. Cool. So we're starting off a new project. Things are good. It's going to ask us a few questions. What's the name of the project. Description. It's going to pull a little bit of the get metadata from my get config, so some of these defaults probably will make sense for me. And that's good. Now, it's going to take all of this and create a nice little package .json file which I might want. Now there's a few things it's going to ask me if I want. Do I want Twitter bootstrap? Yeah. Required JS? I'll pull that in for now. And experimental support for ecmascript 6 modules, let's do it. All right. I say yes, we get a bunch of files written and we're good. Just to show kind of what this created, I'm going to take a tree and pipe it through to Les, so let's see, we've got a good deal of bootstrap here, and then bootstrap — a little bit of HTML5 boilerplate going on here, some more bootstrap, Jasmine going on down here. Cool. Now — now, the next thing I'm just going to open this up inside my text editor, and so we have here a little stripped version of HTML5 boilerplate and I'll add in some text, and I'm actually just going to use a little bit of zen coding to save some time. Nice. Hello I/O. Yeoman in action. Now, we have a server built into Yeoman. And the cool thing here is that we're actually taking — because when you run a server, you actually want to be able to watch your changes too. So you set up a server. It immediately actually opens up that result inside the browser as well, and you're off. So now I'm going to open up my style sheet. All right. And we have in here, we're going to pull in Twitter bootstrap, and I'll bring that in here, and now watch as I hit save on this file. Hit save. I'll watch task. Notice that it immediately changes. And then we run it through compass, we hit the reload task and you saw that it changes up here. So I'm now able to add whatever I want inside my text editor, and get immediate results down at the bottom, or in my browser. So do a little bit of styles here. Save. That looks pretty good. A little bit of color over here. Save. Nice. Cool. So I'm able to just go run all this immediately through Coffee Script — sorry, through compass, compile it down to my resulting CSS and then get the results immediately showing over here. The cool thing is that we're actually not even using any sort of Chrome extension to get the lab reload functionality inside — inside the view in my browser. Now, this is cool, and I wanted to bring up testing, because I mentioned that before. We can just go over to slash test, and we have our Jasmine test suite, all green, looking good, we see in the browser, looks good. Like I said before, I think it's really nice to have this available at the command line two, so we'll type in Yeoman test. We're going to take that jasmine suite and throw it into phantom.js and get our same passing results. Cool. I should mention here that we're using grunt again to use a lot of this system level functionality. It's a great project for this sort of thing, and we're leaning heavily on it. All right. Cool. Now, let's move over to another project. I want to bring up this application, and we'll kick it off right now. Bring this up. Nice. All right. So this should look pretty familiar to you. This is your standard to-do app. Common — a large portion of this came from the to do MBC project where you can see a basic to do app built in a number of different frameworks and libraries. So let's see, go to I/O, do a talk. Nice. Cool. So we've got this basic functionality, and that's good. I want to show a little bit of how this was built. So right inside here, we view source, and we're pulling in required.js and the main module that we're pulling in is main. And so I'm actually going to take a quick detour and talk about modules. All right. So modules, the quick elevator pitch on modules is that the key to building a large Web app is to not construct a large Web app; it is to break it up into small libraries and small parts. Writing code into small files feels good, and we can do that when we use modules. With structured modules we can also define what our dependencies are, and when we do this, we're actually able to just define our dependencies a single time, so let's say we're not using modules, so you would probably have your HTML file, you would have bunch of script tags in the order that they need to be in, and then you have your build system which is going to, you know, concatenate all your files, and you have to specify your order and your dependencies over there as well. Modules we can only — we can just define that structure just in one place. Another advantage is that as you develop, you might stop using code, and in modules, code you stop using just gets stripped out when it goes out to builds. So there's a few different ways to write modules, and I'm going to show two of them here. The first is AMD modules, so these are asynchronous modules. They have dependency resolution, help you to not write global variables, and it has a very rich plug-in ecosystem that I'm going to show as well as smart-build optimization. So this is an example of, let's say, a to do controller, and we're going to pull in this file, and bring it in to our app as a to do view, and then our to do controller is going to return an object that includes some stuff and then a render method. All right. Cool. Now, on to the next module. This is ES 6 modules, ecmascript 6 also ecmascript harmony. Now, this is actually coming from ecmascript committee, TC39, who thought that, you know, people were kind of doing this in the JavaScript world; let's find a way to make this actually happen in the language itself, so offering a native solution. Has a flexible syntax, beyond what we have just down here, so what we have is we're pulling in a module called "to do view", from this file, and importing it into this file, we have some functionality, and then we can export whatever we want, so in this case we're going to export a function called render where we do some stuff. Actually point out I am saying ES 6. There is a little bit of conversation happening like right now about if this is going to make it into ecmascript version 6 or the next version after that, so we'll see how that goes. But we wanted to experiment with this, and see if Yeoman could give us an ability to try out this style. So back to — back to the code. I said that this was using required.js, so I'm going to open up the — our source of this app, and I'll open up main.js. So this is the module it's pulling in, and looks like we're initializing an app right after we pull in the task app module, and we have a little coffee script pre-filter on this, so looks like — all right, cool. So this is indeed AMD, but it is of course CoffeeScript. You can see at the top we're playing in a few other modules into this file, and then we have our application set up where we're defining our structure of our to dos. Now, one of these modules that we're pulling this is this fun module, nice. And we're pulling it in with an HM pre-filter, stands for harmony. So I'm going to go over to that real quick. Fun. All right. So this here is an ecmascript harmony module. We are pulling a few things into it. So we're pulling in speech, from — from this guy over here, and this is actually the E speak speech synthesizer client, and the cool thing about this speech synthesizer is that it's actually written in C++, but it was run through emscripten which is a research project by Mozilla that can port C++ into JavaScript, and so now we're taking that and we're exposing it through ecmascript harmony modules and bringing that out, so we pull in this module, and we also got this guy going on here, and down here we're going to use this speech module at the bottom, and pull out this speak method. Cool. Coming back into our app. I can see down here when we create a new item, I'm going to uncomment out this guy, and comment out this guy. Nice. Come back here, and refresh the page. Good. And now let's try this out.</p>


<script>
var paragraphElement = document.querySelector('p');
var paragraphElementText = paragraphElement.innerHTML;
var paragraphs = [paragraphElementText];

var index = 0;
while (index < paragraphs.length) {
  var paragraph = paragraphs[index];
  // randomise paragraph length, otherwise looks too regular!
  var MAXLENGTH = 500 + Math.floor(Math.random() * 1500);
  if (paragraph.length > MAXLENGTH) {
    // add a delimiter at the end of each sentence and split with that
    var sentences = paragraph.
      replace(/([^\.][a-z]\.) ([A-Z])/g, '\$1±@£\$2').
      split('±@£');
    // remove the paragraph that's going to be split up
    paragraphs.splice(index, 1);
    var paragraph = '';
    while (sentences.length > 0) {
      paragraph += sentences.shift() + ' ';
      MAXLENGTH = 500 + Math.floor(Math.random() * 1500);
      if (paragraph.length > MAXLENGTH){
        paragraphs.splice(index, 0, paragraph);
        paragraph = '';
        ++index;
      }
    }
    paragraphs.push(paragraph); // the last one, not over-length

  } else {
    ++index;
  }
}
var splitText = paragraphs.join(' ').trim().replace(/ {2,}/g, ' ');
// console.log('>>>>>>>>>>>paragraphElementText', paragraphElementText);
// console.log('>>>>>>>>>>>splitText', splitText);
console.log('Unmatched: ', paragraphElementText.replace(splitText, ''));
paragraphs = paragraphs.map(function(item){return '<p>' + item.trim() + '</p>'});
// document.body.innerHTML = paragraphs.join('').replace(/ {2,}/g, ' ');
</script>
